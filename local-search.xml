<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Node笔记</title>
    <link href="/2020/12/16/Node%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/16/Node%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Node是什么"><a href="#Node是什么" class="headerlink" title="Node是什么"></a>Node是什么</h1><p><strong>Node</strong>是一个基于ChromeV8引擎的JavaScript<strong>代码运行环境</strong>。</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript的代码运行环境。</p><p>Node（软件）能够运行JavaScript代码，Node就是JavaScript的代码运行环境。</p><h1 id="Node-js的组成"><a href="#Node-js的组成" class="headerlink" title="Node.js的组成"></a>Node.js的组成</h1><p>Node.js是由<strong>ECMAScript</strong>及<strong>Node环境</strong>提供的一些<strong>附加API</strong>组成的，包括文件、网络、路径等待一些强大的API。所有ECMAScript语法在Node环境中都可以使用。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/ced1f2319044b7cb3ea939a1a11013e7.png"></p><h1 id="Node-js模块化开发"><a href="#Node-js模块化开发" class="headerlink" title="Node.js模块化开发"></a>Node.js模块化开发</h1><p>多个JavaScript调用有文件依赖和变量命名冲突问题。</p><p>一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。</p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>Node.js规定一个<strong>JavaScript文件</strong>就是一个模块，模块<strong>内部定义的变量和函数</strong>默认情况下在外部无法得到</p><p>模块内部可以使用<strong>exports对象进行成员导出</strong>，使用<strong>require方法</strong>导入其他模块。</p><p>导出exports：</p><p>exports.属性名 = 变量</p><p>例：const sayHi = name =&gt; `您好${name}`； exports.sayHi = sayHi;</p><p>导入：</p><p>let a = require(‘文件名’);</p><p><strong>另一种导出方式module.exports</strong></p><p><strong>exports</strong>是<strong>module.exports</strong>的别名<strong>（地址引用关系）</strong>，<strong>导出对象最终以module.exports<br>为准</strong></p><h2 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h2><p>当两者指向同一对象，两者无区别。当两者指向不同对象，导出以module.exports为准，exports导出无效。</p><p>Node.js全局对象global</p><p>在浏览器中全局对象是window，在Node中全局对象是global。</p><p>Node中全局对象下有以下方法，可以在任何地方使用，global可以省略。</p><p>console.log() 在控制台中输出</p><p>setTimeout() 设置超时定时器</p><p>clearTimeout() 清除超时定时器</p><p>setInterval() 设置间歇定时器</p><p>clearInterval() 清除间歇定时器</p><h2 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h2><p>含义：Node运行环境提供的API。因为这些API都是以模块化方式进行开发的，所以我们又称Node运行环境提供的API为系统模块</p><h3 id="fs文件操作"><a href="#fs文件操作" class="headerlink" title="fs文件操作"></a>fs文件操作</h3><p>f：file ，s：system，文件操作系统</p><p>引用：const fs = require(‘fs’)；</p><p>方法：</p><p><strong>读取文件内容</strong> fs.readFile(‘文件路径/文件名称’[，’文件编码’], callbcak);</p><p>文件读取是硬盘的操作，需要耗时，只有读取完毕触发回调函数才能引用读取结果。</p><pre><code class="hljs js"><span class="hljs-comment">// 读取上一级css目录下中的base.css</span>fs.readFile(<span class="hljs-string">&#x27;..css/base.css&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, doc</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 如果文件读取发生错误 参数err的值为错误对象 否则err的值为null</span>    <span class="hljs-comment">// doc参数为文件内容</span>    <span class="hljs-keyword">if</span> (err == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 控制台中输出文件内容</span>        <span class="hljs-built_in">console</span>.log(doc)&#125;&#125;)</code></pre><p>错误优先的回调函数</p><p><strong>写入文件内容</strong> fs.writeFile(‘文件路径/文件名称’, ‘数据’, callback);</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> content = <span class="hljs-string">&#x27;&lt;h3&gt;正在使用fs.writeFile写入文件内容&lt;/h3&gt;&#x27;</span>fs.writeFile(<span class="hljs-string">&#x27;../index.html&#x27;</span>, content, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) &#123;<span class="hljs-built_in">console</span>.log(err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;文件写入成功&#x27;</span>)&#125;)</code></pre><h2 id="系统模块path-路径操作"><a href="#系统模块path-路径操作" class="headerlink" title="系统模块path 路径操作"></a>系统模块path 路径操作</h2><p>为什么要进行路径拼接</p><p>不同操作系统的路径分隔符不统一，windows上是\或/，Linux上是/</p><p>路径拼接语法 path.join(‘路径’，‘路径’，‘路径’，·····—) 下例</p><pre><code class="hljs js"><span class="hljs-comment">// 导入path模块</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">// 路径拼接</span><span class="hljs-keyword">let</span> finialPath = path.join(<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c.css&#x27;</span>)<span class="hljs-comment">// 输出结果cat\a\b\c.css</span><span class="hljs-built_in">console</span>.log(finialPath)</code></pre><h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><ul><li><p>  大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录</p></li><li><p>  读取文件或者设置文件路径时都会选择绝对路径</p></li><li><p>  使用<strong>__dirname</strong>获取当前文件所在的绝对路径</p></li><li><p>  require比较特殊，它指向的就是文件所在的路径，所以可以用相对路径</p></li></ul><h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>就是别人写好的，具有特定功能的，可以直接使用的模块就是第三方模块，由于第三方模块通常都是多个文件组成并且被放置在一个文件夹中，所以又名包。</p><p>存在形式：1. 以js文件的形式存在，提供实现项目具体功能的API接口。</p><ol start="2"><li>以命令行工具形式存在，辅助项目开发。</li></ol><h3 id="获取第三方模块"><a href="#获取第三方模块" class="headerlink" title="获取第三方模块"></a>获取第三方模块</h3><p>npmjs.com: 第三方模块的存储和分发仓库</p><p>npm(node package manager): node的第三方模块管理工具</p><p>下载：npm install 模块名称</p><p>卸载：npm uninstall package 模块名称</p><p>全局安装与本地安装</p><p>命令行工具：全局安装 加-g</p><p>库文件：本地安装</p><h3 id="第三方模块nodemon"><a href="#第三方模块nodemon" class="headerlink" title="第三方模块nodemon"></a>第三方模块nodemon</h3><p>在Node.js中，每次修改文件都要在命令行工具重新执行该文件，nodemon帮我们解决这个问题。</p><p>安装后要把node换成nodemon</p><p><strong>终止操作就按ctrl + c</strong></p><h3 id="第三方模块nrm"><a href="#第三方模块nrm" class="headerlink" title="第三方模块nrm"></a>第三方模块nrm</h3><p>nrm(npm registry manager): npm下载地址切换工具</p><p>npm默认的下载地址在国外，国内下载速度慢</p><p>使用npm install nrm -g 下载</p><p>nrm ls 查看可用下载地址列表</p><p>切换npm下载地址 nrm use</p><h1 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h1><p>第三方模块，基于node平台开发的前端构建工具</p><p>将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令，任务就能自动执行了，提高效率。</p><h2 id="Gulp能做什么"><a href="#Gulp能做什么" class="headerlink" title="Gulp能做什么"></a>Gulp能做什么</h2><ul><li><p>  项目上线，HTML、css、js文件压缩合并</p></li><li><p>  语法转换（es6、less、—）</p></li><li><p>  公共文件抽离</p></li><li><p>  修改文件浏览器自动刷新</p></li></ul><p>即：</p><ol><li><p> 把一个文件拷贝到另一个位置</p></li><li><p> 把多个js或css文件合并成一个文件，以减少网络请求数</p></li><li><p> 对js文件和css文件进行压缩合并 以减少网络流量</p></li><li><p> 把sess或less文件编译成css</p></li><li><p> 压缩图像文件，以减少网络流量</p></li><li><p> 创建一个可以实时刷新页面内容和本地服务器等等</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p> 安装：npm install gulp</p></li><li><p> 在项目根目录下建立gulpfile.js文件</p></li><li><p> 重构项目的文件夹结构src目录放置源代码文件dist目录放置构建后文件</p></li><li><p> 在gulpfile.js文件中编写任务</p></li><li><p> 在命令行工具中执行gulp任务</p></li></ol><h2 id="Gulp中提供的方法"><a href="#Gulp中提供的方法" class="headerlink" title="Gulp中提供的方法"></a>Gulp中提供的方法</h2><ul><li><p>  gulp.src()：获取任务要处理的文件</p></li><li><p>  gulp.dest()：输出文件</p></li><li><p>  gulp.task()：建立gulp任务</p></li><li><p>  gulp.watch()：监控文件的变化</p></li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>)<span class="hljs-comment">// 使用gulp.task()方法建立任务</span>gulp.task(<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 获取要处理的文件</span>gulp.src(<span class="hljs-string">&#x27;./src/css/base.css&#x27;</span>)    <span class="hljs-comment">// 将处理后的文件输出到dist目录</span>.pipe(gulp.dest(<span class="hljs-string">&#x27;./dist/css&#x27;</span>))&#125;)</code></pre><h2 id="Gulp插件"><a href="#Gulp插件" class="headerlink" title="Gulp插件"></a>Gulp插件</h2><ul><li><p>  gulp-htmlmin: html文件压缩</p></li><li><p>  gulp-csso：压缩css</p></li><li><p>  gulp-babel：JavaScript语法转化</p></li><li><p>  gulp-less：less语法转化</p></li><li><p>  gulp-uglify：压缩混淆JavaScript</p></li><li><p>  gulp-file-include：公共文件包含</p></li><li><p>  browsersync：浏览器实时同步</p></li></ul><h2 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h2><p>gulp.task(‘default’, gulp.series(任务名));</p><p>gulp.series：按照顺序执行 gulp.paralle：可以并行计算</p><p>现在gulp.task只接受两个参数</p><h2 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h2><h3 id="node-modules文件夹的问题"><a href="#node-modules文件夹的问题" class="headerlink" title="node_modules文件夹的问题"></a>node_modules文件夹的问题</h3><ul><li><p>  文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢</p></li><li><p>  复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错</p></li></ul><h3 id="package-json文件的作用"><a href="#package-json文件的作用" class="headerlink" title="package.json文件的作用"></a>package.json文件的作用</h3><p>项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。使用<strong>npm<br>init -y</strong>命令生成。</p><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a><strong>项目依赖</strong></h3><ul><li><p>  在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖，例如，jQuery</p></li><li><p>使用npm<br>  install包名命令下载的文件会默认被添加到package.json文件的dependencies字段中</p></li></ul><h3 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h3><ul><li><p>  在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖，例如gulp</p></li><li><p>使用npm install 包名<br>  <strong>–save-dev</strong>命令将包添加到package.json文件的devDependencies字段中</p></li></ul><p><strong>–production 下载项目依赖内容</strong></p><p><strong>script作用：运用命令的别名，来简化一些操作。例如将一段命令语句声明一个别名，通过npm<br>run 别名 就可以执行这条别名里的命令</strong></p><h2 id="package-lock-json文件的作用"><a href="#package-lock-json文件的作用" class="headerlink" title="package-lock.json文件的作用"></a>package-lock.json文件的作用</h2><ul><li><p>  <strong>锁定包的版本</strong>，确保再次下载时不会因为包版本不同而产生问题</p></li><li><p>  <strong>加快下载速度</strong>，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工</p></li></ul><h1 id="Node-js中模块加载机制"><a href="#Node-js中模块加载机制" class="headerlink" title="Node.js中模块加载机制"></a>Node.js中模块加载机制</h1><p><strong>模块查找规则-当模块拥有路径但没有后缀时</strong></p><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;/find.js&#x27;</span>)<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;/find&#x27;</span>)</code></pre><ol><li><p> require方法根据模块路径查找模块，如果是完整路径，直接引入模块。</p></li><li><p> 如果模块后缀省略，先找同名JS文件再找同名JS文件夹</p></li><li><p> 如果找到了同名文件夹，找文件夹中的index.js</p></li><li><p> 如果文件夹中没有index.js就会去当前文件夹中的package.js文件中查找main选项中的入口文件</p></li><li><p> 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</p></li></ol><p><strong>模块查找规则-当模块没有路径且没有后缀时</strong></p><ol><li><p> Node.js会假设它是系统模块</p></li><li><p> Node.js会去node_modules文件夹中</p></li><li><p> 首先看是否有该名字的JS文件</p></li><li><p> 再看是否有该名字的文件夹</p></li><li><p> 如果是文件夹看里面是否有index.js</p></li><li><p> 否则找不到报错</p></li></ol><h1 id="服务器端基础概念"><a href="#服务器端基础概念" class="headerlink" title="服务器端基础概念"></a>服务器端基础概念</h1><h2 id="网站的组成"><a href="#网站的组成" class="headerlink" title="网站的组成"></a>网站的组成</h2><p>网站应用程序主要分为两大部分：客户端和服务器端</p><p>客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。</p><h2 id="Node网站服务器"><a href="#Node网站服务器" class="headerlink" title="Node网站服务器"></a>Node网站服务器</h2><p>能够提供网站访问服务的机器就是网站服务器，他能够接受客户端的<strong>请求</strong>，能够对请求做出<strong>响应</strong>。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>互联网中设备的唯一标识</p><p>IP是Internet Protocol Address的简写，代表互联网协议地址</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时<strong>上网所使用的网址</strong>。</p><p>虽然在地址栏中输入的是网址，但是最终还是会将域名转换为ip才能访问到指定的网站服务器。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>统一资源定位符，又叫URL（Uniform Resource<br>Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。</p><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>传输协议://服务器IP或域名:端口/资源所在位置标识</p><p>http：超文本传输协议，提供了一种发布和接受HTML页面的方法。</p><h2 id="开发过程中客户端和服务器端说明"><a href="#开发过程中客户端和服务器端说明" class="headerlink" title="开发过程中客户端和服务器端说明"></a>开发过程中客户端和服务器端说明</h2><p>在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/9667d2f0ef5d3194fd01c98ef7938fed.png"></p><p><strong>创建Web服务器</strong></p><p><strong>创建web服务器</strong></p><pre><code class="hljs js"><span class="hljs-comment">// 引用系统模块</span><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<span class="hljs-comment">// 创建web服务器</span><span class="hljs-keyword">const</span> app = http.createServer()<span class="hljs-comment">// 当客户端发送请求的时候</span>app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-comment">// 响应</span>res.end(<span class="hljs-string">&#x27;&lt;h1&gt;hi, user&lt;/h1&gt;&#x27;</span>)&#125;)<span class="hljs-comment">// 监听3000端口</span>app.listen(<span class="hljs-number">3000</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;服务器已启动，监听3000端口，请访问localhost:3000&#x27;</span>)</code></pre><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP协议的概念"><a href="#HTTP协议的概念" class="headerlink" title="HTTP协议的概念"></a>HTTP协议的概念</h3><p><strong>超文本传输协议</strong>（hyperText Transfer<br>Protocol，缩写：<strong>HTTP</strong>）规定了如何从网站服务器传输超文本到本地服务器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/b61a0c8588d9a22a13a18ff5ab1da97e.png"></p><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/5003849755bb396b5d1787fb60a7b41a.png"></p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ol><li><p> 请求方式（Request Method）：GET 请求数据 POST 发送数据</p></li><li><p> 请求地址（Request URL）：</p></li></ol><pre><code class="hljs js">app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;req.headers <span class="hljs-comment">// 获取请求报文</span>req.url <span class="hljs-comment">// 获取请求地址</span>req.method <span class="hljs-comment">// 获取请求方法</span>&#125;)</code></pre><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ol><li> HTTP状态码</li></ol><ul><li><p>  200 请求成功</p></li><li><p>  404 请求的资源没有被找到</p></li><li><p>  500 服务器端错误</p></li><li><p>  400 客户端请求有语法错误</p></li></ul><ol start="2"><li>内容类型</li></ol><p>text/html 说明返回html文件</p><p>text/css 说明返回css文件</p><p>application/javascript 说明返回js文件</p><p>image/jpeg 说明返回图片文件</p><p>application/json 说明返回json文件</p><p><strong>res.writeHead</strong> 方法，书写响应头</p><h3 id="HTTP请求与响应处理"><a href="#HTTP请求与响应处理" class="headerlink" title="HTTP请求与响应处理"></a>HTTP请求与响应处理</h3><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p><p>有两种请求参数</p><h4 id="GET请求参数"><a href="#GET请求参数" class="headerlink" title="GET请求参数"></a>GET请求参数</h4><p>参数被放置在浏览器地址栏中，例如：<strong>http:// localhost:3000/index?name=zhangsan&amp;age=20</strong></p><p>?开始，&amp;连接多个</p><p>url.parse(urlStr, [parseQueryString], [slashesDenoteHost]);</p><p>urlStr url字符串</p><p>parseQueryString 为true时将使用查询模块分析查询字符串，默认为false</p><p>slashesDenoteHost 为true时返回对象类型结果</p><h4 id="POST请求参数"><a href="#POST请求参数" class="headerlink" title="POST请求参数"></a>POST请求参数</h4><p>参数被放置在请求体中进行传输</p><p>获取POST参数需要使用data事件和end事件</p><p>使用querystring系统模块将参数转换为对象格式</p><p>post参数是通过事件的方式接受的</p><p>data 当请求参数传递的时候出发data事件</p><p>end 当参数传递完成的时候出发end事件</p><pre><code class="hljs js"><span class="hljs-comment">// 导入系统模块querystring用于将http参数转换为对象形式</span><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;<span class="hljs-keyword">let</span> postData = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">// 监听参数传输事件</span>req.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> postData += chunk)<span class="hljs-comment">// 监听参数传输完毕事件</span>req.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(querystring.parse(postData))&#125;)&#125;)</code></pre><h2 id="输出带有object-null-prototype问题"><a href="#输出带有object-null-prototype问题" class="headerlink" title="输出带有object: null prototype问题"></a>输出带有object: null prototype问题</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/8cb4d2f58bed5ad3000c19b3c242be7a.png"></p><p>解决方法：将对象进行JSON字符串转化（JSON.stringify()）, 然后再转化成对象</p><p>（JSON.parse()）</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件。</p><p><strong>mime 模块 判断请求资源的类型</strong></p><p><strong>动态资源</strong></p><p>相同的请求地址不同的响应资源，这种资源就是动态资源。</p><h1 id="Node-js异步编程"><a href="#Node-js异步编程" class="headerlink" title="Node.js异步编程"></a>Node.js异步编程</h1><h2 id="同步API，异步API"><a href="#同步API，异步API" class="headerlink" title="同步API，异步API"></a>同步API，异步API</h2><p>同步API：只有当前API执行完成后，才能继续执行下一个API</p><p>异步API：当前API的执行不会阻塞后续代码的执行</p><h2 id="同步API，异步API的区别（获取返回值）"><a href="#同步API，异步API的区别（获取返回值）" class="headerlink" title="同步API，异步API的区别（获取返回值）"></a>同步API，异步API的区别（获取返回值）</h2><p>同步API可以从返回值中拿到API执行的结果，但是异步API不可以</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>自己定义函数让别人去调用。</p><h2 id="同步API，异步API的区别（代码执行顺序）"><a href="#同步API，异步API的区别（代码执行顺序）" class="headerlink" title="同步API，异步API的区别（代码执行顺序）"></a>同步API，异步API的区别（代码执行顺序）</h2><p>同步API从上到下依次执行，前面代码会阻塞后面代码的执行</p><p>异步API不会等待API执行完成后再向下执行代码</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/ca95b39956909b22e1dc75005c8c0e6a.png"></p><h2 id="Node-js的异步API"><a href="#Node-js的异步API" class="headerlink" title="Node.js的异步API"></a>Node.js的异步API</h2><p>例：</p><p>fs.readFile(‘./demo.txt’, (err, result) =&gt; {});</p><p>var server = http.createServer(); server.on(‘request’, (req, res) =&gt; {});</p><p>回调地狱：异步API多层嵌套，导致代码难以维护。 <strong>promise可以解决这个问题。</strong></p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise出现的目的是解决Node.js异步编程中回调地狱的问题。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;resolve(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span> &#125;)&#125;<span class="hljs-keyword">else</span> &#123;reject(<span class="hljs-string">&#x27;失败了&#x27;</span>)&#125;&#125;， <span class="hljs-number">2000</span>)&#125;)promise.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result) <span class="hljs-comment">// &#123; name: &#x27;张三&#x27; &#125;)</span>.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error) <span class="hljs-comment">// 失败了)</span></code></pre><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">async</span> () =&gt; &#123;&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</code></pre><h4 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h4><ol><li><p> 普通函数定义前加async关键字 普通函数变成异步函数</p></li><li><p> 异步函数默认的<strong>返回值是promise对象</strong></p></li><li><p>在异步函数内部使用<strong>return关键字进行结果返回</strong> 结果会被包裹的promise对象中<br> return关键字代替了resolve方法</p></li><li><p> 在异步函数内部·使用<strong>throw关键字</strong>进行<strong>错误的抛出</strong></p></li><li><p> 调用异步函数再链式调用then方法获取异步函数执行结果</p></li><li><p> 调用异步函数再链式调用catch方法获取异步函数执行的错误信息</p></li></ol><h4 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h4><ol><li><p> <strong>await关键字只能出现在异步函数中</strong></p></li><li><p> await promise <strong>await后面只能写promise对象</strong> 写其他类型的API是不可以的</p></li><li><p> await关键字它可以暂停异步函数的执行，等待promise对象返回结果后再向下执行。</p></li></ol><p><strong>promisify util模块中的方法，用来改造现有异步函数api 让其返回promise对象<br>从而支持异步函数语法</strong></p><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><p>Express是一个基于<strong>Node平台</strong>的<strong>web应用开发框架</strong>，它提供了一系列的强大特性，帮助你<strong>创建各种Web应用</strong>。</p><p><strong>下载：</strong>npm install express</p><p><strong>框架特性：</strong></p><ul><li><p>  提供了方便<strong>简洁的路由定义</strong>方式</p></li><li><p>  对获取HTTP<strong>请求参数</strong>进行了<strong>简化处理</strong></p></li><li><p>  对<strong>模板引擎支持程度高</strong>，方便渲染动态HTML页面</p></li><li><p>  提供了<strong>中间件</strong>机制有效<strong>控制HTTP请求</strong></p></li><li><p>  拥有大量第三方中间件对功能进行扩展</p></li></ul><p>响应方法不再是end（）而是<strong>send（）</strong></p><ol><li><p> send方法内部会检测响应内容的类型</p></li><li><p> send方法会自动设置http状态码</p></li><li><p> send方法会帮我们自动设置响应的内容类型以及编码</p></li></ol><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>，中间件就是一堆方法，可以接收客户端发来的请求，可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/d2423f8ce4f619f6d55bf3e55d5c8069.png"></p><p>中间件主要由两部分构成，<strong>中间件方法</strong>以及<strong>请求处理函数</strong></p><p>中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。例如路由方法。</p><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;请求路径&#x27;</span>, <span class="hljs-string">&#x27;处理函数&#x27;</span>) <span class="hljs-comment">// 接收并处理get请求</span>app.post(<span class="hljs-string">&#x27;请求路径&#x27;</span>, <span class="hljs-string">&#x27;处理函数&#x27;</span>) <span class="hljs-comment">// 接收并处理post请求</span></code></pre><p>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p><p>默认情况下，请求从上往下一次匹配中间件，一旦匹配成功，终止匹配。</p><p>可以调用<strong>next方法</strong>将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;req.name = <span class="hljs-string">&#x27;张三&#x27;</span>&#125;)app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.send(req.name)&#125;)</code></pre><h3 id="app-use中间件用法"><a href="#app-use中间件用法" class="headerlink" title="app.use中间件用法"></a>app.use中间件用法</h3><p>app.use匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有请求</p><p>第一个参数也可以是传入请求地址，代表无论什么请求方式，只要是这个请求地址就接收这个请求。</p><pre><code class="hljs js">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(req.url)next()&#125;)app.use(<span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(req.url)next()&#125;)</code></pre><h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><ol><li><p> 路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p></li><li><p> 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</p></li><li><p> 自定义404页面</p></li></ol><h3 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h3><p>在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。</p><pre><code class="hljs js">app.use(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">&#x27;服务器发生未知错误&#x27;</span>)&#125;)</code></pre><p>同步函数抛出错误会被马上捕获到，但<strong>异步函数</strong>不行，所以要调用<strong>next（）方法</strong>，并且将错误信息通过参数的形式传递给next（）方法，即可触发错误处理中间件</p><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123; fs.readFile(<span class="hljs-string">&#x27;/file-does-not-exist&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123; <span class="hljs-keyword">if</span> (err) &#123; next(err) &#125; &#125;)&#125;)</code></pre><h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p>在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。</p><p><strong>try catch</strong>可以<strong>捕获异步函数以及其他同步代码在执行过程中发生的错误</strong>，但是不能捕获其他类型的API发生的错误，例如promise，回调函数</p><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (req, res, next) =&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">await</span> User.find(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;)&#125;<span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">ex</span>)</span> &#123;next(ex)&#125;&#125;)</code></pre><h2 id="Express请求处理"><a href="#Express请求处理" class="headerlink" title="Express请求处理"></a>Express请求处理</h2><h3 id="构建模块化路由"><a href="#构建模块化路由" class="headerlink" title="构建模块化路由"></a>构建模块化路由</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-comment">// 创建路由对象</span><span class="hljs-keyword">const</span> home = express.Router()<span class="hljs-comment">// 将路由和请求路径进行匹配</span>app.use(<span class="hljs-string">&#x27;/home&#x27;</span>, home)<span class="hljs-comment">// 在home路由下继续创建路由</span>home.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// /home/index</span>res.send(<span class="hljs-string">&#x27;欢迎来到博客展示页面&#x27;</span>)&#125;)</code></pre><pre><code class="hljs js"><span class="hljs-comment">// home.js</span><span class="hljs-keyword">const</span> home = express.Router()home.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;res.send(<span class="hljs-string">&#x27;欢迎来到博客展示页面&#x27;</span>)&#125;)<span class="hljs-built_in">module</span>.exports = home</code></pre><pre><code class="hljs js"><span class="hljs-comment">// admin.js</span><span class="hljs-keyword">const</span> admin = express.Router()admin.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;res.send(<span class="hljs-string">&#x27;欢迎来到博客管理页面&#x27;</span>)&#125;)<span class="hljs-built_in">module</span>.exports = admin</code></pre><pre><code class="hljs js"><span class="hljs-keyword">const</span> home = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./route/home.js&#x27;</span>)<span class="hljs-keyword">const</span> admin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./route/admin.js&#x27;</span>)app.use(<span class="hljs-string">&#x27;/home&#x27;</span>, home)app.use(<span class="hljs-string">&#x27;/admin&#x27;</span>, admin)</code></pre><h3 id="GET参数的获取"><a href="#GET参数的获取" class="headerlink" title="GET参数的获取"></a>GET参数的获取</h3><p>Express框架中使用<strong>req.query</strong>即可获取GET参数，框架内部会将GET参数转换为对象并返回。</p><pre><code class="hljs js"><span class="hljs-comment">// 接收地址栏中问号后面的参数</span><span class="hljs-comment">// 例如：http://localhost:3000/?name=zhangsan&amp;age=30</span>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(req.query) <span class="hljs-comment">// &#123; &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot; &#125;</span>&#125;)</code></pre><h3 id="POST参数的获取"><a href="#POST参数的获取" class="headerlink" title="POST参数的获取"></a>POST参数的获取</h3><p>Express中接收post请求参数需要借助第三方包<strong>body-parser</strong>。</p><pre><code class="hljs js"><span class="hljs-comment">// 引入body-parser模块</span><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<span class="hljs-comment">// 配置body-parser模块</span>app.use(bodyParser.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<span class="hljs-comment">// 接收请求</span>app.post(<span class="hljs-string">&#x27;/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-comment">// 接收请求参数</span><span class="hljs-built_in">console</span>.log(req.body)&#125;)</code></pre><p>extended拓展，默认值为false，即使用系统模块querystring处理请求参数的格式，当为true时，运用第三方模块qs来对请求参数进行处理，虽然qs的功能比querystring强大，但目前用querystring就足够了。</p><h3 id="Express路由参数"><a href="#Express路由参数" class="headerlink" title="Express路由参数"></a>Express路由参数</h3><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/find/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(req.params) <span class="hljs-comment">// &#123; id: 123 &#125;</span>&#125;)<span class="hljs-comment">// localhost:3000/find/123</span></code></pre><p>不传递参数将无法访问页面</p><h3 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h3><p>通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript文件等。</p><pre><code class="hljs js">app.use(express.static(<span class="hljs-string">&#x27;pubilc&#x27;</span>))</code></pre><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方原art-template模板引擎的基础上封装了express-art-template。</p><p>下载：</p><p>npm install –save art-template</p><p>npm install –save express-art-template</p><pre><code class="hljs js"><span class="hljs-comment">// 当渲染后缀为art的模板时 使用express-art-template</span>app.engine(<span class="hljs-string">&#x27;art&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))<span class="hljs-comment">// 设置模板存放目录</span>app.set(<span class="hljs-string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>))<span class="hljs-comment">// 渲染模板时不写后缀 默认拼接art后缀</span>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;art&#x27;</span>)app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 渲染模板</span>res.render(<span class="hljs-string">&#x27;index&#x27;</span>)&#125;)</code></pre><p>views是固定的，要在文件夹中生成views文件夹</p><h3 id="app-locals对象"><a href="#app-locals对象" class="headerlink" title="app.locals对象"></a>app.locals对象</h3><p>将变量设置到app.locals对象z下面，这个数据在所有的模板中都可以获取到。</p><pre><code class="hljs js">app.locals.users = [&#123;name: <span class="hljs-string">&#x27;张三&#x27;</span>,age: <span class="hljs-number">20</span>&#125;, &#123;name: <span class="hljs-string">&#x27;李四&#x27;</span>,age: <span class="hljs-number">20</span>&#125;]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML5笔记</title>
    <link href="/2020/12/15/HTML5%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/15/HTML5%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h1><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/9f8352f5b5b1520bf42cad8dbc5c2ebb.png"></p><h1 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h1><h2 id="lt-audio-gt-音频标签"><a href="#lt-audio-gt-音频标签" class="headerlink" title="&lt;audio&gt;音频标签"></a>&lt;audio&gt;音频标签</h2><p>支持格式</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/273f885407d856d683348e4e7736486b.png"></p><p>可以放多个不同格式资源在标签中，用source加载</p><p>&lt;source src=”路劲” type=”声明”/&gt;</p><p>常见属性：</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/fb7778f79a495252cfc25bf099fb87fa.png"></p><h2 id="lt-video-gt-视频标签"><a href="#lt-video-gt-视频标签" class="headerlink" title="&lt;video&gt;视频标签"></a>&lt;video&gt;视频标签</h2><p>支持格式</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/b52661c227025070a1658813470ea6df.png"></p><p>常见属性</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/4c4747d335f9bea6e45ee3dcd64478a6.png"></p><h2 id="新增input表单"><a href="#新增input表单" class="headerlink" title="新增input表单"></a>新增input表单</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/4f17f03037bb6d7fb2881ddd33376305.png"></p><h2 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/0f93bb646ce64bc05cc47268a6db1975.png"></p><h1 id="CSS3选择器"><a href="#CSS3选择器" class="headerlink" title="CSS3选择器"></a>CSS3选择器</h1><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/985017c2d1e0ae1c1db2768061efb7bc.png"></p><h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/5d664e5ce4ccdcf9c339924c703c98a5.png"></p><p>注：n可以是关键词 even 是偶数 odd是基数，也可以是公式（从0开始算起）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/1096dfcab8e490e5043d030fa6c52b61.png"></p><p>但是第0个元素或者超出了元素的个数会被忽略</p><p>nth-child（n）选择父元素里面的第n个孩子，他不管里面的孩子是否同一种类型；</p><p>如果div里有p和span标签，想选择其中的span标签，则用of-type 选择指定类型的元素</p><p>例：div span:nth-of-type(n)</p><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/1e272e7bae034f3a7a668ed2653003ce.png"></p><p>注意：1.before和after必须要有content属性</p><p>2.before在里面的内容的前面，after在里面的内容的后面</p><p>3.before和after创建一个元素，但是行内元素（inline）</p><p>4.在dom在看不到创建的元素，所以叫伪元素</p><p>5.伪元素和标签选择器一样，权重为1</p><h1 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h1><p>转换（transform）是css3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果。</p><p>二维坐标系</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/a03d02a8c95e6a8518973bc5fe0d9d32.png"></p><h2 id="移动（translate）"><a href="#移动（translate）" class="headerlink" title="移动（translate）"></a>移动（translate）</h2><p>语法：transform：translate(x,y); 或者分开写 transform: translateX(n);</p><p>transform: translateY(n);</p><p>重点：1.translate最大的优点：不会影响其他元素的位置</p><p>2.可以用%。%的长度取决于盒子自身的宽度或高度</p><p>3.对行内标签没有效果</p><h2 id="旋转（rotate）"><a href="#旋转（rotate）" class="headerlink" title="旋转（rotate）"></a>旋转（rotate）</h2><p>语法：transform：rotate( num deg)</p><p>重点：1.角度为正时，顺时针；负时，为逆时针</p><p>2.默认旋转的中心点是元素的中心点</p><h2 id="中心点（transform-origin）"><a href="#中心点（transform-origin）" class="headerlink" title="中心点（transform-origin）"></a>中心点（transform-origin）</h2><p>语法：transform-origin：x y</p><p>重点：1.注意两个参数要用空格隔开</p><p>2.x y默认50%</p><p>3.x y可以设置数值或者方位名词（top bottom left right center）</p><h2 id="缩放（scale）"><a href="#缩放（scale）" class="headerlink" title="缩放（scale）"></a>缩放（scale）</h2><p>语法：transform:scale(x, y)</p><p>优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</p><h2 id="2D转换综合写法"><a href="#2D转换综合写法" class="headerlink" title="2D转换综合写法"></a>2D转换综合写法</h2><p>1.同时使用多个转换，其格式为：transform：translate() rotate() scale()..等等</p><p>2.其顺序会影响转换的效果。（先旋转会改变坐标轴方向）所以一般把位移放在最前面。</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>动画（animation）是css3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p><p>制作动画分两步：1.先定义动画 2.调用动画</p><h2 id="用keynames定义动画（类似定义类选择器）"><a href="#用keynames定义动画（类似定义类选择器）" class="headerlink" title="用keynames定义动画（类似定义类选择器）"></a>用keynames定义动画（类似定义类选择器）</h2><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> 动画名称 &#123;0% &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;&#125;100% &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;&#125;&#125;</code></pre><p>1.可以做多个状态变化 keyframe（关键帧）</p><p>2.里面的百分比要用整数</p><h2 id="动画序列"><a href="#动画序列" class="headerlink" title="动画序列"></a>动画序列</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/9f9b6bf598ca2486bd48a0f08ebf9e2a.png"></p><p><strong>动画属性</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/e628dfa8e2e7084fb1b4fa34c1472626.png"></p><h2 id="动画简写属性"><a href="#动画简写属性" class="headerlink" title="动画简写属性"></a>动画简写属性</h2><p>animation：动画名称 持续时间 运动速度 何时开始 播放次数 是否反方向<br>动画起始或者结束的状态</p><p>注意：</p><ol><li><p>简写属性里面不包括animation-play-state</p></li><li><p>同一个元素添加多个动画效果时，一个animation属性，用逗号（<strong>，</strong>）隔开。</p></li></ol><h2 id="速度曲线细节（animation-timing-function）"><a href="#速度曲线细节（animation-timing-function）" class="headerlink" title="速度曲线细节（animation-timing-function）"></a>速度曲线细节（animation-timing-function）</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/9d4d9052c822821941c4f4839370efc9.png"></p><h1 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h1><h2 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/d71f70b9d442b726ea7c671c380c629a.png"></p><h2 id="移动（translate3d）"><a href="#移动（translate3d）" class="headerlink" title="移动（translate3d）"></a>移动（translate3d）</h2><p>跟2D移动差不多，多了一个z轴。z轴移动一般用px单位。translate3d中的xyz值不能省略，没有就写0。</p><h2 id="透视（perspective）"><a href="#透视（perspective）" class="headerlink" title="透视（perspective）"></a>透视（perspective）</h2><p>透视我们也称之为视距：视距就是人的眼睛到屏幕的距离。想要网页产生3D效果需要透视。</p><p>注意：</p><p>1.距离透视点越近的在电脑平面成像越大，越远就越小。</p><p><strong>2.透视写在被观察元素的父盒子上面的</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/707b8f847530e84d2423e73b515c0b66.png"></p><p>d：视距，人眼睛到屏幕距离。</p><p>z：z轴，物体距离屏幕的距离。z轴越大，看到的物体越大</p><h2 id="3D旋转-rotate3d"><a href="#3D旋转-rotate3d" class="headerlink" title="3D旋转(rotate3d)"></a>3D旋转(rotate3d)</h2><p>可以指定x,y,z轴，让元素旋转。</p><p>语法：transform：rotateX( num deg); transform：rotateY( num deg);<br>transform：rotateZ( num deg);</p><p>transform: rotate3d(x, y, z, deg)；:<br>沿着自定义旋转deg为角度。xyz是表示旋转的矢量(1,<br>-1)，是表示你是否希望沿着该轴旋转，最后一个表示旋转角度。</p><p><strong>左手准则</strong>：左手拇指指向x，y轴的正方向，其余手指的弯曲方向就是该元素沿着x，y轴旋转的方向</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/9c23210ed743abf45d045a9a54566b8b.png"></p><h2 id="3D呈现（transform-style）"><a href="#3D呈现（transform-style）" class="headerlink" title="3D呈现（transform-style）"></a>3D呈现（transform-style）</h2><p>作用：控制子元素是否开启三维立体环境。</p><p>参数：flat——子元素不开启3d立体空间，默认的。 preserve-3d——子元素开启立体空间</p><p>注意：代码写给父级，但影响的是子元素。</p><h1 id="浏览器私有前缀"><a href="#浏览器私有前缀" class="headerlink" title="浏览器私有前缀"></a>浏览器私有前缀</h1><p>浏览器私有前缀是为了兼容老版本的写法，比较新版本的浏览器无须添加</p><p>-moz-：代表firebox浏览器私有属性</p><p>-ms-：代表ie浏览器私有属性</p><p>-webkit-：代表safari-chrome私有属性</p><p>-o-：代表Opera私有属性</p><h1 id="移动布局基础"><a href="#移动布局基础" class="headerlink" title="移动布局基础"></a>移动布局基础</h1><p>国内主流的浏览器内核一般为webkit，所以兼容移动端的浏览器，考虑webkit的兼容就可以了。</p><p>调试方法：**1.**Chrome DevTool（谷歌浏览器）的模拟手机调试</p><p>2.搭建本地web服务器，用手机访问服务器</p><p>3.用外网的服务器，直接IP或域名访问</p><h2 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h2><p>就是浏览器显示页面内容的屏幕区域。视口可以分为布局视口、视觉视口和理想视口。</p><ul><li>布局视口（layout viewport）</li></ul><p>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题</p><p>ios，android基本都将这个视口分辨率设置为980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。大小即整个网页大小</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/adf94f2f01a6c4c496d30ebe549ebf2c.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/648f4161ad36b78219c0c9e9204413ef.jpeg"></p><ul><li>视觉视口（visual viewport）</li></ul><p>字面意思，它是用户正在看到的网站的区域。大小即手机屏幕大小。</p><ul><li><strong>理想视口</strong>（ideal viewport）</li></ul><p>为了使网站在移动端最理想的浏览器和阅读宽度而设定</p><p>需要手动添写<strong>meta视口标签</strong>通知浏览器操作</p><p>meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，设备有多宽，我们布局的视口就多宽。</p><p><strong>meta视口标签</strong></p><p>标准viewport设置：&lt;meta name=”viewport” content=”width=device-width,<br>user-scalable=no, initial-scale=1.0 maximum-scale=1.0, minimum-scale=1.0”&gt;</p><p>上例：宽度等于设备宽度，不允许用户缩放，不缩放。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/825eab8d102239b4d7b746314bc800a9.png"></p><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><h3 id="物理像素和物理像素比"><a href="#物理像素和物理像素比" class="headerlink" title="物理像素和物理像素比"></a>物理像素和物理像素比</h3><ol><li><p>物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了，比如6\7\8<br> 是750*1334</p></li><li><p> 开发的时候1px不是一定等于一个物理像素的。PC端页面，1个px等于1个物理像素的，但手机上不同</p></li><li><p> 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比。</p></li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/a744f84e28ff58de7abaff6f7b1f91bc.png"></p><p>原因：Retina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。</p><h2 id="多倍图"><a href="#多倍图" class="headerlink" title="多倍图"></a>多倍图</h2><p>对于图片，在Retina屏中打开，按照物理像素比放大，会造成图片模糊</p><p>在标准的viewport设置中，使用倍图来提高图片质量。通常用二倍图，也有三倍、四倍。按实际开发需求</p><p>方法：二倍图放在宽高为一倍的盒子内。</p><h3 id="背景缩放（background-size：背景图片宽度-背景图片高度）"><a href="#背景缩放（background-size：背景图片宽度-背景图片高度）" class="headerlink" title="背景缩放（background-size：背景图片宽度 背景图片高度）"></a>背景缩放（background-size：背景图片宽度 背景图片高度）</h3><p>background-size属性规定背景图像的尺寸</p><p>只写一个参数，为宽度，高度等比例缩放。</p><p>单位：长度|百分比|cover|contain</p><p>cover：把背景图片等比例拉伸 完全覆盖盒子 可能有部分背景图片显示不全</p><p>contain：把背景图片等比例拉伸<br>当宽度或者高度到达边界，则停止缩放。所以可能有部分空白。</p><p>背景图片二倍图缩放方法：运用background-size</p><h3 id="多倍图切图（cutterman）"><a href="#多倍图切图（cutterman）" class="headerlink" title="多倍图切图（cutterman）"></a>多倍图切图（cutterman）</h3><p>ps中，选择图片，选择cutterman，选择ios/android，@3X：3倍图 @2X：2倍图<br>@1X：一倍图</p><h2 id="二倍精灵图做法"><a href="#二倍精灵图做法" class="headerlink" title="二倍精灵图做法"></a>二倍精灵图做法</h2><ol><li><p> 在firework里面把精灵图等比例缩放为原来的一半</p></li><li><p> 根据大小测量坐标</p></li><li><p> background-size：精灵图原来宽度的一半</p></li></ol><h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><ol><li><p> 单独制作移动端页面（主流）</p></li><li><p> 响应式页面兼容移动端：一个页面，兼容电脑和手机。（花费精力大，但未来应该会向这边靠拢）</p></li></ol><p>移动端技术解决方案</p><ol><li><p> 注意属性是否加webkit私有前缀</p></li><li><p> CSS初始化 normalize.css</p></li></ol><h2 id="CSS3盒子模型（box-sizing）"><a href="#CSS3盒子模型（box-sizing）" class="headerlink" title="CSS3盒子模型（box-sizing）"></a>CSS3盒子模型（box-sizing）</h2><p>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</p><p>CSS盒子模型：盒子宽度 =<br>CSS中设置的宽度width里面包含了border和padding，即padding和border不会撑大盒子。</p><p>CSS3盒子模型：box-sizing：border-box</p><p>传统盒子模型：box-sizing：content-box</p><h3 id="特殊样式"><a href="#特殊样式" class="headerlink" title="特殊样式"></a>特殊样式</h3><p>点击高亮清除：-webkit-tap-highlight-color：transparent；</p><p>去除按钮和输入框自定义样式：-webkit-appearance：none；</p><p>禁用长按页面时的弹出菜单：-webkit-touch-callout：none；</p><h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><ol><li>单独制作移动端页面</li></ol><p><strong>流式布局（百分比布局） flex弹性布局 less+rem+媒体查询布局 混合布局</strong></p><ol start="2"><li>响应式页面兼容移动端</li></ol><p><strong>媒体查询 bootstarp</strong></p><h3 id="流式布局（百分比布局）"><a href="#流式布局（百分比布局）" class="headerlink" title="流式布局（百分比布局）"></a>流式布局（百分比布局）</h3><p>通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。</p><p>为了保护元素不被无限缩放，引入最大最小宽高。</p><p><strong>max-width 最大宽度 （max-height 最小宽度）</strong></p><p><strong>min-width 最小宽度 (min-height 最小高度)</strong></p><p><strong>图片格式</strong></p><p>DPG：京东独有的图片压缩技术，节省加载时间。压缩后与webp的清晰度对比没有差距</p><p>webp：谷歌开发的一种皆在加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3</p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>传统布局：兼容性好、布局繁琐、局限性</p><p>flex弹性布局：操作简单，布局简单、PC端浏览器支持情况较差</p><p>含义：flex是flexible<br>Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局。</p><p>采用flex布局的元素，称为Flex容器（flex<br>container），简称“容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex<br>item），简称“项目”。</p><p><strong>注意：当我们父盒子设为flex布局以后，子元素的float、clear和vertical-align属性将失效</strong></p><p><strong>父项常见属性</strong></p><p><strong>flex-direction</strong>：设置主轴的方向（横向、纵向）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/fc963efa7b7904a3cabbe5564b7fb173.png"></p><p><strong>justify-content</strong>：设置<strong>主轴</strong>上的元素的子元素排列方式</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/a29503bde9861e5171627d0837fca7a4.jpeg"></p><p><strong>flex-wrap</strong>：设置子元素是否换行（flex默认不换行，如果元素过多，会挤压盒子缩小宽高放在一行内）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/71f1c1854696dacabd9f7c3862434318.png"></p><p><strong>align-items</strong>：设置<strong>侧轴</strong>上的子元素排列方式<strong>（单行）（stretch拉伸不要给子元素高度，否则无效果）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/54aabc147ca6b7d38714c85d55b2fa0b.png"></p><p>align-content：设置侧轴上的子元素的排列方式<strong>（多行）（对单行无效果）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/b9007880a294849fb06450e90a2c0405.jpeg"></p><p>使用情景</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/47e0d1794205a8231d4911dd5ec0d754.png"></p><p>flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap</p><h4 id="子项常见属性"><a href="#子项常见属性" class="headerlink" title="子项常见属性"></a>子项常见属性</h4><p><strong>flex属性</strong></p><p>flex属性定义子项目分配剩余空间，用flex来表示占多少份数</p><p>语法：flex：number （默认是0）</p><p><strong>align-self</strong> 控制子项自己在侧轴上的排列方式</p><p>align-self属性允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><p><strong>order</strong><br>属性定义项目的排列顺序，数值越小，排列越靠前，默认为0。（在主轴上排列的前后）</p><p><strong>背景线性渐变</strong></p><p>background：-webkit-linear-gradient（起始方向，颜色1，颜色2,。。。）；</p><p>背景渐变必须添加私有前缀</p><p>起始方向可以是方位名词（top，left，bottom，right）如果省略默认就是top</p><h3 id="rem适配布局"><a href="#rem适配布局" class="headerlink" title="rem适配布局"></a>rem适配布局</h3><p><strong>rem基础</strong></p><p>rem（root em）是一个相对单位，类似于em，em是<strong>父元素</strong>字体大小</p><p>不同的是rem的基准是相对于<strong>html元素</strong>的字体大小</p><p>比如，根元素（html）设置font-size=12px；非根元素设置width：2rem；则换成px表示就是24px。</p><p>rem的优点：可以通过修改html里面的文字大小来改变页面中元素的大小可以整体控制，而与em相比，因为父元素很多，所有不好控制。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>rem布局是为了适应某个特殊时期发明的布局方式，不建议使用。现在的移动端布局依旧使用百分比布局+flex布局较好。</p><h2 id="媒体查询（Media-Query）"><a href="#媒体查询（Media-Query）" class="headerlink" title="媒体查询（Media Query）"></a>媒体查询（Media Query）</h2><p>媒体查询是CSS3新语法</p><p>特点：</p><p>1.使用 @media 查询，可以针对不同的媒体类型定义不同的样式</p><p><strong>2.@media 可以针对不同的屏幕尺寸设置不同的样式</strong></p><p>3.当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面</p><p>4.目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询</p><p>语法：</p><pre><code class="hljs css"><span class="hljs-keyword">@media</span> 媒体类型 关键字 (媒体特性) &#123;<span class="hljs-selector-tag">CSS-Code</span>;  &#125;<span class="hljs-comment">/* 用@media开头注意@符号 */</span></code></pre><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/3948858191f2a9e22f37ed306aae9c26.png"></p><p><strong>关键字</strong>：将媒体类型或多个媒体特性连接到一起做为媒体查询的条件</p><p>and：可以将多个媒体特性连接到一起，相当于“且”的意思</p><p>not：排除某个媒体类型，相当于“非”的意思，可以省略</p><p>only：指定某个特定的媒体类型，可以省略</p><h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><p>每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。暂且了解三个</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/92d59a8372e506312b6f0a58e6bb95df.png"></p><p>媒体查询为了代码更简洁，我们按从小到大的顺序写。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/2dfb83167f1a54ed1f8d0b15f2d620c9.png"></p><h2 id="引入资源"><a href="#引入资源" class="headerlink" title="引入资源"></a>引入资源</h2><p>当样式比较繁多的时候，我们可以针对不同的媒体使用不同的stylesheets（样式表）。</p><p>原理，就是直接在link中判断设备的尺寸，然后引用不同的css文件。</p><p>语法：&lt;link rel=”stylesheet” media = ”mediatype and|not|only (media feature)”<br>href = ”mystylesheet.css”&gt;</p><h1 id="less基础"><a href="#less基础" class="headerlink" title="less基础"></a>less基础</h1><h2 id="维护CSS的弊端"><a href="#维护CSS的弊端" class="headerlink" title="维护CSS的弊端"></a>维护CSS的弊端</h2><p>CSS是一门非程序式语言，没有变量，函数，SCOPE（作用域）等概念</p><p>1.CSS需要书写大量看似没有逻辑的代码，CSS冗余度是比较高的</p><p>2.不方便维护及扩展，不利于复用</p><p>3.CSS没有很好的计算能力</p><h2 id="什么是Less"><a href="#什么是Less" class="headerlink" title="什么是Less"></a>什么是Less</h2><p>Less（leaner Style Sheets的缩写）是一门CSS扩展语言，也成为CSS预处理器</p><p>作为CSS的一种形式的扩展，它并没有减少CSS的功能，而是在现有的CSS语法上，为CSS加入程序语言的特性。</p><p>它在CSS的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了CSS的编写，并且降低了CSS的维护成本。</p><p>常见的CSS预处理器：Sass、Less、Stylus</p><p>一句话：<strong>Less是一名门CSS预处理语言，它扩展了CSS的动态特性</strong></p><h2 id="Less变量"><a href="#Less变量" class="headerlink" title="Less变量"></a>Less变量</h2><p>创建.less文件，在文件中编写less变量和样式。</p><p>语法： @变量名：值；</p><p><strong>命名规范</strong>：1.必须要@为前缀 2.不能包含特殊字符 3.不能以数字开头 4.大小写敏感</p><h2 id="Less编译"><a href="#Less编译" class="headerlink" title="Less编译"></a>Less编译</h2><p>需要将less文件编译生成css文件，html页面才能使用。</p><p>工具：vscode插件：eazy less。保存less文件即可生成对应的css文件。</p><h2 id="Less嵌套"><a href="#Less嵌套" class="headerlink" title="Less嵌套"></a>Less嵌套</h2><p>CSS选择器嵌套 <strong>Less嵌套写法</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/36376a0470ba4078c0f5e1a28dfad046.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/0db62e55f99112c7bb1c01f5308132e0.png"></p><p>对于交集|伪类|伪元素选择器，如果直接写在里面，编译的时候就好在父元素和交集|伪类|伪元素选择器之间加入空格从而无效化。我们需要把交集|伪类|伪元素选择器写在里面并在前面加入**&amp;符号**，这样它就被解析为父元素自身或父元素的伪类。</p><p>CSS伪类写法  <strong>Less写法</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/30529968b2f54a0083bb51735bb8ffed.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/52728fced9c6f698e122056b9f874149.png"></p><h2 id="Less运算"><a href="#Less运算" class="headerlink" title="Less运算"></a>Less运算</h2><p>任何数字、颜色或者变量都可以参与运算。Less提供了四则算术运算。</p><p>注意：1.<strong>运算符左右两侧必须加空格隔开</strong></p><p>2.两个数参与运算，如果只有一个数有单位，那么最后以这个单位为准</p><p>3.两个数参与运算，如果两个数都有单位，最后的结果以第一个单位为准</p><h1 id="rem适配方案"><a href="#rem适配方案" class="headerlink" title="rem适配方案"></a>rem适配方案</h1><ol><li><p> 让一些不能等比自适应的元素，达到当设备尺寸发生改变时，等比例适配当前设备。</p></li><li><p> 使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。</p></li></ol><p>适配方案技术使用（市场主流）</p><p>方案一：less + 媒体查询 + rem</p><p>方案二：flexible + rem</p><p><strong>方案一</strong></p><p><strong>设计稿常见宽度（基本以750为准）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/79c256b6cffaae1773bfe53b816118ba.png"></p><p><strong>动态设置html标签font-size大小</strong></p><p>假设我们把整个屏幕划分为15等份，那么字体大小=屏幕宽度/等份</p><p><strong>元素大小取值方法</strong></p><ol><li><p> 屏幕宽度/划分份数 就是html font-size的大小</p></li><li><p> 最后公式：页面元素的rem值 = 页面元素值（px）/（屏幕宽度/划分的份数）</p></li><li><p> 或者：页面元素的rem值 = 页面元素值（px）/ html font-size字体大小</p></li></ol><p><strong>方案二</strong></p><p>flexible.js：手机淘宝团队出的简洁高效移动端适配库</p><p>原理：把当前设备划分为10等份，确定好当前设备的html文字大小就可以了。</p><h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><h2 id="响应式开发原理"><a href="#响应式开发原理" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h2><p>就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同的设备的目的。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/6882c60739864f421c001d9f775280f7.png"></p><h2 id="响应式布局容器"><a href="#响应式布局容器" class="headerlink" title="响应式布局容器"></a>响应式布局容器</h2><p>响应式布局需要一个父级的布局容器，来配合子级元素来实现变化效果。</p><p>原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</p><h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>Bootstrap是基于HTML、CSS和JAVASCRIPT的，它简洁灵活，使得WEB开发更便捷</p><p>优点：1.标准化得html +css编码规范</p><p>2.提供了一套简洁、直观、强悍的组件</p><p>3.不断更新迭代</p><p>4.提高开发效率</p><h2 id="Bootstrap使用"><a href="#Bootstrap使用" class="headerlink" title="Bootstrap使用"></a>Bootstrap使用</h2><p>使用样式：创建文件夹结构——创建html骨架结构——引入相关样式文件——书写内容</p><p>书写内容：1.直接拿Bootstrap预先定义好的样式来使用</p><p>2.修改Bootstrap原来的样式，注意权重问题</p><p>3.<strong>要清楚它定义了哪些样式，以及这些样式能实现什么样的效果</strong></p><h2 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h2><p>Bootstrap需要为页面内容和栅格系统包裹一个.contain容器，Bootstrap预先定义好了这个类，叫container。它提供了两个作此用处的类</p><ol><li> <strong>container类</strong></li></ol><p>响应式布局容器 固定宽度 大屏（&gt;=1200px）宽度定为1170px<br>中屏（&gt;=992px）宽度定为970px</p><p>小屏（&gt;=768px）宽度定为750px 超小屏（100%）</p><ol start="2"><li><strong>container-fluid类</strong></li></ol><p>流式布局容器 百分百宽度</p><p>占据全部视口（viewport）的容器</p><p>适合于单独做移动端开发</p><h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><p>栅格系统（grid systems）指页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局。</p><p>Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统自动分为最多<strong>12列</strong>。</p><p>Bootstrap里面container宽度是固定的，但是不同屏幕下，container的宽度不同，我们再把container划分为12等份。</p><h3 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h3><p>栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建的布局中。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/ca325f85393e1c4cf308e740feef9cc0.png"></p><p>注意：1.行（row）必须放到container布局容器里面</p><p>2.我们实现列的平均划分需要给列添加类前缀</p><p>3.列（column）大于12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。列小于12则填不满一行。</p><p>4.每一列默认有左右15像素的padding</p><p>5.可以同时为一列指定多个设备的类名，以便划分不同份数 例如class=“col-md-4<br>col-sm-6”</p><h3 id="列嵌套"><a href="#列嵌套" class="headerlink" title="列嵌套"></a>列嵌套</h3><p>栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一列再分成若干小列。可以通过添加一个新的.row元素和一系列.col-sm-*元素到已经存在的.col-sm-*元素内</p><p>列嵌套最好加一个行row，这样可以取消父元素的padding值</p><h3 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h3><p>使用.col-md-offset-*类可以将列向右侧偏移。这些类实际是通过使用*选择器为当前元素增加了左侧的边距。</p><p>偏移的份数 就是 12 – 两个盒子的份数</p><p>如果只有一个盒子，那么就偏移 = 12 – 盒子份数/2</p><h3 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h3><p>通过使用.col-md-push-*（向右推） 和.col-md-pull-*（向左拉）来改变顺序<br>（靠position：relative实现）</p><p>按x轴方向运动</p><h2 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h2><p>为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/42b357c3e404a4993516d90980e8fc49.png"></p><p>与之相反的是visible-xs visible-sm visible-md visible-lg 在什么屏幕下显示。</p><h1 id="移动端技术选型"><a href="#移动端技术选型" class="headerlink" title="移动端技术选型"></a>移动端技术选型</h1><p>流式布局（百分比布局）</p><p><strong>flex弹性布局（推荐）</strong></p><p><strong>rem适配布局（不推荐）</strong></p><p>响应式布局</p><p>建议：选一种为主要技术选型，其他技术作为辅助，混合开发</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript笔记</title>
    <link href="/2020/12/05/JS%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/JS%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><p>arguments对象中存储了传递到函数里的所有实参。</p><p>prompt</p><p>prompt() 方法用于显示可提示用户进行输入的对话框</p><p>语法：prompt(text,defaultText)</p><p>text：可选。要在对话框中显示的纯文本</p><p>defaultText：可选。默认的输入文本。</p><p>如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段<strong>当前显示的文本</strong>。</p><h1 id="函数声明方式"><a href="#函数声明方式" class="headerlink" title="函数声明方式"></a>函数声明方式</h1><h2 id="1-利用函数关键字自定义函数（命名函数）"><a href="#1-利用函数关键字自定义函数（命名函数）" class="headerlink" title="1.利用函数关键字自定义函数（命名函数）"></a>1.利用函数关键字自定义函数（命名函数）</h2><p>function fn() {}</p><p>fn（）；</p><h2 id="2-函数表达式（匿名函数）"><a href="#2-函数表达式（匿名函数）" class="headerlink" title="2.函数表达式（匿名函数）"></a>2.函数表达式（匿名函数）</h2><p>var fun(变量名) = function() {}</p><p>fun（）；</p><p>注意：1.变量名不是函数名</p><p>2.函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存函数</p><p>3.函数表达式也可以进行传递参数</p><p>4.<strong>函数表达式调用必须写在函数声明下面</strong></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>Javascript作用域：就是代码名字（变量）在某个范围内起作用和效果 目的是为了提高程序的可靠性更重要的是减少命名冲突。</p><p>js的作用域（es6）之前：全局作用域 局部作用域</p><p><strong>全局作用域</strong>：整个script标签 或者是一个单独的js文件</p><p><strong>局部作用域</strong>：在函数内部就是局部作用域</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>根据作用域的不同我们变量分为全局变量和局部变量</p><ol><li><p><strong>全局变量</strong>：在全局作用域下的变量 在全局下都可以使用</p></li><li><p><strong>局部变量</strong> 在局部作用域下的变量 后者在函数内部的变量就是局部变量。只能在函数内部使用。</p></li><li><p><strong>从指向效率来看全局变量和局部变量</strong></p></li></ol><p>（1）  全局变量只有浏览器关闭的时候才会销毁，比较占内存资源</p><p>（2）  局部变量 当我们程序执行完毕就会销毁，比较节约内存资源</p><p><strong>注意</strong>：如果在函数内部 <strong>没有声明直接赋值的变量也属于全局变量</strong></p><p>函数的形参也可以看做是局部变量</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值 这种结构称作作用域链 就近原则。</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步：<strong>预解析和代码执行</strong></p><ol><li><p>预解析：js引擎会把js里面所有的var还有function提升到当前作用域的最前面</p></li><li><p>代码执行：按照代码书写顺序从上往下执行</p></li></ol><p>预解析分为 变量预解析（变量提升）和函数预解析（函数提升）</p><ol><li><p>变量提升：就是把所有的变量声明提升到当前的作用域最前面 <strong>不提升赋值操作</strong>。</p></li><li><p>函数提升：就是把所有的函数声明提升到当前作用域的最前面 <strong>不调用函数</strong></p></li></ol><p>例：    </p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;fun();                 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;         <span class="hljs-built_in">console</span>.log(num);          <span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span>;          &#125;</code></pre><p>相当于</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num;<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> num;<span class="hljs-built_in">console</span>.log(num);num = <span class="hljs-number">20</span>;&#125;num = <span class="hljs-number">10</span>fun();</code></pre><p>最后结果是undefined（就近原则）</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>JavaScript中，对象是一组无序的相关属性和方法的集合，例如字符串、数值、数组、函数等。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h3><p><strong>对象字面量</strong>：就是花括号**{}**里面包含了表达这个具体事物（对象）的属性和方法。</p><p><strong>使用对象</strong>：</p><p>（1）  调用对象的属性 用  对象名 <strong>.</strong> 属性名</p><p>（2）  调用属性还有一种方法 对象吗[‘属性名’] 方括号内一定要有引号</p><p>（3）  调用方法  对象名 <strong>.</strong> 方法()</p><h3 id="new-Object创建对象"><a href="#new-Object创建对象" class="headerlink" title="new Object创建对象"></a>new Object创建对象</h3><p>var 对象名 = new Object();</p><p>对象名.属性名 = 属性值  //创建新的属性</p><p>对象名.方法名 = function（）{} //创建新的方法</p><h3 id="利用构造函数创建对象"><a href="#利用构造函数创建对象" class="headerlink" title="利用构造函数创建对象"></a>利用构造函数创建对象</h3><p>构造函数 就是把对象里面一些相同的属性和方法抽象出来封装到函数里面</p><p>function 构造函数名（）{</p><p>  this.属性 = 值；</p><p>  this.方法 = function () {}</p><p>}</p><p>new 构造函数名（）；</p><p>注意: 1.构造函数名字首字母要大写</p><p>2.构造函数不需要return 就可以返回结果</p><p>3.调用构造函数必须使用new</p><p>4.属性和方法前面必须要添加this</p><h2 id="构造函数和对象的关系"><a href="#构造函数和对象的关系" class="headerlink" title="构造函数和对象的关系"></a>构造函数和对象的关系</h2><ol><li><p> 构造函数泛指某一大类，它类似java中的类（class）</p></li><li><p> 对象特指是一个具体的事物 </p></li><li><p> 我们利用构造函数创建对象的过程我们称之为<strong>对象的实例化</strong></p></li></ol><h2 id="new执行步骤"><a href="#new执行步骤" class="headerlink" title="new执行步骤"></a>new执行步骤</h2><ol><li><p> 在内存中创建一个新的空对象</p></li><li><p> 让this指向这个新的对象</p></li><li><p> 执行构造函数里面的代码，给这个新对象添加属性和方法</p></li><li><p> 返回这个新对象（所以构造函数里面不需要return）</p></li></ol><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><p>for in 遍历对象</p><p>例：</p><p>for (var k in obj){</p><p> console.log(k); //k 变量 输出得到的是<strong>属性名</strong></p><p>console.log(obj[k]); //obj[k] 得到的是<strong>属性值</strong></p><p>}</p><p>使用for in 里面的变量，我们喜欢用k 或者 key （习惯，就像i ,j）</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>JavaScript中的对象分为3种：自定义对象、内置对象、浏览器对象</p><p>前两种对象是js基础内容，属于ECMAScript；第三个浏览器对象属于JS独有的。</p><p>内置对象就是指js语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基础而必要的功能（属性和方法）</p><p>查文档：MDN</p><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p>Math对象不是构造函数，它具有数学常数和函数的属性和方法，跟数学相关的运算。</p><p>Math.max() 最大值</p><p>Math.min() 最小值</p><p>Math.PI 圆周率</p><p>Math.abs() 绝对值 (隐式转换 会把字符串中的 -1 转换为数字型</p><p>Math.floor() 向下取整(取最小的整数)</p><p>Math.ceil() 向上取整（取最大的整数）</p><p>Math.round() 四舍五入 其他数字都是四舍五入</p><p>Math.random() 不跟参数，返回随机小数 0&lt;= x &lt;1</p><h1 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h1><h2 id="JS的组成"><a href="#JS的组成" class="headerlink" title="JS的组成"></a>JS的组成</h2><p>WebAPIs是JS所独立的部分，主要实现交互功能。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/123.png"></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>API（应用程序编程接口）</strong>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p><p>简单理解：<strong>API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。</strong></p><p><strong>Web API是浏览器</strong>提供的一套操作<strong>浏览器功能</strong>和<strong>页面元素</strong>的API（BOM和DOM）。主要针对于浏览器做交互效果。</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h2><p>文档对象模型（Document Object Model，简称<strong>DOM</strong>），是W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准<strong>编程接口</strong>。</p><p>W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/dom.png"></p><p>文档：一个页面就是一个文档，DOM中使用document表示</p><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p><p>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示</p><p><strong>DOM把以上内容都看做是对象</strong></p><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>(因为我们文档页面是从上往下加载，所以先得有标签 所以我们script写到标签的下面)</p><h3 id="1-根据ID获取"><a href="#1-根据ID获取" class="headerlink" title="1.根据ID获取"></a>1.根据ID获取</h3><p><strong>getElementById(id) //参数id是大小写敏感的字符串，所以要‘ ’ 返回的是Element对象</strong></p><p><strong>console.dir</strong> <strong>打印我们返回的元素对象 更好的查看里面的属性和方法</strong></p><h3 id="2-根据标签名获取"><a href="#2-根据标签名获取" class="headerlink" title="2.根据标签名获取"></a>2.根据标签名获取</h3><p><strong>getElementsByTagName(TagName) //返回的是 获取的元素对象的集合 以伪数组的形式存储的（没有数组方法）</strong></p><p><strong>得到的对象是动态的</strong></p><p><strong>element.getElementsByTagName()</strong> <strong>可以获取这个元素中的某些标签</strong></p><p><strong>例：var nav = document.getElementById(id)</strong></p><p><strong>nav. getElementsByTagName(Tagname)</strong></p><h3 id="3-通过HTML5新增方法获取"><a href="#3-通过HTML5新增方法获取" class="headerlink" title="3.通过HTML5新增方法获取"></a>3.通过HTML5新增方法获取</h3><p><strong>document.getElementsByClassName(‘类名’); // 根据类名返回元素对象集合</strong></p><p><strong>document.querySelector(‘选择器‘); // 根据指定选择器返回</strong>第一个<strong>元素对象</strong></p><p><strong>里面的选择器要加符号 id：#、 class：.</strong></p><p><strong>document.querySelectorAll(); // 返回指定选择器的所有元素对象集合</strong></p><h3 id="4-获取特殊元素"><a href="#4-获取特殊元素" class="headerlink" title="4.获取特殊元素"></a>4.获取特殊元素</h3><p><strong>document.body // 获取body标签，返回body对象</strong></p><p><strong>document.documentElement // 返回html对象</strong></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是由三部分组成 事件源 事件类型 事件处理程序</p><ol><li><p> 事件源：事件被触发的对象</p></li><li><p> 事件类型：如何触发 什么事件 </p></li><li><p> 事件处理程序：通过一个函数赋值的方式 完成</p></li></ol><p>例：var btn = document.getElementById(‘btn’)</p><p>btn.onclick = function() { }</p><p><strong>步骤</strong>：获取事件源——注册事件——添加事件处理程序（采用函数赋值形式）</p><h3 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h3><p><strong>onClick</strong>：鼠标点击事件，多用在某个对象控制的范围内的鼠标点击</p><p>onDblClick：鼠标双击事件</p><p><strong>onfocus</strong>：获得鼠标焦点触发</p><p><strong>onblur</strong>：失去鼠标焦点触发</p><p><strong>onMouseDown</strong>：鼠标上的按钮被按下了</p><p><strong>onMouseUp</strong>：鼠标按下后，松开时激发的事件</p><p><strong>onMouseOver</strong>：当鼠标移动到某对象范围的上方时触发的事件</p><p><strong>onMouseMove</strong>：鼠标移动时触发的事件</p><p><strong>onMouseOut</strong>：当鼠标离开某对象范围时触发的事件</p><p>onKeyPress：当键盘上的某个键被按下并且释放时触发的事件</p><p><strong>onKeyDown</strong>：当键盘上某个按键被按下时触发的事件</p><p><strong>onKeyUp</strong>：当键盘上某个按键被按放开时触发的事件</p><h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><p><strong>element.innerText</strong>：从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉</p><p><strong>element.innerHTML</strong>：起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</p><p>区别：</p><p>1.innerText不识别html标签，innerHTML识别</p><p>2.innerText是非标准 innerHTML是W3C标准</p><h2 id="表单属性操作"><a href="#表单属性操作" class="headerlink" title="表单属性操作"></a>表单属性操作</h2><p>type、value、checked、selected、disabled</p><p>表单里面的值 文字内容是通过value来修改</p><p>表单禁用，disabled=true</p><h2 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h2><p><strong>element.style</strong> <strong>行内样式操作即修改具体样式</strong></p><p><strong>element.className</strong> <strong>类名样式操作即修改类名</strong></p><p>注意：</p><p><strong>1.JS里面的样式采取驼峰命名法 比如 fontSize、backgroundColor</strong></p><p><strong>2.JS修改style样式操作，产生的是行内样式，css权重比较高</strong></p><h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>去除其他元素独特的样式，给自己添加的独特样式</p><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p>即我们可以自定义元素的属性 应用：tab页</p><p><strong>获取</strong>属性方法：</p><p>1.获取元素的属性值——<strong>element.属性</strong> 先get元素，再得属性值</p><p>2.<strong>element.getAttribute(‘属性’)</strong> </p><p><strong>设置</strong>元素属性值1. <strong>element.属性 = ‘值’</strong> 设置内置的属性值</p><p><strong>2. element.setAttribute(‘属性’，值)</strong> 主要针对<strong>自定义属性</strong>，也可以改内置属性</p><p>注意：class比较特殊，里面是class，不是className</p><p><strong>移除</strong>属性方法：<strong>element.removeAttribute(‘属性’)</strong></p><h2 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h2><p><strong>自定义属性目的：是为了保存并使用数据。有些数据可以保持到页面中而不用保存到数据库中。</strong></p><p>H5规定自定义属性**data-**开头做为属性名并且赋值。</p><p>比如：&lt;div data-index=””&gt;&lt;/div&gt;</p><p>H5新增的获取自定义属性方法：<strong>element.dataset.index (就不用再加data-)</strong></p><p>注意：只能获取data-的自定义属性，兼容ie11以上版本</p><p><strong>dataset是一个集合里面存放了所有以data-开头的自定义属性</strong></p><p>注意：如果自定义属性里面有多个-链接的单词，我们获取的时候采取驼峰命名法。（例：data-list-name —— element.dataset.listName）</p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><ol><li>利用DOM提供的方法获取元素</li></ol><p>缺点：逻辑性不强、繁琐</p><ol start="2"><li>利用节点层级关系获取元素</li></ol><p>利用父子兄节点关系获取元素</p><p>特点：逻辑性强，但是兼容性稍差</p><p><strong>节点描述</strong>：一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><p>元素节点 nodeType 为 1</p><p>属性节点 nodeType 为 2</p><p>文本节点 nodeType 为 3</p><p><strong>节点层级</strong>：利用DOM树可以把节点划为不同的层级关系，最常见的是父子兄级关系</p><h3 id="父节点parentNode"><a href="#父节点parentNode" class="headerlink" title="父节点parentNode"></a>父节点parentNode</h3><p><strong>element.parentNode</strong>得到离元素最近的父级节点，如果找不到，返回为null</p><h3 id="子节点childNodes"><a href="#子节点childNodes" class="headerlink" title="子节点childNodes"></a>子节点childNodes</h3><p>parentNode.childNodes（标准） 返回包含指定节点的子节点的集合</p><p><strong>注意：返回值里面包含了所有的子节点，包括元素节点、文本节点等</strong></p><p><strong>如果只想获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes</strong></p><p><strong>子节点children</strong></p><p>parentNode.children（非标准）<strong>获取所有的子元素节点，虽然是非标准，但是得到了各个浏览器的支持。（常用）</strong></p><p><strong>子节点 firstChild</strong> 获得第一个子节点（不管是文本还是元素）</p><p><strong>子节点 lastChild</strong> 获得最后一个子节点（不管是文本还是元素）</p><p><strong>子节点 firstElementChild</strong> 返回第一个子元素节点</p><p><strong>子节点 lastElementChild</strong> 返回最后一个子元素节点</p><p>上两种方法兼容IE9以上版本</p><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><p><strong>node.nextSibling</strong> 返回当前元素的下一个兄弟节点（包括文本，元素），找不到返回null</p><p><strong>node.previousSibling</strong> 返回当前元素上一个兄弟节点</p><p><strong>node.nextElementSibling</strong> 返回当前节点的下一个兄弟元素节点</p><p><strong>node.previousElementSibling</strong> 返回当前节点的上一个兄弟元素节点</p><p>上两种方法兼容IE9以上版本</p><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p><strong>document.createElement(‘tagName’)</strong> 创建由tagName指定的HTML元素。因为这些元素原先不存在，是动态生成的。</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p><strong>1.node.appendChild(child)</strong> 将一个节点添加到指定父节点的子节点列表末尾。后面追加元素，类似于伪元素after</p><p>node（父级）child（子级）</p><p><strong>2.node.insertBefore(child,</strong> <strong>指定元素)</strong> 将添加父元素的指定子元素的前面添加。</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>node.removeChild(child) 方法从DOM中删除一个子节点，返回删除的节点</p><p>阻止链接跳转需要添加<strong>javascript:void(0);</strong> 或者 **javascript:; **在 a href=” ”中</p><h3 id="复制节点（克隆节点）"><a href="#复制节点（克隆节点）" class="headerlink" title="复制节点（克隆节点）"></a>复制节点（克隆节点）</h3><p>node.cloneNode() 返回调用该方法的节点的一个副本。</p><p>例：ul.children[0].cloneNode()</p><p>注意：括号为空或者里面是false 进行的是浅拷贝，只复制标签不复制里面的内容，改为true就是深拷贝，复制里面的所有内容。</p><h3 id="三种动态创建元素区别"><a href="#三种动态创建元素区别" class="headerlink" title="三种动态创建元素区别"></a>三种动态创建元素区别</h3><p><strong>document.write()</strong> </p><p><strong>element.innerHTML</strong></p><p><strong>document.createElement()</strong></p><p><strong>区别</strong></p><ol><li>document.write()是直接将内容写入页面的内容流，但是当页面文档流加载完毕，则它会导致页面全部重绘。</li></ol><p>2.innerHTML是将内容写入某个DOM节点，不会导致页面全部重绘</p><p>3.innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</p><p>4.createElement() 创建多个元素效率稍低一点点，但是结构更清晰</p><h2 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h2><h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p><strong>1.传统注册方式</strong></p><p>利用on开头的事件onclick </p><p>特点：注册事件的唯一性 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数。</p><p><strong>2.方法监听注册方式</strong></p><p>w3c标准 推荐方式</p><p><strong>addEventListener()</strong> 它是一个方法</p><p>IE9之前的IE不支持此方法，可使用attachEvent()代替</p><p>特点：同一个元素同一个事件可以注册多个监听器  按照注册顺序依次执行</p><p><strong>addEventListener事件监听方式</strong></p><p><strong>eventTarget.addEventListener(type, listener[, useCapture])</strong></p><p>eventTarget.addEventListener()方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，就会执行事件处理函数。</p><p>该方法接收三个参数：</p><p>type:事件类型字符串，比如click、mouseover，注意这里不要带on</p><p>listener：事件处理函数，事件发生时，会调用该监听函数</p><p>useCapture：可选参数，是一个布尔值，默认时false。</p><p><strong>attachEvent</strong> <strong>事件监听方式（非标准，了解一下）</strong></p><p>eventTarget.attachEvent()方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p><p>该方法接收两个参数：</p><p>eventNameWithOn：事件类型字符串，比如onclick、onmouseover，这里要带on</p><p>callback：事件处理函数，当目标触发事件时会回调函数被调用</p><h3 id="删除事件（解绑事件）"><a href="#删除事件（解绑事件）" class="headerlink" title="删除事件（解绑事件）"></a>删除事件（解绑事件）</h3><p><strong>1.传统注册方式</strong></p><p><strong>eventTarget.onclick = null</strong></p><p><strong>2.方法监听注册方式</strong></p><p><strong>eventTarget.removeEventListener(type, listener[,useCapture]);</strong></p><p>注意函数不能是匿名函数，兼容性问题（跟add一样）</p><p><strong>eventTarget.detachEvent(eventNameWithOn, callback);</strong></p><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件流描述的是从页面中接收事件的顺序</p><p>事件发生时会在元素节点之间按照特定的传播，这个传播过程即DOM事件流</p><p>DOM事件流分三个阶段：捕获阶段 当前目标阶段 冒泡阶段</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/684645.png"></p><p>事件冒泡：IE最早提出，事件开始时有最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程。</p><p>事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到具体的元素接收的过程。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/861.png"></p><p><strong>注意</strong></p><ol><li><p>JS代码中只能执行捕获或者冒泡其中的一个阶段</p></li><li><p>onclick和attachEvent只能得到冒泡阶段</p></li><li><p>addEventListener（type，listener[,useCapture]）第三个参数如果为true，表示事件捕获阶段调用事件处理程序；如果为false（默认为false），则在事件冒泡阶段调用事件处理程序。</p></li><li><p>实际开发很少使用事件捕获</p></li><li><p>有些事件没有冒泡，比如onblur、onfocus、onmouseover、onmouseleave</p></li></ol><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ol><li><p>event就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看</p></li><li><p>事件对象只有有了对象才会存在，它是系统给我们自动创建的，不需要我们传递参数</p></li><li><p>事件对象是我们事件的<strong>一系列相关数据的集合</strong> 跟事件相关的 <strong>有很多属性和方法</strong> 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标，如果是键盘事件就包含了键盘事件的信息</p></li><li><p><strong>这个事件对象我们可以自己命名 比如event、evt、e</strong></p></li><li><p>事件对象也有兼容性问题 ie678通过window.event </p></li></ol><p><strong>兼容性写法e = e | | window.event</strong></p><ol start="6"><li>event是个形参，不需要传递实参过去</li></ol><h4 id="事件对象常见的属性和方法"><a href="#事件对象常见的属性和方法" class="headerlink" title="事件对象常见的属性和方法"></a>事件对象常见的属性和方法</h4><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E4%BA%8B%E4%BB%B6.png"></p><p>1.<strong>e.target</strong>返回的是<strong>触发事件的对象</strong>（元素） <strong>this</strong>返回的是<strong>绑定事件的对象</strong>（元素）</p><p>2.了解一下 跟this有个相似的属性 currentTarget ie678不兼容</p><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><p><strong>标准写法：利用事件对象里面的stopPropagation（）方法</strong></p><p>兼容性：再添加判断条件 使用e.cancelBubble = true</p><h4 id="事件委托（代理、委派）"><a href="#事件委托（代理、委派）" class="headerlink" title="事件委托（代理、委派）"></a>事件委托（代理、委派）</h4><p><strong>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</strong></p><p>作用：操作一次DOM，提高了程序性能</p><p>关键：就是把事件绑定在父节点上</p><h3 id="常见鼠标事件"><a href="#常见鼠标事件" class="headerlink" title="常见鼠标事件"></a>常见鼠标事件</h3><ol><li>禁止鼠标右键菜单</li></ol><p><strong>contextmenu</strong>主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p><ol start="2"><li>禁止鼠标选中</li></ol><p><strong>selectstart（开始选中）</strong></p><p><strong>鼠标事件对象（MouseEvent）</strong></p><p> 1.鼠标在可视区的 X 和 Y 坐标</p><ul><li><p>e.clientX  返回鼠标相对于浏览器窗口可视区的坐标X</p></li><li><p>e.clientY  返回鼠标相对于浏览器窗口可视区的坐标Y</p></li></ul><p>2.鼠标在页面文档的 X 和 Y 坐标</p><ul><li><p>e.pageX  返回鼠标相对于页面文档的坐标X  IE9+ 支持</p></li><li><p>e.pageY  返回鼠标相对于页面文档的坐标Y  IE9+ 支持</p></li></ul><p>3.鼠标在电脑屏幕的 X 和 Y 坐标</p><ul><li><p>e.screenX  返回鼠标相对于电脑屏幕的 X 坐标</p></li><li><p>e.screenY  返回鼠标相对于电脑屏幕的 Y 坐标</p></li></ul><p>开发中pageXY比较常用</p><h3 id="常见的键盘事件"><a href="#常见的键盘事件" class="headerlink" title="常见的键盘事件"></a>常见的键盘事件</h3><p><strong>onkeyup</strong>：按键弹起时触发</p><p><strong>onkeydown</strong>：键盘按下时触发</p><p><strong>onkeypress</strong>：键盘按下触发 但是识别不了功能键</p><p>三个事件的执行顺序：keydown -&gt; keypress-&gt; keyup</p><h4 id="键盘事件对象-KeyboardEvent"><a href="#键盘事件对象-KeyboardEvent" class="headerlink" title="键盘事件对象 KeyboardEvent"></a>键盘事件对象 KeyboardEvent</h4><p> <strong>keyCode</strong>：返回该键的ASCII值</p><p>注意：</p><p>1.keyup和keydown事件不区分字母大小写 a和A得到都是65</p><p>2.keypress事件区分字母大小写 a 97 A 65</p><p>注意：keydown和keypress在文本框里面得特点：他们两个事件触发的时候，文字还没有落入文本框中。</p><p>keyup事件触发的时候，文字已经落入文本框里面了</p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM即<strong>浏览器对象模型</strong>，它提供了独立于内容而与<strong>浏览器窗口进行交互的对象</strong>，其核心对象是window</p><p>BOM由一系列相关的对象构成，并且每个对象都提供了很多方法和属性。</p><p>BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分。</p><h2 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h2><p><strong>window对象是浏览器的顶级对象</strong>，它具有双重角色</p><ol><li><p>它是JS访问浏览器窗口的一个接口</p></li><li><p>它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window。对话框都属于window对象方法（alert、prompt等）</p></li></ol><p><strong>注意：window下的一个特殊属性window.name，声明变量尽量不用name</strong></p><h2 id="window对象的常见事件"><a href="#window对象的常见事件" class="headerlink" title="window对象的常见事件"></a>window对象的常见事件</h2><h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><p><strong>window.onload= function(){ }</strong></p><ol><li><p>窗口加载事件，当文档内容（包括图像、脚本文件、CSS文件等）完全加载完成会触发事件，就调用函数。</p></li><li><p>传统的方式注册事件只能写一次，声明多个以最后一个为准。</p></li><li><p>如果用addEventListener则没有限制，没有on</p></li></ol><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><p><strong>document.addEventListener(‘DOMContentLoaded’, function(){ })</strong></p><p>DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片、flash等等</p><p>ie9以上支持</p><p>如果页面图片较多，加载时间长，用DOMContentLoaded事件比较合适</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p><strong>window.onresize = function(){}</strong></p><p><strong>window.addEventLIstener(‘resize’, function(){ })</strong></p><p>window.onresize 是调整窗口大小加载的事件，当触发时就调用的处理函数。</p><p>应用：响应式布局，<strong>window.innerWIdth当前屏幕的宽度</strong></p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p>window.setTimeout(调用函数，[延迟的毫秒数]);</p><p>setTimeout()方法用于设置定时器，该定时器在定时器到期后执行调用函数。</p><ol><li><p> window在调用时可以省略</p></li><li><p> 这个调用函数可以直接写函数，还可以写函数名 还有一个写法‘函数名（）’第三种不推荐（麻烦）</p></li><li><p> 页面中可能有多个定时器，要给定时器加标识符（名字）</p></li></ol><h3 id="停止setTImeout（）定时器"><a href="#停止setTImeout（）定时器" class="headerlink" title="停止setTImeout（）定时器"></a>停止setTImeout（）定时器</h3><p><strong>window.clearTimeout(timeout ID)</strong></p><p>window可以省略</p><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p>window.setInterval(回调函数，[间隔毫秒数]);</p><p>setInterval()方法用于设置定时器，该定时器每隔指定毫秒就执行调用一次函数，不断重复调用。</p><ol><li><p> window在调用时可以省略</p></li><li><p> 这个调用函数可以直接写函数，还可以写函数名 还有一个写法‘函数名（）’第三种不推荐（麻烦）</p></li><li><p> 页面中可能有多个定时器，要给定时器加标识符（名字）</p></li></ol><h3 id="停止setInterval-定时器"><a href="#停止setInterval-定时器" class="headerlink" title="停止setInterval()定时器"></a>停止setInterval()定时器</h3><p>window.clearInterval(intervalID);</p><p>clearInterval()方法取消了先前通过调用setInterval()建立的定时器</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this指向问题 一般情况下this的最终指向的是那个调用它的对象</p><ol><li><p>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</p></li><li><p>方法调用中谁调用this指向谁</p></li><li><p>构造函数中this指向构造函数的实例</p></li></ol><h2 id="JS执行队列"><a href="#JS执行队列" class="headerlink" title="JS执行队列"></a>JS执行队列</h2><h3 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一时间只能做一件事</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>如果执行过程中有一步需要等待很长时间，就会造成页面渲染不连贯。为了解决这个问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。于是，JS中出现了同步和异步。</p><p><strong>同步：</strong>前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</p><p><strong>异步：</strong>如果做一件事花费的时间很长，在做一件事的同时，可以处理其他事情。</p><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>同步任务都在主线程上执行，形成一个执行线。</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>JS的异步是通过回调函数实现的</p><p>一般而言，异步任务有以下三种类型：</p><p>1、    普通事件，如 click、resize等</p><p>2、    资源加载，如load、error等</p><p>3、    定时器，包括setInterval、setTImeout等</p><p>异步任务相关回调函数添加到<strong>任务队列</strong>中（任务队列也称为消息队列）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E6%89%A7%E8%A1%8C.png"></p><h4 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h4><ol><li><p>先执行<strong>执行栈中的同步任务</strong></p></li><li><p>异步任务（回调函数）放入任务队列中。</p></li><li><p>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取<strong>任务队列</strong>中的异步任务，于是被读取的异步任务结束等待状态，进入执行线，开始执行。</p></li></ol><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为<strong>事件循环（event loop）</strong>。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/qd516.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/1d56w.png"></p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>window对象给我们提供了一个<strong>location属性</strong>用于<strong>获取或设置窗体的URL</strong>，并且可以用于<strong>解析URL</strong>。因为这个属性返回的是一个对象，所以我们将这个属性也称为<strong>location对象</strong>。</p><p>URL：统一资源定位符（Uniform Resource Locator，URL）是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p>URL的一般语法格式为：</p><p> <strong>protocol://host[:port]/path/[?query]#frament</strong></p><p>例：<a href="http://www.amaodama.com/index.html?name=amao&amp;age22#link">http://www.amaodama.com/index.html?name=amao&amp;age22#link</a></p><p>protocol：通信协议 常用的http,ftp,maito等等</p><p>host：主机（域名）</p><p>port：端口号 可选，省略时使用方案的默认端口，如http的默认端口为80</p><p>path：路径 由 零或多个‘/’符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</p><p>query：参数 以键值对的形式，通过&amp;符号分隔开来</p><p>fragment：片段#后面内容 常见于链接锚点</p><h3 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage014.png"></p><p><strong>重点记住：href和search</strong></p><h3 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage015.png"></p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象<strong>包含有关浏览器的信息</strong>，它有很多属性，最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值。即得知是什么浏览器。</p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>该对象包含用户（在浏览器窗口中）访问过的URL</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage016.png"></p><h1 id="PC端网页特效"><a href="#PC端网页特效" class="headerlink" title="PC端网页特效"></a>PC端网页特效</h1><h2 id="元素offset系列"><a href="#元素offset系列" class="headerlink" title="元素offset系列"></a>元素offset系列</h2><h3 id="offset概述"><a href="#offset概述" class="headerlink" title="offset概述"></a>offset概述</h3><p>offset翻译过来就是偏移量，使用offset系列相关属性可以<strong>动态的</strong>得到该属性的位置（偏移）、大小等。</p><ul><li>获得元素距离带有定位父元素的位置</li></ul><ul><li>获得元素自身的大小</li></ul><p><strong>注意：返回的数值都不带单位</strong></p><h3 id="offset系列常用属性"><a href="#offset系列常用属性" class="headerlink" title="offset系列常用属性"></a>offset系列常用属性</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage017.png"></p><p>element.parentNode也可以返回父节点，返回的是最近一级的父节点。</p><p>element.offsetParent返回带有定位的父节点</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage018.png"></p><h3 id="offset和style区别"><a href="#offset和style区别" class="headerlink" title="offset和style区别"></a>offset和style区别</h3><p><strong>offset</strong></p><p>offset可以得到任何样式表中的样式值</p><p>offset系列获得的数值是没有单位的</p><p>offsetWIdth包含padding + border + width</p><p>offsetWidth等属性是只读属性，只能获取不能赋值</p><p>获取元素大小位置，用offset更合适</p><p><strong>style</strong></p><p>style只能得到行内样式表的样式值</p><p>style.width获得的是带有单位的</p><p>style可以赋值</p><p>给元素位置赋值，用style更合适</p><h2 id="元素可视区client系列"><a href="#元素可视区client系列" class="headerlink" title="元素可视区client系列"></a>元素可视区client系列</h2><p>client就是客户端，使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage019.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage020.png"> </p><p><strong>立即执行函数（function () {}）() 或者 （function（）{}（））</strong></p><p><strong>立即执行函数最大的作用是 独立创建了一个作用域，避免了命名冲突问题</strong></p><p><strong>pageshow： 重新加载页面触发的事件 添加给window</strong></p><h2 id="为什么用pageshow不用load事件？"><a href="#为什么用pageshow不用load事件？" class="headerlink" title="为什么用pageshow不用load事件？"></a>为什么用pageshow不用load事件？</h2><p><strong>有三种情况会刷新页面触发load事件：a标签的超链接、F5或者刷新按钮、前进后退按钮</strong></p><p><strong>但是火狐浏览器有“往返缓存”，保存了DOM和JavaScript的状态；此时后退按钮不能刷新页面。</strong></p><p><strong>这时候可以使用pageshow事件触发。这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发。</strong></p><p>根据事件对象中的<strong>persisted</strong>来判断<strong>是否是缓存中的页面触发</strong>的pageshow事件。</p><h2 id="元素滚动scroll系列"><a href="#元素滚动scroll系列" class="headerlink" title="元素滚动scroll系列"></a>元素滚动scroll系列</h2><p>scroll翻译过来就是滚动，scroll系列相关属性可以动态的得到该元素的大小、滚动距离。<strong>（元素内容的实际高度大小）</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage021.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage022.png"></p><p><strong>页面被卷去的头部：可以通过window.pageYOffset获得 如果是被卷去的左侧 window.pageXOffset</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage023.png"></p><p>DTD：<!DOCTYPE html></p><p><strong>三个系列对比</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage024.png"></p><p>主要用法：</p><ol><li><p>offset系列经常用于获得元素位置 <strong>offsetLeft offsetTop</strong></p></li><li><p>client经常用于获取元素大小 <strong>clientWidth clientHeight</strong></p></li><li><p>scroll经常用于获取滚动距离 <strong>scrollTop scrollLeft</strong></p></li><li><p>注意页面滚动的距离通过window.pageXOffset获得</p></li></ol><h2 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h2><p>mouseenter和mouseover都是鼠标移到元素上就会触发的事件</p><p>区别：mouseover鼠标<strong>经过自身盒子会触发</strong>，经过<strong>子盒子还会触发</strong>。mouseenter<strong>只会经过自身盒子触发</strong>。之所以这样，就是因为<strong>mouseenter不会冒泡</strong></p><p>跟mouseenter搭配mouseleave，同样也不会冒泡</p><h2 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h2><h3 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h3><p><strong>核心原理</strong>：通过定时器setInterval（）不断移动盒子位置。</p><p>实现步骤：</p><p>1.获得盒子当前位置</p><p>2.让盒子在当前位置加上1个移动距离</p><p>3.利用定时器不断重复这个操作</p><p>4.加一个结束定时器的条件</p><p><strong>5.注意此元素需要添加定位，才能使用element.style.left</strong></p><h3 id="动画函数简单的封装"><a href="#动画函数简单的封装" class="headerlink" title="动画函数简单的封装"></a>动画函数简单的封装</h3><p>注意函数需要传递2个参数，对象和移动距离</p><h3 id="动画函数给不同元素记录不同定时器"><a href="#动画函数给不同元素记录不同定时器" class="headerlink" title="动画函数给不同元素记录不同定时器"></a>动画函数给不同元素记录不同定时器</h3><p>如果多个元素都使用这个动画函数，每次都要var声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）</p><p>核心原理：利用JS是一门动态语言，可以很方便的给当前对象添加属性。</p><h3 id="缓动效果原理"><a href="#缓动效果原理" class="headerlink" title="缓动效果原理"></a>缓动效果原理</h3><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p><p>思路：</p><p>1.让每次移动距离慢慢变小，速度就会慢慢落下来</p><p>2.核心算法：（目标值-当前位置）/ 10 作为每次移动的距离步长</p><p>3.停止条件：让当前盒子位置等于目标位置就停止定时器。</p><h3 id="动画函数添加回调函数"><a href="#动画函数添加回调函数" class="headerlink" title="动画函数添加回调函数"></a>动画函数添加回调函数</h3><p><strong>回调函数原理：</strong>函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。</p><h3 id="动画函数封装到单独JS文件里面"><a href="#动画函数封装到单独JS文件里面" class="headerlink" title="动画函数封装到单独JS文件里面"></a>动画函数封装到单独JS文件里面</h3><p>经常用到这个函数，就单独创建js文件，把函数放进去。</p><p>轮播图</p><p>图片放在一个大ul，通过移动ul实现滚动效果。</p><p>无缝滚动效果：在最后一张后面复制一份第一张克隆，等到达克隆张，下次点击快速到达第一张，</p><p><strong>节流阀</strong></p><p>目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p><p>题外话：</p><p>if（callback）{callback（）；} == callback &amp;&amp; callback（）；</p><p>运用了短路运算符的特性，当两个都为true时，才会调用函数。</p><h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><p>window.scroll(x, y); 里面的xy不跟单位；</p><h1 id="移动端特效"><a href="#移动端特效" class="headerlink" title="移动端特效"></a>移动端特效</h1><h3 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h3><p>移动端浏览器兼容性较好，不需要考虑JS兼容性问题。但移动端也有独特的地方，比如触屏事件touch。</p><p>touch对象代表一个触摸点。</p><p>常见的触屏事件如下</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage025.png"></p><h4 id="触摸事件对象"><a href="#触摸事件对象" class="headerlink" title="触摸事件对象"></a>触摸事件对象</h4><p>每个事件都有对象产生</p><p>触摸事件对象常见的对象类别：</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage026.png"></p><p>如果监听的是一个DOM元素，touches和targetTouches一样。</p><p>手指离开屏幕，只有changedTouches还在。</p><p>一般都是触摸元素，最经常用targetTouches。</p><p><strong>注意：手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault();</strong></p><h3 id="移动端轮播图"><a href="#移动端轮播图" class="headerlink" title="移动端轮播图"></a>移动端轮播图</h3><p>要前后放两张图片（第一张和最后一张），同时为了显示第一张图片，ul要margin-left：-100%；移动一张图片的位置。</p><p>transitionend：过渡效果结束的时候触发。</p><h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。</p><p>添加类名：classList.add(‘类名’);</p><p>移除类名：classList.remove(‘类名’)；</p><p>切换类名：classList.toggle(‘类名’); //原来有就删除，没有就添加。</p><h3 id="click延时解决方案"><a href="#click延时解决方案" class="headerlink" title="click延时解决方案"></a>click延时解决方案</h3><p>点了第一下，300ms没有点第二下，就判断是点击。</p><p>移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放页面。</p><p>解决方案：</p><ol><li>禁用缩放。浏览器禁用默认的双击缩放行为并且去掉300ms的点击延迟。</li></ol><meta name=”viewport” content=”user-scalable=no”>2. 利用touch事件自己封装这个事件解决300ms延迟。<ol start="3"><li>利用fastclick插件解决（GitHub上找）</li></ol><p><strong>视频插件：zy.media.js</strong></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。</p><p>常用框架：bootstrap、vue、angular、react等</p><p>移动端常用插件：swiper、superslide、iscroll等</p><p>框架：大而全，一整套解决方案</p><p>插件：小而专一，某个功能的解决方案</p><h1 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h1><p>特性：1.数据存储在用户浏览器中</p><p>2.设置、读取方便、甚至页面刷新不丢失数据</p><p>3.容量较大，sessionStorage约5M、localStorage约20M</p><p>4.只能存储字符串，可以将对象JSON.stringfy()编码后存储</p><h2 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h2><ol><li><p>生命周期为<strong>关闭浏览器窗口</strong>（即关闭浏览器就消失）</p></li><li><p>在同一个窗口（页面）下数据可以共享</p></li><li><p>以键值对的形式存储使用</p></li></ol><p>存储数据：sessionStorage.setItem(key, value);</p><p>获取数据：sessionStorage.getItem(key);</p><p>删除数据：sessionStorage.removeItem(key);</p><p>清空数据：sessionStorage.clear();</p><h2 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h2><ol><li><p>生命周期<strong>永久生效</strong>，除非手动删除</p></li><li><p>可以多窗口（页面）共享（同一浏览器可以共享）</p></li><li><p>以键值对的形式存储使用</p></li></ol><p>存储数据：localStorage.setItem(key, value);</p><p>获取数据：localStorage.getItem(key);</p><p>删除数据：localStorage.removeItem(key);</p><p>清空数据：localStorage.clear();</p><p>change: 状态改变触发事件。</p><h1 id="JavaScript面向对象"><a href="#JavaScript面向对象" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h1><h2 id="面向对象编程介绍"><a href="#面向对象编程介绍" class="headerlink" title="面向对象编程介绍"></a>面向对象编程介绍</h2><p>面向过程（POP）就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p><p>即面向过程就是分析好问题，按步骤解决。</p><p>面向对象（OOP）是把事务分解成为一个个对象，然后由对象之间分工与合作。</p><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。</p><p>面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</p><p>特性：<strong>封装性 继承性 多态性</strong></p><p>缺点：面向对象性能比面向过程低</p><p><strong>通俗的讲：用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭</strong></p><h2 id="ES6中的类与对象"><a href="#ES6中的类与对象" class="headerlink" title="ES6中的类与对象"></a>ES6中的类与对象</h2><p><strong>在JavaScript中，对象是一组无序的相关属性和方法集合，所有事物都是对象。</strong></p><p>对象是由<strong>属性</strong>和<strong>方法</strong>组成的：</p><p>属性：事物的<strong>特征</strong>，在对象中用<strong>属性</strong>来表示</p><p>方法：事物的<strong>行为</strong>，在对象中用<strong>方法</strong>来表示</p><p>类：class ES6新增了类的概念 类抽象了对象的公共部分，它<strong>泛指</strong>某一大类（class）<strong>对象</strong>特指某一个，通过<strong>类</strong>实例化一个具体对象</p><p>面向对象的思维特点：</p><ol><li><p>抽取（抽象）对象共用的属性和行为组织（封装）成一个<strong>类</strong>（模板）</p></li><li><p>对类进行实例化，获取类的<strong>对象</strong></p></li></ol><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>语法：class name{ //class body} 创建实例： var xx = new name（）；</p><p><strong>注意：类必须使用new实例化对象</strong></p><h3 id="类constructor构造函数"><a href="#类constructor构造函数" class="headerlink" title="类constructor构造函数"></a>类constructor构造函数</h3><p><strong>constructor（）</strong>方法是类的构造函数（默认方法），<strong>用于传递参数，返回实例对象</strong>，通过new命令生成对象实例时，自动调用该方法。如果没有显示定义，类内部会自动给我们创建一个<strong>constructor（）</strong></p><p>注意</p><ol><li><p>通过class关键字创建类，<strong>类名我们还是习惯性定义首字母大写</strong></p></li><li><p>类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象</p></li><li><p>constructor函数只要new生成实例时，就会自动调用这个函数，如果我们不写这个函数，类也会自动生成这个函数</p></li><li><p>生成实例new不能省略</p></li><li><p>最后注意语法规范，创建类 类名后面不要加小括号，生成实例 类名后面加小括号，<strong>构造函数不需要加function</strong></p></li><li><p>多个函数和方法之间不需要逗号分隔</p></li></ol><h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><p>子类可以继承父类，使用父类中的属性和方法。</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p><strong>super关键字</strong>用于访问和调用对象父类上的函数。<strong>可以调用父类的构造函数（super(参数)）</strong>，也可以调用父类的普通函数（**super.方法()**）。</p><p>1.继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的这个方法。如果没有就查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原则）</p><p>2.<strong>super必须在this前面调用</strong></p><p><strong>注意点</strong></p><ol><li><p>在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p></li><li><p>类里面的共有的属性和方法一定要加this使用。</p></li><li><p>类里面的this指向问题</p></li><li><p>constructor里面的this指向实例对象，方法里面的this指向这个方法的调用者</p></li></ol><p><strong>添加元素高级做法</strong>：利用**insertAdjacentHTML(position, text)**可以直接把字符串格式元素添加到父元素中。</p><p><strong>position参数</strong></p><p><strong>beforebegin:元素自身的前面</strong></p><p><strong>afterbegin:插入元素内部的第一个子节点之前<br> beforeend:插入元素内部的最后一个子节点之后</strong></p><p><strong>afterend:元素自身的后面</strong></p><p><strong>remove()</strong> <strong>可以删除指定的元素 例：element.remove();</strong></p><h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在典型的OOP的语言中（如java），都存在类的概念，类就是对象的模板，对象就是类的实例，但是在ES6之前没有类的概念。</p><p>创建对象可以通过以下三种方式：</p><ol><li><p>对象字面量   例：var xx = {}</p></li><li><p>new Object（）</p></li><li><p>自定义构造函数</p></li></ol><p><strong>构造函数</strong>时一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在js中，使用构造函数时要注意以下两点：</p><ol><li><p>构造函数用于创建某一类对象，其<strong>首字母要大写</strong></p></li><li><p>构造函数要<strong>和new一起使用</strong>才有意义</p></li></ol><p>静态成员 在构造函数本身上添加的成员 sex就是静态成员</p><p>静态成员只能通过构造函数来访问</p><p>构造函数问题：<strong>存在浪费内存的问题</strong></p><h3 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h3><p>构造函数通过原型分配的函数是所有对象所<strong>共享</strong>的。</p><p>JavaScript规定，<strong>每一个构造函数都有一个prototype属性</strong>，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p><strong>我们可以把一些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。</strong></p><p>原型的作用是什么？<strong>共享方法</strong></p><p>语法：函数名.prototype.方法 = function（）{}</p><p>所以，一般情况下，公共属性定义到构造函数里面，公共的方法放到原型对象身上</p><h3 id="对象原型proto"><a href="#对象原型proto" class="headerlink" title="对象原型proto"></a>对象原型proto</h3><ul><li><p><strong>对象都会有一个属性<strong>proto</strong></strong>指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有__proto__原型的存在。（即__proto__对象原型和原型对象prototype是等价的）</p></li><li><p>__proto__是非标准的，实际开发不可以使用这个属性。他只是内部指向原型对象prototype的一条路线。</p></li></ul><p>方法查找原则：查找对象身上是否有指定方法，因为有__proto__，就接着查找构造函数原型对象prototype身上去查找。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage027.png"></p><h3 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h3><p>如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须<strong>手动的利用constructor指向</strong>原来的构造函数</p><p>例：函数名.prototype = { //通过这个方式给原型添加多个方法，但这样就把原来原型的方法覆盖掉了</p><p>constructor：函数名，//指回原来的构造函数</p><p>}</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage028.png"></p><h4 id="JS成员的查找机制"><a href="#JS成员的查找机制" class="headerlink" title="JS成员的查找机制"></a>JS成员的查找机制</h4><ol><li><p>当访问一个对象的属性（包括方法）时，首先查找这个<strong>对象自身</strong>有没有该属性。</p></li><li><p>如果没有就查找它的原型（也就是__proto__指向的<strong>prototype原型对象</strong>）。</p></li><li><p>如果还没有就查找原型对象的原型（<strong>Object的原型对象</strong>）。</p></li><li><p>依此类推一直找到Object为止（<strong>null</strong>）。</p></li></ol><h4 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h4><p>一般情况下，this指向的是调用函数的对象。</p><p>原型对象函数里面的this指向的是 实例对象</p><h4 id="扩张内置对象"><a href="#扩张内置对象" class="headerlink" title="扩张内置对象"></a>扩张内置对象</h4><p>可以通过内置对象原型，给内置对象添加方法。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>组合继承：（ES6前）构造函数 + 原型对象 模拟实现继承</p><p>call（） 调用这个函数，并且修改函数运行时的指向</p><p>语法：函数名.call(thisArg, arg1, arg2,—)</p><p><strong>thisArg：当前调用函数this的指向对象</strong></p><h5 id="借用父构造函数继承属性"><a href="#借用父构造函数继承属性" class="headerlink" title="借用父构造函数继承属性"></a>借用父构造函数继承属性</h5><p>例：子构造函数中</p><p>Father.call(this, 属性1，属性2)；//这样子构造函数就可以使用父构造函数中的属性。</p><h5 id="借用原型对象继承方法"><a href="#借用原型对象继承方法" class="headerlink" title="借用原型对象继承方法"></a>借用原型对象继承方法</h5><ol><li>直接赋值（误）</li></ol><p>Son.prototype = Father.prototype //这时候把父构造函数的原型对象地址给了子，子修改原型对象，父也会变化</p><ol start="2"><li>创建父实例，子==父实例</li></ol><p>例: Son.prototype = new Father(); //因为这样覆盖了子的constructor，所以要指回</p><p>Son.prototype.constructor = Son;</p><h2 id="ES5中新增的方法"><a href="#ES5中新增的方法" class="headerlink" title="ES5中新增的方法"></a>ES5中新增的方法</h2><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>迭代方法：</p><p>**forEach()**：遍历数据每一个数据 array.forEach(function(value, index, array){});</p><p><strong>filter():</strong> 主要用于筛选数组，找到所有满足条件的值，返回一个<strong>新数组</strong> arr.filter(function(value, index,array){})</p><p><strong>some():</strong> 检测数组中的元素是否满足指定条件，通俗点 查找数组中是否有满足条件的元素 返回值是<strong>布尔值</strong> 如果找到第一个满足条件的，就停止查找。</p><p>array.some(function(value, index, arr){});</p><p>map（）类似于forEach（）</p><p>every（）类似于some（）</p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>trim() 会从一个字符串的两端删除空白字符</p><p>str.trim() //返回新的字符串</p><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><ol><li><strong>Object.keys()</strong> 用于获取对象自身所有属性 效果类似for。。。in</li></ol><p>Object.keys(obj) //返回一个由属性名组成的数组</p><ol start="2"><li><strong>Object.defineProperty()</strong> 定义对象中新属性或修改原有的属性。</li></ol><p>Object.defineProperty(Obj, prop, descriptor)</p><p>第二个参数是属性名，字符串</p><p>第三个参数是descriptor说明：以对象形式{}书写，其中参数有</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage029.png"></p><p>重写就是修改的意思</p><p>枚举就是遍历的意思</p><p>configurable定义true后属性将不会被修改</p><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><ol><li><p>自定义函数 function fn() {}</p></li><li><p>函数表达式（匿名函数） var fun = function() {}</p></li><li><p>new Function  var fn = new Function(‘参数1’，’参数2’，’函数体’)；</p></li></ol><p>例：var fn = new Function(‘a’,’b’,’console.log(a+b)’);</p><p>不建议使用，效率低，但这种声明方式说明，所有函数都是Function的实例（对象），函数也属于对象</p><h3 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h3><ol><li>普通函数</li></ol><p>function fn() { }  fn();</p><ol start="2"><li>对象方法</li></ol><p>var o = {             o.fn();</p><p>fn: function(){}</p><p>}                 </p><ol start="3"><li>构造函数</li></ol><p>function Star(){}  new Star();</p><ol start="4"><li>绑定事件函数</li></ol><p>btn.onclick = function() {}; </p><ol start="5"><li>定时器函数</li></ol><p>setInterval(function() {}, 1000)</p><ol start="6"><li>立即执行函数</li></ol><p>(function() {})();</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this的指向，是当我们调用函数的时候确定的。调用方式不同决定了this的指向不同。一般指向我们的调用者。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage030.png"></p><p>构造函数this指向实例对象，原型对象中的this也是指向实例对象。</p><h3 id="改变函数内部this指向"><a href="#改变函数内部this指向" class="headerlink" title="改变函数内部this指向"></a>改变函数内部this指向</h3><p>常用的方法有bind(), call(), apply() 三种方法</p><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>语法：fn.call( thisArg, arg1, arg2, —);</p><p>作用：1. 可以调用函数 2. 可以改变函数内部的this指向</p><p>主要应用：可以实现继承</p><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>语法：fn.apply(thisArg, array);</p><p>作用：1. 调用函数 2. 可以改变函数内部的this指向</p><p>但是参数必须是数组（伪数组）</p><p>主要应用：可以利用apply借助于数学内置对象求最大值（ Math.max.apply(null, array) ）</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>语法：fn.bind(thisAsg, arg1, arg2,—-);</p><p>作用：1. <strong>不会调用函数</strong> 2. 可以改变函数内部的this指向</p><p>返回由指定的this值和初始化参数改造的<strong>原函数拷贝</strong></p><p>thisArg：当前调用函数this的指向对象</p><p>arg1,arg2：传递的其他参数</p><h4 id="call-apply-bind-总结"><a href="#call-apply-bind-总结" class="headerlink" title="call(), apply(), bind()总结"></a>call(), apply(), bind()总结</h4><ol><li><p>都可以改变函数内部this指向</p></li><li><p>call和apply可以调用函数，bind不调用函数</p></li><li><p>call、bind的参数一个一个传，apply的参数以数组方式传递</p></li><li><p>call主要用于继承，apply主要用于数组打交道的情况，bind用于不调用函数又要改变内部this指向。</p></li></ol><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES5的严格模式（strict mode）是采用具有限制性JavaScript变体的一种方式，即在严格的条件下运行JS代码。（IE10以上版本浏览器才支持）</p><ol><li><p>消除了JavaScript语法的一些不合理、不严谨之处，减少了一些怪异行为。</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全。</p></li><li><p>提高编译器效率，增加运行速度。</p></li><li><p>禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的JavaScript做好铺垫。比如保留字如class，export，import不能做变量名</p></li></ol><p>严格模式可以应用到整个脚本或个别函数中</p><ol><li>为脚本开启严格模式</li></ol><p>需要<strong>在所有语句之前放一个特定语句“use strict”；(或 ‘use strict’; )</strong></p><ol start="2"><li>为函数开启严格模式</li></ol><p>需要把<strong>“use strict”；(或 ‘use strict’; )声明放在函数体所有语句之前。</strong></p><h4 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h4><ol><li>变量规定</li></ol><ul><li><p><strong>严格模式下，变量都必须先用var命令声明，然后再使用。</strong></p></li><li><p><strong>严禁删除已经声明变量。例如，delete x；语法是错误的。</strong></p></li></ul><ol start="2"><li>严格模式下this指向问题</li></ol><ul><li><p><strong>严格模式下全局作用域函数中的this指向的是underfined</strong></p></li><li><p><strong>严格模式下不加new调用构造函数，会报错</strong></p></li><li><p><strong>定时器this还是指向window</strong></p></li><li><p><strong>事件、对象还是指向调用者</strong></p></li></ul><ol start="3"><li>函数变化</li></ol><ul><li><p><strong>函数不能有重名的参数</strong></p></li><li><p><strong>函数必须声明在顶层。为了与ES6接轨，不允许在非函数的代码块内声明函数。即不能在for、if等有大括号而不是函数的代码块中声明函数。</strong></p></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p><strong>高阶函数</strong>是对其他函数进行操作的函数，它<strong>接受函数作为参数</strong>或<strong>将函数作为返回值输出</strong>。</p><p>函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p><strong>闭包</strong>指有权<strong>访问</strong>另一个函数作用域中<strong>变量</strong>的<strong>函数</strong>。</p><p>简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。</p><p><strong>变量指向的函数就是闭包函数</strong></p><p>闭包的主要作用：<strong>延伸了变量的作用范围，使变量不会被立即释放</strong>。</p><p><strong>立即执行函数也称为小闭包</strong>因为立即执行函数里面的任何一个函数都可以调用它的变量。</p><p>缺点：<strong>比较占用内存</strong></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>定义：如果<strong>一个函数在内部可以调用其本身</strong>，那么这个函数就是<strong>递归函数</strong>。</p><p>由于递归很容易发生栈溢出错误，所以必须要加退出条件return</p><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><ol><li><p>浅拷贝只是拷贝一层，<strong>更深层次对象级别的只拷贝引用</strong></p></li><li><p>深拷贝拷贝多层，每一级别的数据都会拷贝</p></li><li><p><strong>Object.assign(target, …sources)</strong> es6新增方法可以<strong>浅拷贝</strong></p></li></ol><p>深拷贝就是把所有数据都拷贝过来，更深层次而不只是引用地址，从而会可能修改了原数据。深拷贝时要先拷贝数组数据，再拷贝对象。因为数组也属于对象。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><strong>概述：</strong>正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。</p><p>正则表单式里面不用加引号。</p><p>主要用途：</p><ol><li><p>通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户表单只能输入英文字母、数字或者下划线，昵称输入框中可以输入中文（<strong>匹配</strong>）。</p></li><li><p>常用于过滤掉页面内容中的一些敏感词（<strong>替换</strong>），或者从字符串中获取我们想要的特定部分（<strong>提取</strong>）等。</p></li></ol><p>特点：</p><ol><li><p>灵活性、逻辑性和功能性非常强</p></li><li><p>可以迅速的用极简单的方式达到字符串的复杂控制</p></li><li><p>刚开始比较晦涩难懂</p></li></ol><h4 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h4><p><strong>1.</strong>  <strong>通过调用RegExp对象的构造函数创建</strong></p><p>var 变量名 = new RegExp（/表达式/）；</p><p><strong>2.</strong>  <strong>通过字面量创建</strong></p><p>var 变量名 = /表达式/；</p><h4 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h4><p><strong>test（）</strong>正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false</p><p>regexpObj.test(str)</p><ol><li><p>regexp是写的正则表达式</p></li><li><p>str我们要测试的文本</p></li><li><p>就是检测str文本是否符合我们写的正则表达式规范。</p></li></ol><h4 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h4><p>正则表达式的组成</p><p>一个正则表达式<strong>可以由简单的字符构成</strong>，比如/abc/，<strong>也可以是简单和特殊字符的组合</strong>，比如/ab*c/。其中特殊字符也被称为<strong>元字符</strong>，在正则表达式中是具有<strong>特殊</strong>意义的专用<strong>符号</strong>，如^、$、+等。</p><p><strong>边界符</strong></p><p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage031.png"></p><p>/^abc$/意味着精准匹配abc，意为开头是它结尾也是它（同一个它）</p><p><strong>字符类</strong></p><p><strong>[ ]:</strong> 表示有一系列字符可供选择，只要匹配其中一个就可以了。</p><p><strong>-:</strong> 范围符，表示省略中间的字符，例如a-z，0-9</p><p><strong>字符组合：把要的字符都加进去，不用分隔，例如：a-zA-Z0-9_-</strong></p><p><strong>取反符：</strong>如果<strong>中括号里面有^ 表示取反的意思</strong> 和边界符完全不同</p><p><strong>量词符</strong></p><p>量词符用来<strong>设定某个模式的出现的次数</strong></p><p>*<strong>**     **相当于 &gt;=0 可以出现0次或者很多次</strong></p><p><strong>+</strong>     <strong>相对于&gt;=1 可以出现1次或者很多次</strong></p><p><strong>?</strong>     <strong>相当于1 || 0</strong></p><p><strong>{n}</strong>     <strong>就是重复n次</strong></p><p><strong>{n，}    大于等于n次</strong></p><p><strong>{n，m}   大于等于n次并且小于等于m次（中间不要有空格）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage032.png"></p><p><strong>括号总结</strong></p><p><strong>大括号</strong> 量词符，里面表示重复次数</p><p><strong>中括号</strong> 字符集合。匹配方括号中的任意字符。</p><p><strong>小括号</strong> 表示分组</p><p>可以在线测试：<a href="http://c.runoob.com/">http://c.runoob.com/</a></p><p>注意</p><p>/^abc{2}$/ 匹配的是abcc</p><p>/^(abc){2}$/ 匹配的是abcabc</p><p><strong>预定义类</strong></p><p>预定义类指的是<strong>某些常见模式的简写方式</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage033.png"></p><p>小写要，大写不要</p><p><strong>|</strong> <strong>表示或者</strong> 例：/^red | green $/ 匹配red或者green字符串</p><p><strong>替换</strong></p><p>replace替换</p><p>replace（）方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p><p>string.replace(substr/regexp,replacement)</p><p>第一个参数：被替换的字符串或者正则表达式</p><p>第二个参数：替换为的字符串</p><p>返回值是一个替换完毕的新字符串</p><p><strong>正则表达式参数</strong></p><p>/表达式/[switch]</p><p>switch（也称为修饰符）按照什么样的模式来匹配。有三种值：</p><p><strong>g：全局匹配</strong></p><p><strong>i：忽略大小写</strong></p><p><strong>gi：全局匹配 + 忽略大小写</strong></p><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="let变量"><a href="#let变量" class="headerlink" title="let变量"></a>let变量</h2><p>let声明的变量会与当前块级作用域绑定，不被其他块级作用域访问。</p><p>特点：</p><ol><li>let声明的变量只在所处于的块级作用域有效</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>&#125;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span></code></pre><p>例如：for循环中，索引值就不会变成全局变量而访问到，而且每一次循环都保留着它的i值。</p><ol start="2"><li>不存在变量提升</li></ol><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span></code></pre><ol start="3"><li>暂时性死区</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;tmp = <span class="hljs-string">&#x27;abc&#x27;</span><span class="hljs-keyword">let</span> tmp&#125;</code></pre><p>tmp只看当前块级作用域中的变量，不再往上查找。</p><h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>作用：声明常量，常量就是值（内存地址）不能变化的量。</p><p>特点：</p><ul><li>具有块级作用域</li></ul><ul><li>声明常量时必须赋值</li></ul><h2 id="let、const、var区别"><a href="#let、const、var区别" class="headerlink" title="let、const、var区别"></a>let、const、var区别</h2><ol><li><p>使用 <strong>var</strong> 声明的变量，其作用域为<strong>该语句所在的函数内，且存在变量提升现象。</strong> </p></li><li><p>使用 <strong>let</strong> 声明的变量，其作用域为<strong>该语句所在的代码块内，不存在变量提升。</strong> </p></li><li><p>使用 <strong>const</strong> 声明的是常量，在后面出现的代码中<strong>不能再修改该常量的值。</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage037.png"></p></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6中允许从数组或对象中提取值，按照对应位置，对变量赋值。</p><p>如果解构不成功，变量的值为underfined。</p><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;<span class="hljs-keyword">let</span> &#123; name, age &#125; = person<span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// 20</span></code></pre><p>也可以用属性名匹配对象，用变量实际赋值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge &#125; = person<span class="hljs-built_in">console</span>.log(myName) <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><span class="hljs-built_in">console</span>.log(myAge) <span class="hljs-comment">// 20</span></code></pre><h3 id="箭头函数（-gt-）"><a href="#箭头函数（-gt-）" class="headerlink" title="箭头函数（ ( )=&gt; { } ）"></a>箭头函数（ ( )=&gt; { } ）</h3><p>ES6中新增的定义函数的方式。用来简化函数定义语法的。<strong>一般把它赋值给一个变量，变量名就是函数名。</strong></p><p>特点：</p><ul><li>函数体中只有一句代码，且代码的执行结果就是<strong>返回值</strong>，可以省略大括号</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<span class="hljs-keyword">return</span> num1 + num2&#125;<span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> num1 + num2</code></pre><ul><li>如果形参只有一个，可以省略小括号</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">v</span>) </span>&#123;<span class="hljs-keyword">return</span> v&#125;<span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v</code></pre><ul><li>箭头函数不绑定this关键字。如果在箭头函数中使用this，<strong>this关键字指向箭头函数定义位置的this</strong></li></ul><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">first, ...args</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(first)<span class="hljs-built_in">console</span>.log(args)&#125;sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</code></pre><p>注：剩余参可以数和解构配合使用</p><h2 id="Array的扩展方法"><a href="#Array的扩展方法" class="headerlink" title="Array的扩展方法"></a>Array的扩展方法</h2><h3 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h3><ul><li>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]...ary <span class="hljs-comment">// 1, 2, 3</span><span class="hljs-built_in">console</span>.log(...ary) <span class="hljs-comment">// 1 2 3</span></code></pre><ul><li>扩展运算符可以将两个数组分散合并成一个数组</li></ul><ul><li>将类数组或可遍历对象转换为真正的数组</li></ul><h3 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h3><p>将类数组或可遍历对象转换为真正的数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>length: <span class="hljs-number">3</span>&#125;<span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.from(arrayLike) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></code></pre><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><h3 id="实例方法：find（）"><a href="#实例方法：find（）" class="headerlink" title="实例方法：find（）"></a>实例方法：find（）</h3><p>用于找出第一个符合条件的数组成员，<strong>返回当前项</strong>，如果没有找到返回underfined</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [&#123;id: <span class="hljs-number">1</span>,name: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;， &#123;id: <span class="hljs-number">2</span>,name: <span class="hljs-string">&#x27;李四&#x27;</span>]<span class="hljs-keyword">let</span> target = ary.find(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item.id == <span class="hljs-number">2</span>)</code></pre><h3 id="实例方法：findIndex（）"><a href="#实例方法：findIndex（）" class="headerlink" title="实例方法：findIndex（）"></a>实例方法：findIndex（）</h3><p>用于找出第一个符合条件的数组成员的位置，<strong>返回索引值</strong>，如果没有就返回-1</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]<span class="hljs-keyword">let</span> index = ary.findIndex(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> value &gt; <span class="hljs-number">9</span>)<span class="hljs-built_in">console</span>.log(index) <span class="hljs-comment">// 2</span></code></pre><h3 id="实例方法：includes（）"><a href="#实例方法：includes（）" class="headerlink" title="实例方法：includes（）"></a>实例方法：includes（）</h3><p>表示某个数组是否包含给定的值，<strong>返回布尔值</strong>。</p><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>) <span class="hljs-comment">// false</span></code></pre><h2 id="String的扩展方法"><a href="#String的扩展方法" class="headerlink" title="String的扩展方法"></a>String的扩展方法</h2><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>ES6新增的创建字符串的方式，使用反引号定义。</p><p>例：let name = ‘zhangsan’;</p><p>特点：</p><ul><li>模板字符串中可以<strong>解析变量</strong>（加变量）用**${ }**包裹</li></ul><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;张三&#x27;</span><span class="hljs-keyword">let</span> sayHello = <span class="hljs-string">`hello, my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span> <span class="hljs-comment">// hello, my name is 张三</span></code></pre><ul><li>模板字符串可以<strong>换行</strong></li></ul><ul><li>在模板字符串中<strong>可以调用函数</strong>，得到函数的返回值。</li></ul><h3 id="实例方法：startWith-和-endsWith"><a href="#实例方法：startWith-和-endsWith" class="headerlink" title="实例方法：startWith() 和 endsWith()"></a>实例方法：startWith() 和 endsWith()</h3><p>startWith()：表示参数字符串是否在原字符串的头部，返回布尔值</p><p>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</p><p>例：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world&#x27;</span>str.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span>str.endWith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-comment">// true</span></code></pre><h3 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h3><p>repeat方法表示将原字符串重复n次，返回一个新字符串</p><pre><code class="hljs js"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;xxx&quot;</span><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;hellohello&quot;</span></code></pre><h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成Set数据结构。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()</code></pre><p>Set函数可以接受一个数值作为参数，用来初始化。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</code></pre><p>Set默认去重，size是它的长度</p><p>实例方法</p><p>add（value）：添加某个值，返回Set结构本身</p><p>delete（value）：删除某个值，返回一个布尔值，表示删除成功</p><p>has（value）：返回一个布尔值，表示该值是否为Set的成员</p><p>clear（）：清除所有成员，没有返回值</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>) <span class="hljs-comment">// 向set结构中添加值</span>s.delete(<span class="hljs-number">2</span>) <span class="hljs-comment">// 删除set结构中的2值</span>s.has(<span class="hljs-number">1</span>) <span class="hljs-comment">// 表示set结构中是否有1这个值 返回布尔值</span>s.clear() <span class="hljs-comment">// 清除set结构中的所有值</span></code></pre><p>遍历</p><p>Set结构的实例和数组一样，也拥有forEach方法，用于对每个成员某种操作，没有返回值。</p><p>s.forEach( value =&gt; console.log(value) )</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记都在电脑本地，是word文档，在转markdown了</title>
    <link href="/2020/11/18/hello-world/"/>
    <url>/2020/11/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>有点麻烦，要把word里面的图片重新保存再上传</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
