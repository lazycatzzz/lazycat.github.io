<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript内存管理（二）——垃圾回收及内存泄漏</title>
    <link href="/2021/01/22/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2021/01/22/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>上一次我们已经探讨了内存的存放，它是通过什么样的方式存放的。存和用已经讲了，这次我们来重点探讨一下它的垃圾回收以及它的内存泄漏。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>在内存使用完毕之后，就会有最后一步——内存释放。就像分配内存一样，JavaScript引擎也帮我们处理这个步骤，具体的讲，JavaScript不像C/C++，它有自己的一套垃圾回收机制。</p><p>一旦JS引擎识别到变量或者函数已经不被需要时，就会释放它所占用的内存</p><p>这样做的主要问题是，是否还需要一些内存是一个不可判定的问题，这意味着不可能有一种算法能够在内存过时的那一刻收集所有不再需要的内存。</p><p>一些算法可以很好解决这个问题。<strong>垃圾回收算法主要依赖于引用的概念。</strong>在内存管理的环境中，如果一个对象可以访问到另一个对象，叫做一个对象引用另一个对象。例如，一个JavaScript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。当然这里的“对象”概念并不特指JavaScript对象，还包括函数作用域（或者全局词法作用域）。</p><p>下面我主要探讨最常用的方法：<strong>引用计数</strong>和<strong>标记清除算法</strong></p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>这是最初级的垃圾收集算法。此算法通过计数来判断一个变量是否还被引用。</p><p>举个例子。当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另外一个变量，则该值引用次数加1，反之，如果包含这个值的引用的变量又获取别的值替代该值，则这个值的引用次数减1。</p><p>当这个值的引用次数变成0时，代表没有办法再访问这个值，即这个值已经没有用了。因此可以把这个值占用的内存空间收回来。这样，当垃圾回收运行时，它就会释放那些引用次数为零的值所占用的内存。</p><p>举个例子</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;name: <span class="hljs-string">&#x27;John&#x27;</span>,age: <span class="hljs-number">22</span>,hobbies: [<span class="hljs-string">&#x27;hiking&#x27;</span>, <span class="hljs-string">&#x27;reading&#x27;</span>]&#125; <span class="hljs-comment">// 新建一个对象，计数1</span><span class="hljs-keyword">let</span> newPerson = person <span class="hljs-comment">// 对象 +1</span><span class="hljs-keyword">let</span> hobbies = newPerson.hobbies <span class="hljs-comment">// 对象 +1</span>person = <span class="hljs-literal">null</span> <span class="hljs-comment">// 对象 -1</span>newPerson = <span class="hljs-literal">null</span> <span class="hljs-comment">// 对象 -1</span></code></pre><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/引用计数.gif" /><p>可以看到，在最后我们只有hobbies还引用引用着对象的属性。虽然对象是零引用，可以被垃圾回收了。但是它的属性hobbies还被hobbies引用，所以海不能回收。</p><h4 id="缺陷——循环引用"><a href="#缺陷——循环引用" class="headerlink" title="缺陷——循环引用"></a>缺陷——循环引用</h4><p>引用计数有一个缺陷，就是当如果两个对象互相引用时（循环），其引用计数值不为0，即使后面没有对这两个后面的引用。</p><p>举个例子</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> son = &#123;  name: <span class="hljs-string">&#x27;John&#x27;</span>&#125;<span class="hljs-keyword">let</span> dad = &#123;  name: <span class="hljs-string">&#x27;Jason&#x27;</span>&#125;son.dad = daddad.son = sonson = <span class="hljs-literal">null</span>dad = <span class="hljs-literal">null</span></code></pre><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/reference-cycle.png"></p><p>我们可以看到，两个对象被创建，并且互相引用，形成了一个循环。它们即使最后设置为null，判定它们已经没有用了，可以被回收了。但是，引用计数算法考虑到它们互响还有一次引用，所以它们不会被回收。</p><h4 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h4><p>IE6，7使用引用计数方式对DOM对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> div<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;myDivElement&quot;</span>)  div.circularReference = div  div.lotsOfData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10000</span>).join(<span class="hljs-string">&quot;*&quot;</span>)&#125;</code></pre><p>在上面的例子中，myDivElement这个DOM元素里的circularReference属性循环引用了myDivElement，这样引用计数就会始终认为这里至少有一个引用。即使其从DOM树中删去了。如果这个DOM元素有大量的数据，那么这个数据会一直占用内存永远不会被释放。</p><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>这个算法的思想是将是否需要对象转化为确定该对象是否可到达。</p><p>标签清除的算法步骤如下</p><ol><li><strong>根是关键</strong>。所谓的根就是代码中引用的全局变量。例如，在JavaScript中，可以充当根的全局变量就是window对象。在Node.js的全局变量就是global。垃圾回收将构建所有根的完整列表。</li><li>然后，该算法会检查所有根及其子代，并将其标记为活动状态，这意味着它们还有用，不会被清除。而根无法达到的任何内容都将被标记为垃圾。</li><li>最后，垃圾回收会释放所有未标记为活动的内存，并将该内存返回给OS（Operating System，操作系统）。</li></ol><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/标记清除.gif" /><p>这个算法比引用计数法好，优势就在于它可以解决循环引用的问题。因为根无法访问到循环引用的对象，所以算法会将其标记为垃圾然后清除。</p><p>从2012年起，所有现代浏览器都使用标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p><h4 id="缺陷——无法从根对象查询到的对象都将被清除"><a href="#缺陷——无法从根对象查询到的对象都将被清除" class="headerlink" title="缺陷——无法从根对象查询到的对象都将被清除"></a>缺陷——无法从根对象查询到的对象都将被清除</h4><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在了解完垃圾回收之后，我们就要开始探讨内存泄漏咯。之前在与师兄的讨论以及一次面试时被面试官重复反问内存泄漏之后，我现在对内存泄漏的定义非常敏感。所以我们首先回答第一个问题。</p><p>什么是内存泄漏？根据维基百科的回答，<strong>内存泄漏是计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。</strong>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>那么就很明了了，就是在内存已经没有用可以释放的时候，JS垃圾回收机制因为某种原因导致判断它还有用，导致它一直占用内存。</p><p>那么什么情况下就是内存泄漏？</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在JS中，如果省略var，const或let去定义一个变量，那么这个变量就会添加到全局对象上。</p><pre><code class="hljs js">user = getUser()<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUser</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;user&#x27;</span>&#125;</code></pre><p>了解过垃圾回收我们都知道，从根可以范围到的变量是不会被清除的，所以users会一直都在。</p><p>当然，在严格模式下可以避免这种情况。</p><p>除了意外的将变量添加到全局对象，我们有时候需要主动想全局对象添加属性，这时候，一旦该属性不需要了，要记得手动将它释放掉。</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.users = <span class="hljs-literal">null</span></code></pre><h3 id="计时器和回调"><a href="#计时器和回调" class="headerlink" title="计时器和回调"></a>计时器和回调</h3><p>忘记计时器和回调会使应用程序的内存使用率上升。特别是在单页应用程序（spa）中，动态添加事件侦听器和回调时，必须要小心！</p><h4 id="Interval计时器"><a href="#Interval计时器" class="headerlink" title="Interval计时器"></a>Interval计时器</h4><pre><code class="hljs js"><span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>)&#125;, <span class="hljs-number">2000</span>)</code></pre><p>只要setInterval没有被取消，则其中的引用对象就不会被垃圾回收。</p><p>确保在不再需要时清除它。</p><pre><code class="hljs js"><span class="hljs-built_in">clearInterval</span>(intervalId)</code></pre><p>那setTimeout是否要手动清除？要看自己的需求，如果要在执行前清除则需手动，如果是执行后，可以不用管。</p><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><p>如果我们向按钮添加了onclick侦听器，之后将该按钮删除。如果是旧的浏览器，它无法收集侦听器，当然在如今，这不是问题。</p><p>不过，如果在单页面应用，在页面内容发生变化时，即使没有绑定侦听器的元素在页面上，侦听器依旧还会响应，这说明它们没有被清理掉。所以，在不需要事件侦听器时，删除它们仍然是一个好的做法。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;button&#x27;</span>)<span class="hljs-keyword">const</span> onClick = <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;hi&#x27;</span>)btn.addEventListerner(<span class="hljs-string">&#x27;click&#x27;</span>, onClick)btn.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, onClick)btn.parentNode.removeChild(btn)</code></pre><h3 id="脱离DOM引用"><a href="#脱离DOM引用" class="headerlink" title="脱离DOM引用"></a>脱离DOM引用</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> elements = []<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;button&#x27;</span>)elements.push(element)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeAllElements</span>(<span class="hljs-params"></span>) </span>&#123;  elements.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;    <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">document</span>.getElementById(item.id))  &#125;)&#125;</code></pre><p>我们通过删除DOM元素的方式删除了这个DOM，但是这并不代表删除了这个引用。我们需要同时删除数组中的引用。因为每个DOM元素也保留了对其父节点的引用，因此可以防止垃圾回收收集元素的父元素和子元素。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> elements = []<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;button&#x27;</span>)elements.push(element)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeAllElements</span>(<span class="hljs-params"></span>) </span>&#123;  elements.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;    <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">document</span>.getElementById(item.id))    element.splice(index, <span class="hljs-number">1</span>)  &#125;)&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次我们主要探讨了JavaScript的垃圾回收和内存泄漏，通过了解垃圾回收的机制，进一步理解内存泄漏发生的原因以及解决的方法。在理解好这些细节之后，相信以后设计程序时，就可以少一点bug了。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this的深入理解</title>
    <link href="/2021/01/20/this%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <url>/2021/01/20/this%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是this？"><a href="#什么是this？" class="headerlink" title="什么是this？"></a>什么是this？</h2><p>this关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。（引自《你所不知道的JavaScript》）</p><p>在实际开发中，熟练的使用this函数可以让我们的代码更加简练并且易于复用。虽然很多时候，我们设计函数都会显式传递一个上下文对象，但是随着使用模式越来越复杂，显式上下文对象会让代码变得越来越混乱，使用this则不会这样。</p><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p>在理解this之前首先我们要消除一些对this的错误认识。一是this指向自身，二是this指向自身的作用域。这包括我在内，之前也是这么认为。</p><h3 id="this指向自身"><a href="#this指向自身" class="headerlink" title="this指向自身"></a>this指向自身</h3><p>按字面意思理解this好像确实是那么一会事，这不指向自身还指向谁啊，名字都这么叫。我们先不探讨它指向谁，我们先解决，它为什么不是指向自身。</p><p>事例代码</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo：&quot;</span> + num)  <span class="hljs-built_in">this</span>.count++&#125;foo.count = <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++</span>)</span> &#123;  <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">i&gt;<span class="hljs-number">5</span></span>)</span> &#123;    foo(i)  &#125;&#125;<span class="hljs-built_in">console</span>.log(foo.count)</code></pre><p>按照说法，它指向自身，那么foo.count应该输出4，那实际是？</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210119215146959.png" alt="image-20210119215146959"></p><p>实际上是0，因为this并不指向自身，而this.count实际上是创建了一个全局变量，它的值为NaN。</p><h3 id="this指向它的作用域"><a href="#this指向它的作用域" class="headerlink" title="this指向它的作用域"></a>this指向它的作用域</h3><p>这个问题需要明确的是——this在任何情况下都不指向函数的词法作用域。在JavaScript内部，作用域对象是无法通过js代码访问的，因为它存在于JavaScript引擎的内部。</p><p>看看事例代码</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><span class="hljs-built_in">this</span>.bar()&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;foo()</code></pre><p>结果是</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210119220634575.png" alt="image-20210119220634575"></p><p>调用bar的时候最自然的方式就是省略前面的this，直接使用词法引用标识符。再加上我们之前说的结论，this是无法实现引用另一个词法作用域内部的东西。</p><h2 id="this的全面解析"><a href="#this的全面解析" class="headerlink" title="this的全面解析"></a>this的全面解析</h2><h3 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h3><p>首先，<strong>this是在调用时被绑定的，完全取决于函数的调用位置</strong>。我们只有找到this的真正调用位置，才能知道，this指向哪里。最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的<strong>调用位置就在当前正在执行的函数的前一个调用中</strong>。</p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>我们找到this的调用位置，然后根据下面的规则进行判断，它是属于哪种绑定，多条规则可用时我们判断他们的优先级。</p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>最常见的函数调用类型：独立函数调用。可以把这条规则看作时无法应用其他规则时的默认规则。看看事例代码</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>foo() <span class="hljs-comment">// 2</span></code></pre><p>我们可以看到，this.a被解析成了全局变量a。这是因为foo在调用时没有应用任何修饰，因此是默认绑定，this指向它的调用位置，也就是全局对象。但是如果使用严格模式，那么this是undefined。</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>这条规则需要考虑调用位置是否有上下文对象，也就是是否被某个对象拥有或包含。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123;a: <span class="hljs-number">2</span>,foo: foo&#125;obj.foo() <span class="hljs-comment">// 2</span></code></pre><p>这很好理解，通过obj.foo来引用函数foo，函数在执行是，落脚点是对象obj。所以this指向obj对象。当然，对象属性引用链中只有最顶层或者说最后一层会影响调用位置。例如：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj2 = &#123;a: <span class="hljs-number">42</span>,foo: foo&#125;<span class="hljs-keyword">var</span> obj1 = &#123;a: <span class="hljs-number">2</span>,obj2: obj2&#125;obj1.obj2.foo() <span class="hljs-comment">// 42</span></code></pre><p>虽然对象嵌套绕来绕去，但是foo的前一个调用就是obj2，所以前面的花里胡哨省略，我们只看obj2，所以a = 42。</p><h5 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h5><p>有一种情况就是丢失了绑定对象，也就是应用了默认绑定，将this 绑定到全局对象或者 undefined 上（取决于是否应用了严格模式）</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123;a: <span class="hljs-number">2</span>,foo: foo&#125;<span class="hljs-keyword">var</span> bar = obj.foo<span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>bar() <span class="hljs-comment">// &quot;oops, global&quot;</span></code></pre><p>其实很好理解，bar引用了obj.foo，实际上它引用foo函数本身，所以在指向bar的时候，是不会经过obj的，所以foo的上一个调用就是全局，this指向的自然就是全局对象。</p><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>这个规则可以说是我们的老朋友了，显式绑定，顾名思义，就是使用函数的call、apply方法将this强制绑定到指定的对象上。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123;a: <span class="hljs-number">2</span>&#125;foo.call(obj) <span class="hljs-comment">// 2</span></code></pre><p>通过foo.call(..)，我们可以在调用foo的时候强制把它的this绑定在obj上。</p><p>但是显式绑定依然无法解决我们前面说的丢失绑定问题，但是它的变种可以解决这个问题。</p><h5 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h5><p>硬绑定的典型应用场景就是<strong>创建一个包裹函数，传入所有的参数并返回接收到的所有值</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj = &#123;a: <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  foo.call(obj)&#125;bar() <span class="hljs-comment">//2</span><span class="hljs-built_in">setTimeout</span>(bar, <span class="hljs-number">100</span>) <span class="hljs-comment">// 2</span><span class="hljs-comment">// 硬绑定的bar不可能再修改它的this</span>bar.call(<span class="hljs-built_in">window</span>) <span class="hljs-comment">// 2</span></code></pre><p>其实原理很简单，就是在原来的显式绑定基础上外面再套一层函数，无论怎么调用bar，foo都绑定在foo上。</p><p>另一种方法就是创建一个可以重复使用的辅助函数</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a, something)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + something&#125;<span class="hljs-comment">// 简单的辅助绑定函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">fn, obj</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> fn.apply(obj, <span class="hljs-built_in">arguments</span>)&#125;&#125;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">var</span> bar = bind(foo, obj)<span class="hljs-keyword">var</span> b = bar(<span class="hljs-number">3</span>) <span class="hljs-comment">// 2 3</span><span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 5</span></code></pre><p>由于硬绑定式一种非常常用的模式，所以ES5中提供了内置方法Function.prototype.bind</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a, something)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + something&#125;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">var</span> bar = foo.bind(obj)<span class="hljs-keyword">var</span> b = bar(<span class="hljs-number">3</span>) <span class="hljs-comment">// 2 3</span><span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 5</span></code></pre><h5 id="API调用的上下文"><a href="#API调用的上下文" class="headerlink" title="API调用的上下文"></a>API调用的上下文</h5><p>许多的第三方库的函数，以及JavaScript语言和宿主环境中许多新的内置函数，都提供了一种可选的参数，我们通常称之为“上下文”（context），其作用和bind一样，确保你的回调函数使用指定的this。</p><h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>所谓的new绑定，就是我们在调用构造函数时，新建的对象会绑定到函数调用的this上。首先我们要明确一点，<strong>JavaScript的new关键字和其他语言的不同，它并不会实例化一个类。构造函数也只是一个普通的函数，需要被new操作符调用罢了。</strong>所以所谓的“构造函数”其实是“构造调用”。</p><p>new 一个函数会执行一下步骤：</p><ol><li>创建（或者说是构造）一个全新的对象</li><li>这个新对象会执行[[原型]]连接</li><li>这个新对象会绑定到函数调用的this</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li></ol><p>而第三个步骤，就是我们的new绑定。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在了解了绑定规则之后，我们就可以判断this是通过哪种方式绑定的，但也有时候符合多种绑定规则的情况，这时候我们要清楚他们的优先级。像默认绑定这种万金油规则无疑是优先级最低的，我们先思考隐式绑定、显式绑定、以及new绑定谁的优先级高。</p><p>我们先判断隐式绑定和显式绑定的优先级</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;<span class="hljs-keyword">var</span> obj1 = &#123;a: <span class="hljs-number">2</span>,foo: foo&#125;<span class="hljs-keyword">var</span> obj2 = &#123;a: <span class="hljs-number">3</span>,foo: foo&#125;obj1.foo() <span class="hljs-comment">// 2</span>obj2.foo() <span class="hljs-comment">// 3</span>obj1.foo.call(obj2) <span class="hljs-comment">// 3</span>obj2.foo.call(obj1) <span class="hljs-comment">// 2</span></code></pre><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210120171624237.png" alt="image-20210120171624237"></p><p>可以看出来显式绑定比隐式绑定的优先级高</p><p>我们再比较隐式绑定和new绑定</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;  <span class="hljs-built_in">this</span>.a = something&#125;<span class="hljs-keyword">var</span> obj1 = &#123;  foo: foo&#125;<span class="hljs-keyword">var</span> obj2 = &#123;&#125;obj1.foo(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(obj1.a)<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.foo(<span class="hljs-number">4</span>)<span class="hljs-built_in">console</span>.log(obj1.a) <span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(bar.a) <span class="hljs-comment">// 4</span></code></pre><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210120172337836.png" alt="image-20210120172337836"></p><p>可以看到obj1.a并没有发生改变，new创建了一个新对象并将this绑定在这个对象上，所以new绑定优先级比隐式绑定高。</p><p>那显式绑定和new绑定谁高？</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;  <span class="hljs-built_in">this</span>.a = something&#125;<span class="hljs-keyword">var</span> obj1 = &#123;&#125;<span class="hljs-keyword">var</span> bar = foo.bind(obj1)bar(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(obj1.a) <span class="hljs-comment">// 2</span><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> bar(<span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(obj1.a) <span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(baz.a) <span class="hljs-comment">// 3</span></code></pre><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210120172733865.png" alt="image-20210120172733865"></p><p>按照我们之前的理论，硬绑定的this是不会再改变的，但是结果baz.a为3，这说明new确实将this绑定到了新对象上。那为什么会这样？其实ES5中的bind比我们想象的复杂的多，有时间可以去了解一下，而在其中有</p><pre><code class="hljs js"><span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="hljs-built_in">this</span> : oThis<span class="hljs-comment">// .....</span>fNOP.prototype = <span class="hljs-built_in">this</span>.prototypefBound.prototype = <span class="hljs-keyword">new</span> fNOP()</code></pre><p>这就是修改this的代码，bind会根据函数是否是通过new来调用，从而判断this是赋予传入对象还是给new的新对象，如果是new，则this绑定到新对象上。所以，new绑定优先级是高于显式绑定的。</p><p>总结就是</p><ol><li><strong>函数是否是new中调用的，是，this绑定在新创建的对象上</strong></li><li><strong>函数是否通过call、apply、硬绑定调用的，是，this绑定在指定对象上</strong></li><li><strong>函数调用的位置是否有对象上下文，是，this绑定在那个上下文对象上</strong></li><li><strong>如果以上情况都不符合，就是默认绑定，this绑定在全局对象或者undefined上（这取决于是否是严格模式）</strong></li></ol><h3 id="this的一些讲究"><a href="#this的一些讲究" class="headerlink" title="this的一些讲究"></a>this的一些讲究</h3><h4 id="绑定的例外"><a href="#绑定的例外" class="headerlink" title="绑定的例外"></a>绑定的例外</h4><p>在某些情况下，你以为应当应用其他绑定规则时，实际上应用的可能是默认绑定规则。</p><p>例如</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>foo.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 2</span></code></pre><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210120174840618.png" alt="image-20210120174840618"></p><p>如果把null、undefined作为this传入call、apply、bind中，这些值在调用是会被忽略，实际应用默认绑定规则。</p><p>当我们需要用bind来实现函数的柯里化时，null作为传入值就很有用了。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a,b</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a:&quot;</span> + a + <span class="hljs-string">&quot;, b:&quot;</span> + b)&#125;<span class="hljs-keyword">var</span> bar = foo.bind(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)bar(<span class="hljs-number">3</span>) <span class="hljs-comment">// a: 2, b: 3</span></code></pre><p>但是这样会存在一个问题，当我们使用第三方库函数时，如果某个函数确实使用了this，那么传一个null值就会让this指向全局对象，我们就会在全局对象上创建了一些新变量，这可能会造成不可预估的后果，而且难以分析和追踪bug。</p><p>我们可以通过传入一个特殊的对象来解决这个问题，创建一个空的非委托的对象——“DMZ”(demilitarized zone，非军事区)</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a,b</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a:&quot;</span> + a + <span class="hljs-string">&quot;, b:&quot;</span> + b);&#125;<span class="hljs-comment">// 我们的 DMZ 空对象</span><span class="hljs-keyword">var</span> dmz = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<span class="hljs-comment">// 把数组展开成参数</span>foo.apply(dmz, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// a:2, b:3</span><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span><span class="hljs-keyword">var</span> bar = foo.bind( dmz, <span class="hljs-number">2</span> );bar(<span class="hljs-number">3</span>); <span class="hljs-comment">// a:2, b:3</span></code></pre><p>这样做的好处就在于，我们做的修改都是在这个对象里面完成的，不会影响到全局对象。而用Object.create(null)创建对象和{ }其实差别不大，但它不会创建Object.prototype这个委托，它比{ }更空。</p><h4 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h4><p>我们前面讲勒四条规则已经可以包含所有正常的函数，但是ES6中有无法使用这些规则的特殊函数——箭头函数。</p><p>箭头函数并不是使用function关键字定义的，而是使用被称为”胖箭头“的操作符=&gt;定义的。箭头函数不使用this的四种规则，而箭头函数的this由外层的作用域决定的，也就是，外层的this指向哪里，箭头函数里的this就指向那里。箭头函数最常用于回调函数中，例如事件处理器或者定时器。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 这里的 this 在此法上继承自 foo()</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);&#125;,<span class="hljs-number">100</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123;a:<span class="hljs-number">2</span>&#125;;foo.call( obj ); <span class="hljs-comment">// 2</span></code></pre><p>当然我们也可以用词法作用域实现这种效果</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(self.a);&#125;,<span class="hljs-number">100</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123;a:<span class="hljs-number">2</span>&#125;;foo.call( obj ); <span class="hljs-comment">// 2</span></code></pre><p>当然代码的书写时两种方式都可以用，不过同一个程序或者函数混合使用两种风格通常会使代码更难维护，而且可能更难编写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要想知道this指向谁，我们先找到this的调用位置，然后根据四条规则，对应它们的绑定关系，如果同时符合多条绑定规则，则要判断他们的优先级，当然也有绑定例外的情况需要注意。不管怎么说，深入理解this能让我们更好的去运用它，写出更简练、复用性更高的代码。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript内存管理（一）——内存的存放</title>
    <link href="/2021/01/16/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E6%94%BE/"/>
    <url>/2021/01/16/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E6%94%BE/</url>
    
    <content type="html"><![CDATA[<p>内存是用来放东西的，我们创建的变量、对象、数组都存在里面。那么JavaScript是怎么存放数据的，内存又是怎么释放的，内存泄漏又是怎么一回事，这篇文章我们先主要探讨内存的存放。</p><h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><p>内存的一生，大致分为3个阶段</p><ol><li>分配你所需要的内存</li><li>使用内存，即对内存的读写</li><li>释放不再需要的内存</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/memory-life-cycle.33fa7f96.png"></p><h2 id="内存中的堆栈和堆"><a href="#内存中的堆栈和堆" class="headerlink" title="内存中的堆栈和堆"></a>内存中的堆栈和堆</h2><p>在JavaScript里，我们通过两种数据结构来存储数据，一个是堆栈，一个是堆。它们分别用于不同的数据存储，协同来完成数据存储的工作。</p><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>堆栈是 js 用于存储静态数据的数据结构，静态数据是引擎在编译的时候就知道大小的数据，包括 <strong>String，Number，Boolean，undefined，null 以及指向引用类型的地址</strong>。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/stack-memory-explained.png" alt="Memory stack Examples"></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>js中用来存储对象和函数，根据需要动态分配内存空间。</p><table><thead><tr><th>堆栈</th><th>堆</th></tr></thead><tbody><tr><td>存放基本类型和引用</td><td>对象和函数</td></tr><tr><td>大小在编译时已知</td><td>在运行时才知道大小</td></tr><tr><td>分配固定数量的内存</td><td>没怎么限制</td></tr></tbody></table><h2 id="JavaScript内存分配"><a href="#JavaScript内存分配" class="headerlink" title="JavaScript内存分配"></a>JavaScript内存分配</h2><p>JavaScript在定义变量的时候就已经把内存分配好了，而如果把变量的值变化的话，它不会更改原始值，而是创建一个新值。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">123</span> <span class="hljs-comment">// 给数值变量分配内存</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;string&#x27;</span> <span class="hljs-comment">// 给字符串分配内存</span><span class="hljs-keyword">var</span> p = &#123; <span class="hljs-comment">// 给对象及其包含的值分配内存</span>  a: <span class="hljs-number">1</span>,  b: <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// 给数组及其包含的值分配内存（就像对象一样)</span>str = <span class="hljs-string">&#x27;newString&#x27;</span> <span class="hljs-comment">// 給新字符串分配内存</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a</span>) </span>&#123;  <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// 给函数（可调用的对象）分配内存</span><span class="hljs-comment">//函数表达式也能分配一个对象</span>someElement.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  someELement.style.backgroundColor = <span class="hljs-string">&#x27;blur&#x27;</span>&#125;, <span class="hljs-literal">false</span>)</code></pre><p>有些函数调用结果就是分配对象内存</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-comment">// 分配一个 Date 对象</span><span class="hljs-keyword">var</span> e = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>) <span class="hljs-comment">// 分配一个DOM元素</span></code></pre><p>有些方法分配新变量或者对象</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;string&#x27;</span><span class="hljs-keyword">var</span> s2 = s.substr(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// s2是新字符串</span><span class="hljs-comment">// 因为字符串是不变量</span><span class="hljs-comment">// JavaScript可能决定不分配内存</span><span class="hljs-comment">// 只是存储了[0-3]的范围</span><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;bac&#x27;</span>]<span class="hljs-keyword">var</span> a2 = [<span class="hljs-string">&#x27;bca&#x27;</span>, <span class="hljs-string">&#x27;cba&#x27;</span>]<span class="hljs-keyword">var</span> a3 = a.concat(a2)<span class="hljs-comment">// 新数组有四个元素，是a 连接 a2 的结果</span></code></pre><p>有一点需要注意的是，所有变量首先指向堆栈。如果是非原始值，则堆栈包含堆中对象的引用。</p><p>堆的内存没有按特定的方式排序，所有在存储对象或函数时，会将它们的引用存储在堆栈中。我们可以把这个引用比喻为地址，通过它我们就可以在堆中找到自己需要的数据。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/stack-heap-pointers.png" alt="Stack heap pointers explained"></p><h2 id="内存的使用"><a href="#内存的使用" class="headerlink" title="内存的使用"></a>内存的使用</h2><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p><h2 id="内存的释放"><a href="#内存的释放" class="headerlink" title="内存的释放"></a>内存的释放</h2><p>当内存不再被需要时，JavaScript就会将内存给清掉。高级语言解释器嵌入例如“垃圾回收器”，它的主要工作就是跟踪内存和分配使用，以便当分配的内存不再使用时，自动释放它。当然JavaScript引擎会帮我们完成这些工作，而我们要做的就是不给JS引擎添麻烦，也就是内存泄漏问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript通过堆栈和堆来存储数据，堆栈存放静态数据，堆存放需要动态分配内存的数据，但堆会返回一个引用存放在堆栈当中。内存的使用就是我们日常常见的读写，当内存不再需要时则把它们释放掉，那什么时候这个内存就是不需要的，又有如何判断这个内存是不被需要的，内存泄漏又是怎么发生的，这些内容实在是太多疑惑了，我决定分开来写，我将在下一篇文章继续探讨。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端悬停样式禁用——any-hover的使用</title>
    <link href="/2021/01/08/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%82%AC%E5%81%9C%E6%A0%B7%E5%BC%8F%E7%A6%81%E7%94%A8%E2%80%94%E2%80%94any-hover%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/01/08/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%82%AC%E5%81%9C%E6%A0%B7%E5%BC%8F%E7%A6%81%E7%94%A8%E2%80%94%E2%80%94any-hover%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>在网页开发过程中，面对设计抛来的交互效果我们都会一一实现。其中我觉得，悬停应该是最常见的。我们很多时候都需要鼠标悬停在某个元素上，让它的样式发生细微的变化。要实现这个效果我们就需要用到 <strong>hover</strong> 伪类。然后在里面写需要的样式就可以了。</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">background-color</span>: blue;&#125;</code></pre><p>那么这就完了吗？就没有问题了吗？并不是，因为我们还没有考虑到移动端（即触碰点击设备）。举个例子，如果页面上有个盒子，我们希望悬停时背景色为黄色，同时它也是可以点击的元素。如果我们在 pc 端上操作：悬停—点击—离开，没有问题。那同样的步骤在移动端会发生什么？<strong>悬停样式一直都在（保持激活）</strong>。</p><p><strong>示例代码</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.cube</span> &#123;</span>      width: 100px;      height: 100px;      margin: 0 auto;      background-color: aqua;    &#125;<span class="css">    <span class="hljs-selector-class">.cube</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span>      background-color: yellow;    &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cube&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><strong>pc端</strong></p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/GIF 2021-1-8 19-19-20.gif"/><p><strong>chrome模拟手机端</strong></p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/GIF 2021-1-8 19-25-23.gif"/><p>其实道理想一下很简单，通俗地讲，移动端的屏幕，它没有眼睛，它身上没有鼠标让它感觉用户在页面上哪里移动。它只能通过用户的触碰来判断用户的点击位置，那如果盒子有悬停样式，你点击了，它是不是就会认为，你手指在这上方，所以它判断你手指点击了，并且还悬停在上面（直到你下一次点击）。</p><p>说到底悬停只是鼠标的行为，移动设备根本没办法实现悬停，换句话来说，它们不需要悬停。那我们怎样通过 css 判断该设备是移动设备呢？</p><h2 id="不错的办法——媒体查询中的any-hover"><a href="#不错的办法——媒体查询中的any-hover" class="headerlink" title="不错的办法——媒体查询中的any-hover"></a>不错的办法——媒体查询中的any-hover</h2><p>什么是any-hover? MDN上的描述是：<strong>CSS媒体特性</strong> 可以用来测试是否有任意可用的输入机制可以在元素上hover。简单的来说，它会帮你判断当前设备是否需要hover，是就显示样式，不是就不显示。</p><p>它的值有两个：hover 和 none。</p><p><strong>none</strong>：没有什么输入装置可以实现hover悬停，或者没有可以指向的输入装置。</p><p><strong>hover</strong>：一个或多个输入装置可以触发元素的hover悬停交互。</p><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">any-hover:</span> hover) &#123;  <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;    <span class="hljs-attribute">background-color</span>: yellow;&#125;&#125;</code></pre><p>这样的话就可以满足我们的需求——需要hover的时候hover，不需要就不显示，我们看看兼容情况。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210108153158150.png"></p><p>因为IE是只支持a标签的hover事件，所以除了IE，和低版本的浏览器，兼容情况还可观。</p><h2 id="不太行的办法——屏幕尺寸"><a href="#不太行的办法——屏幕尺寸" class="headerlink" title="不太行的办法——屏幕尺寸"></a>不太行的办法——屏幕尺寸</h2><p>在调研的过程中看到很多人都是通过屏幕尺寸来判断移动设备的，确实，移动设备普遍屏幕较小，用媒体查询通过尺寸条件来设置hover也不是不行。</p><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">1280px</span>) &#123;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">background-color</span>: yellow;&#125;&#125;</code></pre><p>但是呢移动设备也包括平板，市面上也有大屏的平板设备，那么在这个场景下，通过屏幕尺寸判断的话，hover问题还是会触发。我们不能抛弃这一部分用户的用户体验。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210108152739037.png" alt="image-20210108153158150"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以前开发网页的时候确实没有考虑过移动端的hover问题，可能也是没触发所以根本没注意到吧。搜索问题都是一些千篇一律的解决方法，幸好在 MDN 文档找到了这个可靠属性，还是得多看看文档。虽然any-hover的兼容性并不太好，但在实际开发中我们要权衡得失，当然有兼容性更好的做法，但是在这上面付出的时间、开发成本，是否有意义，我们得好好考虑。</p>]]></content>
    
    
    <categories>
      
      <category>Problem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Echarts的常用属性</title>
    <link href="/2021/01/05/Echarts%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/01/05/Echarts%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>Echarts是一个功能非常强大的图表插件，能将数据转化成各种图表然后展示在页面上。而且配置的属性非常的齐全，可以说自由度非常高。也同样因为配置属性齐全而让刚接触的我感到这东西很难搞。但其实只要了解几个主要属性就可以做出简单的图表来。</p><p>要渲染一个图表首先我们需要一个对象数据类型，然后setOption函数会将我们对象中的属性解析成图表上的元素并绘制出来。下面我就讲讲几个常用的属性。</p><p>用一个简单的表格来说明一下各个属性</p><p><strong>语法</strong>：</p><pre><code class="hljs js">option = &#123;  title: &#123;    text: <span class="hljs-string">&#x27;这是标题&#x27;</span>,    subtext: <span class="hljs-string">&#x27;这是副标题&#x27;</span>  &#125;,  legend: &#123;    data: [<span class="hljs-string">&#x27;折线一&#x27;</span>, <span class="hljs-string">&#x27;折线二&#x27;</span>]  &#125;,  tooltip: &#123;    trigger: <span class="hljs-string">&#x27;axis&#x27;</span>,    axisPointer: &#123;      type: <span class="hljs-string">&#x27;cross&#x27;</span>  &#125;  &#125;,  grid: &#123;left: <span class="hljs-string">&#x27;3%&#x27;</span>,    right: <span class="hljs-string">&#x27;4%&#x27;</span>,    bottom: <span class="hljs-string">&#x27;3%&#x27;</span>,    containLabel: <span class="hljs-literal">true</span>  &#125;,  xAxis: &#123;    type: <span class="hljs-string">&#x27;category&#x27;</span>,    data: [<span class="hljs-string">&#x27;周一&#x27;</span>, <span class="hljs-string">&#x27;周二&#x27;</span>, <span class="hljs-string">&#x27;周三&#x27;</span>, <span class="hljs-string">&#x27;周四&#x27;</span>, <span class="hljs-string">&#x27;周五&#x27;</span>, <span class="hljs-string">&#x27;周六&#x27;</span>, <span class="hljs-string">&#x27;周日&#x27;</span>]  &#125;,  yAxis: &#123;    type: <span class="hljs-string">&#x27;value&#x27;</span>  &#125;,  series: [    &#123;      name: <span class="hljs-string">&#x27;折线一&#x27;</span>,      type: <span class="hljs-string">&#x27;line&#x27;</span>,      data: [<span class="hljs-number">120</span>, <span class="hljs-number">132</span>, <span class="hljs-number">101</span>, <span class="hljs-number">134</span>, <span class="hljs-number">90</span>, <span class="hljs-number">230</span>, <span class="hljs-number">210</span>]    &#125;,    &#123;      name: <span class="hljs-string">&#x27;折线二&#x27;</span>,      type: <span class="hljs-string">&#x27;line&#x27;</span>,      data: [<span class="hljs-number">220</span>, <span class="hljs-number">182</span>, <span class="hljs-number">191</span>, <span class="hljs-number">234</span>, <span class="hljs-number">290</span>, <span class="hljs-number">330</span>, <span class="hljs-number">310</span>]     &#125;  ]&#125;</code></pre><p>效果图</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20210104174121585.png" alt="image-20210104174121585"></p><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>图表的标题</p><p><strong>title.text</strong>: 标题的内容</p><p><strong>title.subtext</strong>: 副标题内容</p><h2 id="legend"><a href="#legend" class="headerlink" title="legend"></a>legend</h2><p>图例组件，就是一个图标，点选可以显示隐藏线</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20201225115542561.png" alt="image-20201225114256100"></p><p>legend.data: 图例的数据，里面的数据要与series(下面会讲)的name属性一一对应，才能显示出来</p><h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><p>图表的坐标轴，控制它的位置以及一些显示</p><p><strong>grid.top || left || bottom || right</strong>: 控制图表坐标轴与容器的偏移量</p><p><strong>containLabel</strong>: grid 区域是否包含坐标轴的刻度标签，这常用于<strong>防止标签溢出</strong>的场景</p><h2 id="xAxis"><a href="#xAxis" class="headerlink" title="xAxis"></a>xAxis</h2><p>x轴、横轴</p><p>xAxis.type: 常用的两个值：<strong>value，category</strong>。category是x轴作为数据的标明，要设置data，value是x轴作为展示的刻度，刻度依赖series中data的值。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20201225115643719.png" alt="image-20201225115542561"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20201225141335276.png" alt="image-20201225115643719"></p><h2 id="yAxis"><a href="#yAxis" class="headerlink" title="yAxis"></a>yAxis</h2><p>y轴、纵轴</p><p>yAxis.type: 与xAxis一样。但它们是互斥的，一般x轴category，y轴就value、x轴value，y轴就category。</p><h2 id="tooltip"><a href="#tooltip" class="headerlink" title="tooltip"></a>tooltip</h2><p>提示框组件</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20201225141634780.png" alt="image-20201225141634780"></p><p><strong>trigger</strong>: 触发类型，常用axis坐标轴触发</p><p><strong>axisPointer</strong>: 指示器的配置，可设置类型type, 以及一些样式等等。</p><h2 id="series"><a href="#series" class="headerlink" title="series"></a>series</h2><p>最关键的属性，控制图表数据的绘制。series是个数组，数组长度决定会绘制几种数据（长度3就画三条线）</p><p><strong>type</strong>: 图表类型，line是折线图，bar是柱状图，其他的查阅官网</p><p><strong>data</strong>: 图表的数据，也就是线的数据</p><h3 id="line中的一些属性"><a href="#line中的一些属性" class="headerlink" title="line中的一些属性"></a>line中的一些属性</h3><p><strong>symbol</strong>: 控制折线点样式</p><p><strong>areaStyle</strong>: 折线图区域内样式</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/image-20201225114256100.png" alt="image-20201225141335276"></p><p><strong>itemStyle</strong>: 折线的样式</p><h3 id="bar中的一些属性"><a href="#bar中的一些属性" class="headerlink" title="bar中的一些属性"></a>bar中的一些属性</h3><p><strong>barCategoryGap</strong>: 同一系列的柱间距离，默认20%</p><p><strong>itemStyle</strong>: 柱子的样式</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为不同类型的图表，属性各有不同，我就不一一解释了。但是用以上的属性就可以做出简单的折线图或曲线图。如果有其他的需求，还是要翻阅官方文档，按需求根据配置项设计图表。</p><p>（以上图片均来源于echarts官网）</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Echarts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue—理解响应式的初步尝试</title>
    <link href="/2020/12/28/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <url>/2020/12/28/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在实习做项目，用vue来开发。很多时候遇到一些响应式的问题，为了在遇到问题时更好的分析问题，我开始上vue官网去翻文档，刚好在Vue Mastery看到一个教学视频，里面非常通俗易懂的讲解了vue的响应式原理，顿时茅塞顿开，写个博客记录一下。</p><h2 id="什么是响应式？"><a href="#什么是响应式？" class="headerlink" title="什么是响应式？"></a>什么是响应式？</h2><p>根据Vue官网的说法，响应式是Vue最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接。</p><h2 id="为什么要响应式？"><a href="#为什么要响应式？" class="headerlink" title="为什么要响应式？"></a>为什么要响应式？</h2><p>在传统的开发模式里，我们如果想修改页面上的某个数据，需要繁琐的操作——请求数据、获取数据、获取dom元素、修改dom元素、更新视图，而且数据的更新也要自己手动重新赋值。看代码</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> price = <span class="hljs-number">10</span><span class="hljs-keyword">let</span> count = <span class="hljs-number">2</span><span class="hljs-keyword">let</span> total = price * count</code></pre><p>我们用node来运行js文件，改变price的值，看看total是否跟着改变。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201216163045.png"></p><p>我们可以看到即使改变了price的值，total并没有发生改变。因为我们只对total进行了一次赋值。</p><p>现在我们希望有个函数，能够在数据发生变化时，重新执行赋值。Vue的响应式就是实现这一点，它通过将数据与其有关系的元素产生依赖，在数据发生改变时，同时影响所有依赖该数据的其他元素。</p><h2 id="怎么实现响应式？"><a href="#怎么实现响应式？" class="headerlink" title="怎么实现响应式？"></a>怎么实现响应式？</h2><p>Vue实现响应式主要有两点，一是<strong>Object.defineProperty</strong>，二是<strong>发布订阅者模式</strong>。将两者结合起来就是我们想要的响应式。下面我根据我所学的内容打个简单版的响应式。</p><p>首先我们初始化数据，建立一个观察者watcher，用来观察我们的数据，vue中的watcher很复杂，我们现在只是想实现响应式，所以先不纠结watcher的写法，我们用简单的方式实现它。</p><pre><code class="hljs fortran">let <span class="hljs-keyword">data</span> = &#123; price: <span class="hljs-number">10</span>, <span class="hljs-built_in">count</span>: <span class="hljs-number">2</span> &#125;let <span class="hljs-keyword">target</span>, total, salePrice<span class="hljs-function"><span class="hljs-keyword">function</span></span> watcher(myFun) &#123;<span class="hljs-keyword">target</span> = myFun<span class="hljs-keyword">target</span>()<span class="hljs-keyword">target</span> = null&#125;</code></pre><p>然后我们需要一个类，它叫<strong>Dep</strong>，它是用来记录数据的依赖以及响应数据的修改。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-built_in">this</span>.subscriber = [] <span class="hljs-comment">// 依赖仓库</span>  &#125;  <span class="hljs-function"><span class="hljs-title">depend</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 存储相关依赖</span>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">target &amp;&amp; !<span class="hljs-built_in">this</span>.subscriber.includes(target)</span>)</span> &#123;      <span class="hljs-built_in">this</span>.subscriber.push(target)    &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 响应相关依赖</span>    <span class="hljs-built_in">this</span>.subscriber.forEach(<span class="hljs-function"><span class="hljs-params">run</span> =&gt;</span> run()) <span class="hljs-comment">// 执行每一个函数</span>  &#125;&#125;</code></pre><p>我们用<strong>dep.depend()来记录数据的依赖</strong>，当数据发生改变时，我们执行<strong>dep.notify()，执行subscriber仓库中的所有依赖</strong>，这样所有与依赖数据有关的元素都会得到更新。</p><p>接着我们用Object.defineProperty将Dep中的方法绑定在get、set方法中，达到这样的需求——当获取到数据时，就能执行dep.depend()来收集依赖，当数据赋值时，就能执行dep.notify()执行所有的依赖。</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>)=&gt;</span>&#123;  <span class="hljs-keyword">let</span> interValue = data[key]  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()  <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;    get () &#123;      dep.depend() <span class="hljs-comment">// 记录依赖当前数据的函数</span>      <span class="hljs-keyword">return</span> interValue    &#125;,    set (val) &#123;      interValue = val      dep.notify() <span class="hljs-comment">// 重新执行那些函数</span>    &#125;  &#125;)&#125;)</code></pre><p>接着，用watcher观察数据，然后运行程序看一下是否是响应式的。</p><pre><code class="hljs js">watcher(<span class="hljs-function">()=&gt;</span>&#123; total = data.price * data.count &#125;)watcher(<span class="hljs-function">()=&gt;</span>&#123; salePrice = data.price * <span class="hljs-number">0.9</span> &#125;)</code></pre><p>运行node .load fileName.js</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201216170139.png"></p><p>我们可以看到，当我们改变price的值为20时，我们不需要手动的去执行赋值函数，代码自动的就帮我们更新代码，这就是数据响应式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是在理解Vue路上的一次小尝试，而Vue3.0将使用proxy来实现响应式（为了能监听到对象的增删，数组的变化），所以可能这个就会是过去式的东西的，但是现在学会这些，是为了以后更好的理解新东西。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementUI中的Pagination分页器页码不对</title>
    <link href="/2020/12/28/ElementUI%E4%B8%AD%E7%9A%84Pagination%E5%88%86%E9%A1%B5%E5%99%A8%E9%A1%B5%E7%A0%81%E4%B8%8D%E5%AF%B9/"/>
    <url>/2020/12/28/ElementUI%E4%B8%AD%E7%9A%84Pagination%E5%88%86%E9%A1%B5%E5%99%A8%E9%A1%B5%E7%A0%81%E4%B8%8D%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>简述：<strong>浏览器回退到上一个页面，页码对不上</strong></p><p>当我们在某一页，通过筛选条件使数据重新获取，分页器重新获取数据（当前页重置为1，total值减少了）。但是如果通过浏览器回退事件回到上一页（上一页的页码大于目前的总页数），数据没错，但是页码不是当前的页码。</p><p>如图所示</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201210110232.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201210110332.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201210110523.png"></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>简述：<strong>当前页比总页数先更新，回退的当前页大于当前总页数，Pagination自动对数据进行处理</strong></p><p>以下属性在下面经常提到，说说它们的作用</p><ul><li><p><strong>interCurrentPage</strong>：分页器内部控制当前页的属性，当前页的显示依赖它</p></li><li><p><strong>pageCount</strong>：分页器内部的总页数</p></li><li><p><strong>currentPage</strong>：外部传当前页值给el-pagination的属性</p></li></ul><p>通过vue的devtools我们可以发现，传给Pagination的值没有错，但是内部的interCurrentPage出错了。意思是说我们已经把值传给了组件，但是由于某些原因，组件内部的interCurrentPage的值不对。原因是，浏览器回退时，<strong>currentPage的值传给了Pagination，但此时Pagination的pageCount（总页数）还未改变，这个值大于Pagination的总页数，Pagination组件将它判断为错误值，于是组件自动帮你处理数据，将interCurrentPage设置为页数最大值。</strong>如果你还进行了.sync双向绑定，还会导致interCurrentPage的值反向赋给你绑定的值currentPage。而改变完了interCurrentPage值，它才去更新pageCount…。就是这样的一个先后关系——<strong>先更新interCurrentPage再更新pageCount</strong>，导致了我们的页码错误。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201210110801.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201210110912.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>简述：<strong>需要时重新渲染组件</strong></p><p>我无法去手动修改内部封装好的参数，既然它的这种更新顺序是定好的，那我们只能重新渲染组件，来达到我们的目的。首先我们创建一个变量存储总页数pageCount</p><pre><code class="hljs javascript">data () &#123;    <span class="hljs-keyword">return</span> &#123;        pageCount: <span class="hljs-number">0</span>,        refresh: <span class="hljs-literal">true</span> <span class="hljs-comment">// 控制重新渲染</span>    &#125;&#125;</code></pre><p>通过接口获取pageCount的值，并用watch监听它的变化，但数据更新时，如果总页数发生了改变，我们就设置refresh的值重新渲染分页组件。</p><pre><code class="hljs javascript">watch: &#123;    pageCount () &#123;        <span class="hljs-built_in">this</span>.refresh = <span class="hljs-literal">false</span>        <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">this</span>.refresh = <span class="hljs-literal">true</span>        &#125;)    &#125;&#125;</code></pre><p>组件上v-if绑定refresh实现重新渲染。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-pagination</span></span><span class="hljs-tag">  <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;refresh&quot;</span></span><span class="hljs-tag">  @<span class="hljs-attr">current-change</span>=<span class="hljs-string">&quot;currentChange&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;prev, pager, next&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">:page-size</span>=<span class="hljs-string">&quot;pageSize&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">:current-page</span>=<span class="hljs-string">&quot;currentPage&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">:total</span>=<span class="hljs-string">&quot;total&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span></code></pre><p>最后效果就是没问题</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201210113908.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201210114018.png"></p><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>刚开始也用了其他的方法，看看能不能除了重新渲染解决这个问题。网上都说加.sync但依然没有用，用watch监听currentPage的值，也是外部同步了，内部没有，就很奇怪，为什么值没有传进去。于是上github上看了源码，捋了一下发现其实值传进去了，但是被处理了。同时也注意到总页数是computed属性，当前页是watch监听的，也不知道是不是这两者的区别导致了更新的前后关系。最后还是按重新渲染的思路写了一下（期间用过forceUpdate，好像没起效？）所以组件直接用很方便，不过有时候不能达到自己的需求。</p>]]></content>
    
    
    <categories>
      
      <category>Problem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>elementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿猫的博客踩坑</title>
    <link href="/2020/12/18/%E9%98%BF%E7%8C%AB%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/"/>
    <url>/2020/12/18/%E9%98%BF%E7%8C%AB%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="阿猫的博客踩坑"><a href="#阿猫的博客踩坑" class="headerlink" title="阿猫的博客踩坑"></a>阿猫的博客踩坑</h1><h2 id="CNAME文件"><a href="#CNAME文件" class="headerlink" title="CNAME文件"></a>CNAME文件</h2><p>为了让github能记住我们的域名，我们要在setting中将我们的域名save在<strong>GitHub Pages</strong>的<strong>custom domain</strong>中。这实际上在本地的public文件夹中创建了一个<strong>CNAME文件</strong>。但是我们使用hexo上传文章都要清一次缓存，将pubilc文件删除，再新建，这时候CNAME文件就没了（再到Setting里设置一次）。</p><p>为了解决这个问题，我们在source文件夹中创建一个CNAME文件<strong>（就叫CNAME，不要加任何后缀！）</strong>里面放我们的域名，这样，每次更新的时候，也能保存我们的域名。</p><h2 id="Hexo的双大括号"><a href="#Hexo的双大括号" class="headerlink" title="Hexo的双大括号"></a>Hexo的双大括号</h2><p>一次提交文件，发现Vue笔记一直提交不上去，报“Nunjucks Error”的错误。百度了一下，发现原因。</p><p>因为hexo的文章是使用Nunjucks渲染的，它会将大括号识别为自己的语法。然后我写的笔记中有一些模板语法，所以就报错了。解决方法是在报错地方的前后加不编译(在代码块里）。不过我更直接，把模板语法放进了代码块。</p><pre><code class="hljs html">不编译：&#123;% raw %&#125;&#123;% endraw %&#125;&#123;&#123;&#125;&#125;</code></pre><h2 id="typora的图片上传失败"><a href="#typora的图片上传失败" class="headerlink" title="typora的图片上传失败"></a>typora的图片上传失败</h2><p>一次，我上传图片时，发现老是上传失败。报fail fetch的错误。做不到原因，明明前一秒还可以，这会就不行了。原因是：<strong>typora上传图片的端口跟图床picgo监听的端口不一致</strong>导致的，picgo也是莫名其妙给我换了个端口号，只要把他们改为一致的就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>Problem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>typora</tag>
      
      <tag>picgo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vuex笔记</title>
    <link href="/2020/12/18/vuex/"/>
    <url>/2020/12/18/vuex/</url>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><strong>vuex</strong></h1><h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a><strong>Vuex是什么？</strong></h2><p>Vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间数据的共享。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/da08cd1c9962d7bbf9c57e7b6d382946.png"></p><p>传统的组件传值，通过父子间的传值，一步步回退，十分麻烦。而vuex将共享的数据存储到store中，需要用到共享数据的组件直接从store中获取。</p><h2 id="使用vuex统一管理状态的好处"><a href="#使用vuex统一管理状态的好处" class="headerlink" title="使用vuex统一管理状态的好处"></a><strong>使用vuex统一管理状态的好处</strong></h2><ol><li><p> 能够在vuex中集中管理共享的数据，易于开发和后期维护</p></li><li><p> 能够高效地实现组件之间地数据共享，提高开发效率</p></li><li><p> 存储在vuex中的数据都是响应式的，能够实时保持数据与页面的同步</p></li></ol><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a><strong>安装使用</strong></h2><ol><li><p>安装vuex依赖包</p><p>npm install vuex –save</p></li><li><p>导入vuex包</p></li></ol><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>Vue.use(Vuex)</code></pre><ol><li> 创建store对象</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<span class="hljs-comment">// state中存放的就是全局共享的数据</span>state: &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;&#125;)</code></pre><ol start="2"><li>将store对象挂载到vue实例中</li></ol><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue (&#123;el: <span class="hljs-string">&#x27;#app&#x27;</span>,render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(app),router,<span class="hljs-comment">// 将创建的共享数据对象，挂载到vue实例中</span><span class="hljs-comment">// 所有的组件，就可以直接从store中获取全局的数据了</span>store&#125;)</code></pre><h2 id="State"><a href="#State" class="headerlink" title="State"></a><strong>State</strong></h2><p><strong>state</strong>提供唯一的公共数据源，所有共享的数据都要统一放到<strong>store</strong>的<strong>state</strong>中进行存储。</p><p><strong>获取state中的数据</strong></p><p>方法一：</p><p><strong>this.$store.state.全局数据名称</strong></p><p>方法二：</p><pre><code class="hljs js"><span class="hljs-comment">// 1. 从vuex中按需导入 mapstate 函数</span><span class="hljs-keyword">import</span> &#123; mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></code></pre><p>通过刚才导入的<strong>mapState</strong>函数，将当前组件需要的全局数据，映射为当前组件的<strong>computed</strong>计算属性：</p><pre><code class="hljs js"><span class="hljs-comment">// 2. 将全局数据， 映射为当前组件的计算属性</span>computed: &#123;...mapState([<span class="hljs-string">&#x27;count&#x27;</span>])&#125;</code></pre><p><strong>两种方法都可以获取state中的数据，各有各的不同，按自己实际开发需求来使用</strong></p><h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a><strong>Mutations</strong></h2><p>mutations用于变更store中的数据</p><p>建议通过mutations变更store数据，<strong>不要直接操作store中的数据</strong>。虽然通过mutations的这种方式操作起来稍微繁琐了一些，但是<strong>可以集中监控所有数据的变化</strong></p><pre><code class="hljs js"><span class="hljs-comment">// 定义Mutation</span><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store( &#123;state: &#123;count: <span class="hljs-number">0</span>&#125;,mutations: &#123;<span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">state</span>)</span> &#123;<span class="hljs-comment">// 变更状态</span>state.count++&#125;&#125;&#125;)------------------------------------------------<span class="hljs-comment">// 触发mutation</span>methods: &#123;<span class="hljs-function"><span class="hljs-title">handle1</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">//触发mutations的第一种方式</span><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;add&#x27;</span>)  &#125;&#125;</code></pre><p><strong>可以在触发mutations时传递参数</strong></p><pre><code class="hljs js"><span class="hljs-comment">//定义Mutation</span><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> vuex.store ( &#123;state: &#123;count: <span class="hljs-number">0</span>&#125;,mutations: &#123;addN (state, step) &#123;<span class="hljs-comment">//变更状态</span>state.count += step    &#125;  &#125;&#125;)---------------------------------<span class="hljs-comment">// 触发mutation</span>methods: &#123;  <span class="hljs-function"><span class="hljs-title">handle2</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// 在调用commit函数，</span><span class="hljs-comment">// 触发 mutations 时携带参数</span><span class="hljs-built_in">this</span>.$store.commit ( <span class="hljs-string">&#x27;addN&#x27;</span>,<span class="hljs-number">3</span>)  &#125;&#125;</code></pre><p>**this.$store.commit()**是触发mutations的第一种方式，触发mutations的第二种方式：</p><pre><code class="hljs js"><span class="hljs-comment">// 1.从vuex中按需导入mapMutations函数</span><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></code></pre><p>通过刚才导入的mapMutations函数，将需要的mutations函数，映射为当前组件的methods方法：</p><pre><code class="hljs js"><span class="hljs-comment">// 2. 将指定的 mutations 函数， 映射为当前组件的 methods 函数</span>methods: &#123;  ...mapMutations([<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;addN&#x27;</span>])&#125;</code></pre><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a><strong>Actions</strong></h2><p>Actions<strong>用于处理异步任务</strong></p><p>如果在mutations中执行异步任务，那么vue的调试器会监听不到数据的变化。不利于我们对数据的调试</p><p>故通过actions来解决这个问题，不过actions还是通过触发mutations的方式来间接变更数据</p><p>触发actions用<strong>this.$store.dispatch()</strong></p><pre><code class="hljs js"><span class="hljs-comment">// 定义Action</span><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store (&#123;<span class="hljs-comment">// ...省略其他代码</span>mutations: &#123;add (state) &#123;state.count++&#125;&#125;,actions:&#123;<span class="hljs-function"><span class="hljs-title">addAsync</span>(<span class="hljs-params">context</span>)</span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;context.commit(<span class="hljs-string">&#x27;add&#x27;</span>)&#125;, <span class="hljs-number">1000</span>)  &#125;&#125;&#125;)<span class="hljs-comment">// 触发Action</span>methods: &#123;  <span class="hljs-function"><span class="hljs-title">handle</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">//触发actions的第一种方式</span>    <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;addAsync&#x27;</span>)  &#125;&#125;</code></pre><p>context相当于创建的Vuex.store对象，所以通过commit获取方法</p><p>触发actions异步任务时携带参数</p><pre><code class="hljs js"><span class="hljs-comment">//定义Action</span><span class="hljs-keyword">const</span> store =<span class="hljs-keyword">new</span> Vuex.Store(&#123;<span class="hljs-comment">// ...省略其他代码</span>mutations: &#123;<span class="hljs-function"><span class="hljs-title">addN</span>(<span class="hljs-params">state, step</span>)</span> &#123;state.count += step&#125;&#125;,actions: &#123;<span class="hljs-function"><span class="hljs-title">addNAsync</span>(<span class="hljs-params">context, step</span>)</span>&#123;<span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">()=&gt;</span>&#123;context.commit ( <span class="hljs-string">&#x27;addN&#x27;</span>, step)&#125;, <span class="hljs-number">1000</span>)  &#125;&#125;&#125;)-------------------------------------------<span class="hljs-comment">// 触发Action</span>methods: &#123;  <span class="hljs-function"><span class="hljs-title">handle</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">//在调用dispatch函数，</span>    <span class="hljs-comment">//触发actions时携带参数</span>    <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;addNsync&#x27;</span>, <span class="hljs-number">5</span>)&#125;&#125;</code></pre><p>触发actions的第二张方式：</p><pre><code class="hljs js"><span class="hljs-comment">// 1. 从vuex中按需导入 mapActions 函数</span><span class="hljs-keyword">import</span> &#123; mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></code></pre><p>通过刚才导入的mapActions函数，将需要的actions函数，映射为当前组件的methods方法：</p><pre><code class="hljs js"><span class="hljs-comment">// 2. 将指定的 actions 函数， 映射为当前组件的 methods 函数</span>methods: &#123;  ...mapActions([<span class="hljs-string">&#x27;addAsync&#x27;</span>, <span class="hljs-string">&#x27;addNASync&#x27;</span>])&#125;</code></pre><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a><strong>Getter</strong></h2><p>getters用于对store中的数据进行加工处理形成新的数据</p><ol><li><p> getters可以对Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性。</p></li><li><p> Store中数据发生变化，getters的数据也会跟着变化</p></li></ol><pre><code class="hljs js"><span class="hljs-comment">// 定义Getter</span><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;state: &#123;count: <span class="hljs-number">0</span>&#125;,getters: &#123;showNum: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;当前最新的数量是【&#x27;</span>+ state.count +<span class="hljs-string">&#x27;】&#x27;</span>    &#125;  &#125;&#125;)</code></pre><p>使用getters的第一种方式：<strong>this.$store.getters.名称</strong></p><p>使用getters的第二种方式</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>---------------------------------------------computed: &#123;...mapGetters ([<span class="hljs-string">&#x27;showNum&#x27;</span>])&#125;</code></pre><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a><strong>Module</strong></h2><p>在项目开发的过程中，随着项目的逐渐扩大，数据关联复杂度逐渐加大，vuex在数据更新时可能会遇到同名/未预测到的关联数据的变化，为了让各个功能模块的数据能够好好的区分，就用到modules</p><p>modules下面存放一个store对象，通过对象名访问某个模块中的数据，实现多个模块数据的分隔。</p><p>获取方法：<strong>this.$store.state.模块名.属性名</strong></p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue笔记</title>
    <link href="/2020/12/18/Vue/"/>
    <url>/2020/12/18/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a><strong>Vue</strong></h1><h2 id="Vue模板语法"><a href="#Vue模板语法" class="headerlink" title="Vue模板语法"></a><strong>Vue模板语法</strong></h2><h3 id="差值表达式"><a href="#差值表达式" class="headerlink" title="差值表达式"></a><strong>差值表达式</strong></h3><p><strong>双大括号</strong>里面填充数据</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a><strong>指令</strong></h3><p>指令的本质就是自定义属性，指令的格式：以v-开始（比如：v-cloak）</p><h4 id="v-cloak指令用法"><a href="#v-cloak指令用法" class="headerlink" title="v-cloak指令用法"></a><strong>v-cloak指令用法</strong></h4><p>插值表达式存在的问题：“闪动”（显示双大括号内容）</p><p>方法：使用v-cloak指令</p><p>解决该问题原理：先隐藏，在内存中替换好值之后再显示最终的值</p><h4 id="数据绑定指令"><a href="#数据绑定指令" class="headerlink" title="数据绑定指令"></a><strong>数据绑定指令</strong></h4><p><strong>v-text填充纯文本</strong></p><p>语法：&lt;span v-text=”msg”&gt;&lt;/span&gt; = &lt;span&gt;msg&lt;/span&gt;</p><p>没有闪动问题</p><p>相比于插值表达式更加简洁</p><p><strong>v-html填充html片段</strong></p><p>语法：&lt;span v-html=”msg”&gt;&lt;/span&gt;</p><p>存在安全问题，容易受到XSS攻击，<strong>不要用在用户提交内容上</strong></p><p>本网站内部数据可以使用，来自第三方的数据不可以用</p><p><strong>v-pre填充原始信息</strong></p><p>显示原始信息，跳过编译过程（分析编译过程）</p><h2 id="数据响应式"><a href="#数据响应式" class="headerlink" title="数据响应式"></a><strong>数据响应式</strong></h2><p>理解响应式：</p><ol><li><p> html5中的响应式（屏幕尺寸的变化导致样式的变化）</p></li><li><p> 数据的响应式（数据的变化导致页面内容的变化）</p></li></ol><p>什么是数据绑定</p><p>数据绑定：将数据填充到标签中</p><p>v-once只编译一次</p><p>显示内容之后不再具有响应式功能</p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a><strong>双向数据绑定</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><ol><li><p> 当数据发生变化的时候，视图也就发生变化</p></li><li><p> 当视图发生变化的时候，数据也会跟着同步变化</p></li></ol><p><strong>实现方法</strong>：<strong>v-model</strong></p><p>语法：&lt;input type=’text’ v-model=’uname’/&gt;</p><p><strong>使用场景</strong>：v-model是一个指令，限制在<br><strong>&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;**、</strong>components（组件）** 中使用</p><h2 id="MVVM设计思想"><a href="#MVVM设计思想" class="headerlink" title="MVVM设计思想"></a><strong>MVVM设计思想</strong></h2><ol><li> M（model）数据层</li></ol><p>Vue 中 数据层 都放在 data 里面</p><ol start="2"><li>V（view）视图</li></ol><p>Vue 中 view 即 我们的HTML页面</p><ol start="3"><li>VM（View-Model）控制器 将数据和视图层建立联系</li></ol><p>vm 即 Vue 的实例 就是 vm</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/56a457505411b792673bdad131664539.png"></p><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a><strong>事件绑定</strong></h2><ol><li> <strong>如何处理函数</strong></li></ol><p>v-on指令：通过<strong>v-on</strong>指令来绑定事件</p><p>语法：&lt;input type=‘button’<br>v-on:click=’num++’/&gt;v-on简写形式：用**@**来代替v-on</p><p>语法：&lt;input type=‘button’ @click=’num++’/&gt;</p><ol start="2"><li><strong>事件函数的调用方式</strong></li></ol><ul><li>直接绑定函数名称</li></ul><p>语法：&lt;button v-on:click=’say’&gt;Hello&lt;/button&gt;</p><ul><li>调用函数（传参的时候用）</li></ul><p>语法：&lt;button v-on:click=’say()’&gt;Say hi&lt;/button&gt;</p><ol start="3"><li><strong>事件函数参数传递</strong></li></ol><p>普通函数和事件对象</p><p>&lt;button v-on:click=’say(“hi”,$event)’&gt;Say hi&lt;/button&gt;</p><p>$event：传递事件对象</p><p><strong>注意：</strong></p><ol><li><p> 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数</p></li><li><p> 如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，并且事件对象的名称必须事$event</p></li></ol><p><strong>事件修饰符</strong></p><ul><li>  <strong>.stop</strong>阻止冒泡</li></ul><p>语法：&lt;a v-on:click.stop=”handle”&gt;跳转&lt;/a&gt;</p><ul><li>  <strong>.prevent</strong>阻止默认行为</li></ul><p>语法：&lt;a v-on:click.prevent=”handle”&gt;跳转&lt;/a&gt;</p><p><strong>注意：</strong>事件修饰符可以串联使用，而它的顺序很重要，不同的顺序可能有不同的效果</p><p><strong>按键修饰符</strong></p><ul><li>  <strong>.enter</strong> 回车键，当按了回车键，触发事件</li></ul><p>语法：&lt;input v-on:keyup.enter=’submit’&gt;</p><ul><li>  <strong>.esc</strong> 退出键，当按了删除或退格键，触发事件</li></ul><p>语法：&lt;input v-on:keyup.delete=’handle’&gt;</p><p><strong>自定义按键修饰符</strong></p><p>全局config.keyCodes对象</p><p>语法：Vue.config.keyCodes.按键名 = 键值</p><h2 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a><strong>属性绑定</strong></h2><ol><li> <strong>如何处理动态处理属性</strong></li></ol><ul><li>  v-bind指令用法</li></ul><p>语法：&lt;a v-bind:href=’url’&gt;跳转&lt;/a&gt;</p><ul><li>  缩写形式 用 <strong>:</strong> 来代替<strong>v-bind</strong></li></ul><p>语法：&lt;a :href=’url’&gt;跳转&lt;/a&gt;</p><ol start="2"><li><strong>v-model的底层实现原理分析</strong></li></ol><p>&lt;input v-bind:value=”msg” v-on:input=”msg=$event.target.value”&gt;</p><p>oninput: 用户输入时触发事件</p><h2 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a><strong>样式绑定</strong></h2><ol><li> <strong>class样式处理</strong></li></ol><p><strong>对象语法</strong> 通过布尔值来控制具体类是否添加</p><p>语法：&lt;div v-bind:class=”{ active: isActive }”&gt;&lt;/div&gt;</p><p><strong>数组语法</strong> 在Vue实例将类名对应data中的属性，然后将属性名添加到标签中</p><p>语法：&lt;div v-bind:class=”[activeClass, errorClass]”&gt;&lt;/div&gt;</p><p><strong>注意：</strong></p><ul><li><p>对象绑定和数值绑定可以结合使用 例：[ activeClass, { test: istest } ]</p></li><li><p>class绑定的值可以简化操作<br>将数值赋值为data中的属性，通过数值方法就可以对类进行修改</p></li><li><p>默认的class会保留，绑定的class会加到后面</p></li></ul><ol start="2"><li><strong>style样式处理</strong></li></ol><p><strong>对象语法</strong> 在data中将样式字符串赋给属性名，再将属性名绑定到相应的样式属性中</p><p>语法：&lt;div v-bind:style=”{ color: activeColor, fontSize: fontSize }”&gt;&lt;/div&gt;</p><p>activeColor: ‘blue’</p><p><strong>数组语法</strong> 在data中编写好样式代码并赋予属性名，然后传到标签中</p><p>语法：&lt;div v-bind:style=”[baseStyles, overridingStyles]”&gt;&lt;/div&gt;</p><p>baseStyles:{</p><p>​    width:’200px’,</p><p>​    backgroundColor:’blue’// -符号去掉，用驼峰法命名</p><p>}</p><h2 id="分支循环结构"><a href="#分支循环结构" class="headerlink" title="分支循环结构"></a><strong>分支循环结构</strong></h2><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a><strong>分支结构</strong></h3><ul><li><p>  v-if</p></li><li><p>  v-else</p></li><li><p>  v-else-if</p></li><li><p>  v-show</p></li></ul><h3 id="v-if与v-show的区别"><a href="#v-if与v-show的区别" class="headerlink" title="v-if与v-show的区别"></a><strong>v-if与v-show的区别</strong></h3><ul><li><p>  v-if控制元素是否渲染到页面</p></li><li><p>  v-show控制元素是否显示（已经渲染到了页面）</p></li></ul><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a><strong>循环结构</strong></h3><ul><li>  v-for遍历数组</li></ul><p>语法：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;item in list&#x27;</span>&gt;</span>&#123;&#123;item&#125;&#125;\<span class="hljs-tag">&lt;/<span class="hljs-name">li\</span>&gt;</span> <span class="hljs-comment">&lt;!-- 遍历元素--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;(item,index) in list&#x27;</span>&gt;</span>&#123;&#123;item&#125;&#125; + &#x27;---&#x27; +&#123;&#123;index&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-comment">&lt;!--遍历元素和索引--&gt;</span></code></pre><ul><li>  <strong>key的作用：帮助Vue区分不同的元素，从而提高性能</strong></li></ul><p>语法：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;item.id&#x27;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;(item,index) in list&#x27;</span>&gt;</span>&#123;&#123;item&#125;&#125; + &#x27;---&#x27;&#123;&#123;index&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre><ul><li>  v-for遍历对象</li></ul><p>语法：&lt;div v-for=’(value, key, index) in object’&gt;&lt;/div&gt;</p><p><strong>value：属性值</strong>  <strong>key：属性名</strong>  <strong>index：索引</strong></p><ul><li>  v-if和v-for结合使用</li></ul><p>语法：&lt;div v-if=’value==12’ v-for=’(value, key, index) in object’&gt;&lt;/div&gt;</p><h2 id="Vue常用特性"><a href="#Vue常用特性" class="headerlink" title="Vue常用特性"></a><strong>Vue常用特性</strong></h2><h3 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a><strong>表单操作</strong></h3><p><strong>通过v-model来实现，不同的表单元素，有不同的效果。input、textarea通过v-model来绑定其内容文本，而单选框、复选框、下拉框通过v-model来绑定其选中状态（通过元素属性value是否与v-model绑定的数据相等来判断）</strong></p><p><strong>单选框如何实现单选？</strong></p><p>1、 两个单选框需要同时通过v-model 双向绑定 一个值</p><p>2、 每一个单选框必须要有value属性 且value 值不能一样</p><p>3、 当某一个单选框选中的时候 v-model 会将当前的 value值 改变 data 中的 数据</p><p><strong>复选框如何实现复选？</strong></p><p>1、 复选框需要同时通过v-model 双向绑定 一个值 <strong>一个数组</strong></p><p>2、 每一个复选框必须要有value属性 且value 值不能一样</p><p>3、 当某一个单选框选中的时候 v-model 会将当前的 value值 改变 data 中的 数组</p><p><strong>如何实现获取下拉框的选中状态</strong></p><p>1、 需要给select 通过v-model 双向绑定 一个值</p><p>2、 每一个option 必须要有value属性 且value 值不能一样</p><p>3、 当某一个option选中的时候 v-model 会将当前的 value值 改变 data 中的 数据</p><p>4、 当元素属性multiple为true，v-model绑定一个数组</p><p><strong>如何获取文本域中的值</strong></p><p>通过v-model 绑定一个值</p><p><strong>表单域修饰符</strong></p><p><strong>number：</strong>将输入内容转化为数值</p><p><strong>注意点：</strong> 当开始输入非数字的字符串时，因为Vue无法将字符串转换成数值</p><p>所以属性值将实时更新成相同的字符串。即使后面输入数字，也将被视作字符串。</p><p><strong>trim：</strong>去掉开始和结尾空格</p><p><strong>lazy：</strong>将input事件切换为change事件</p><p><strong>input事件：每次输入时触发</strong>  <strong>change事件：失去焦点时触发</strong></p><p>语法：&lt;input v-model.number=”age” type=”number”&gt;</p><h3 id="自定义指令（directive）"><a href="#自定义指令（directive）" class="headerlink" title="自定义指令（directive）"></a><strong>自定义指令（directive）</strong></h3><ul><li><p>  <strong>为何需要自定义指令？</strong> 内置指令不满足需求</p></li><li><p>  <strong>自定义全局指令的语法规则（获取元素焦点）</strong></p></li></ul><p>Vue.directive(‘focus’ {</p><p>inserted: function(el) {</p><p>// 获取元素的焦点</p><p>el.focus();</p><p>}</p><p>})</p><ul><li>  <strong>自定义指令用法</strong></li></ul><p>&lt;input type=”text” v-focus&gt;</p><ul><li>  <strong>带参数的自定义指令（改变元素背景色）</strong></li></ul><p>例：Vue.directive(‘color’, {</p><p>inserted: function(el, binding) {</p><p>el.style.backgroundColor = binding.value.color;</p><p>}</p><p>})</p><ul><li>  <strong>指令的用法</strong></li></ul><p>&lt;input type=”text” v-color=’{color:”orange”}’&gt;</p><h3 id="局部指令（directives）"><a href="#局部指令（directives）" class="headerlink" title="局部指令（directives）"></a><strong>局部指令（directives）</strong></h3><p><strong>局部指令和全局指令有什么区别</strong></p><ul><li><p>  局部的指令只能在当前页面使用</p></li><li><p>  全局的指令能够在任何组件中使用</p></li></ul><p><strong>如何自定义局部指令</strong></p><p>添加在Vue实例中的指令，局部指令定义在 <strong>directives</strong> 里面</p><h3 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a><strong>计算属性（computed）</strong></h3><ul><li>  <strong>计算属性的使用场景</strong></li></ul><p>模板中放入太多的逻辑会让模板过重且难以维护 使用计算属性可以让模板更加的简洁</p><ul><li>  <strong>computed中定义的 属性可以自定义吗？</strong></li></ul><p>可以</p><ul><li>  <strong>定义好的计算属性如何调用</strong></li></ul><ol><li><p> 在插值语法中 直接写 自定义的属性名</p></li><li><p> 在方法中 直接this.自定义的属性名()</p></li></ol><ul><li>  <strong>计算属性的用法</strong></li></ul><p>computed: {</p><p>reversedMessage: function () {</p><p>return this.msg.split(‘’).reverse().join(‘’)</p><p>}</p><p>}</p><ul><li>  <strong>计算属性和方法的区别</strong></li></ul><p><strong>计算属性是基于它们的依赖进行缓存的，方法不存在缓存</strong></p><p>意思就是，计算属性计算了第一次，之后的结果将直接引用第一次的结果</p><p>方法会计算每一次</p><h3 id="侦听器（watch）"><a href="#侦听器（watch）" class="headerlink" title="侦听器（watch）"></a><strong>侦听器（watch）</strong></h3><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/0e0df8d5350955ac09568d99affbee3b.png"></p><p><strong>侦听器的应用场景：</strong>数据变化时执行异步或者开销较大的操作</p><p><strong>侦听器的用法</strong></p><p>watch: {</p><p>firstName: function(val){</p><p>// val表示变化之后的值</p><p>this.fullName = val + this.lastName;</p><p>},</p><p>lastName: function(val) {</p><p>this.fullName = this.firstName + val;</p><p>}</p><p>}</p><h3 id="过滤器（filter）"><a href="#过滤器（filter）" class="headerlink" title="过滤器（filter）"></a><strong>过滤器（filter）</strong></h3><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/87995d9aa70ea2630737d1e9f8a3f109.png"></p><p>应用场景：格式化数据，比如将字符串格式化为首字母大写，将日期格式化为指定的格式等</p><ul><li>  <strong>如何定义一个过滤器</strong></li></ul><p>Vue.filter 或者 filters</p><ul><li>  <strong>如何定义全局和局部过滤器</strong></li></ul><p>Vue.filter 全局</p><p>Filters 局部</p><ul><li>  <strong>全局自定义过滤器</strong></li></ul><p>例：Vue.filter(‘过滤器名称’, function(value){</p><p>// 过滤器业务逻辑</p><p>})</p><ul><li>  <strong>过滤器的使用</strong></li></ul><p>例：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg | upper&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg | upper | lower&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">“id</span> | <span class="hljs-attr">formatId</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><ul><li>  <strong>局部过滤器</strong></li></ul><p>例：filters:{</p><p>capitalize: function(){}</p><p>}</p><ul><li>  <strong>带参数的过滤器</strong></li></ul><p>Vue.filter(‘format’, function(value, arg1){</p><p>// value就是过滤器传递过来的参数</p><p>})</p><ul><li>  <strong>过滤器的使用</strong></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;date | format(‘yyyy-MM-dd&#x27;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h2><h3 id="主要阶段"><a href="#主要阶段" class="headerlink" title="主要阶段"></a><strong>主要阶段</strong></h3><ul><li>  挂载（初始化相关属性）</li></ul><p>① beforeCreate</p><p>② created</p><p>③ beforeMount</p><p>④ mounted</p><ul><li>  更新（元素或组件的变更操作）</li></ul><p>① beforeUpdate</p><p>② updated</p><ul><li>  销毁（销毁相关属性）</li></ul><p>① beforeDestroy</p><p>② destroyed</p><h2 id="Vue数组处理"><a href="#Vue数组处理" class="headerlink" title="Vue数组处理"></a><strong>Vue数组处理</strong></h2><ul><li>  <strong>变异方法和替换数组有什么区别</strong></li></ul><p>变异的方法能够实现数据更新视图自动更新</p><p>替换数组 不会修改原始数据 导致 数据改变 视图不一定更新</p><ul><li>  <strong>变异方法和替换数组有哪些</strong></li></ul><p><strong>变异方法</strong></p><p>push pop shift unshift splice sort reverse</p><p><strong>替换数组</strong></p><p>filter concat slice</p><p><strong>数组响应式变化</strong></p><p>在实例外用索引修改的数据不是响应式，页面没有更新</p><p><strong>修改响应式数据</strong></p><ul><li><p>  Vue.set(vm.items, indexOfItem, newValue)</p></li><li><p>  vm.$set(vm.items, indexOfItem, newValue)</p></li></ul><p>① 参数一表示要处理的数组名称</p><p>② 参数二表示要处理的数组的索引</p><p>③ 参数三表示要处理的数组的值</p><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a><strong>组件化开发</strong></h2><h3 id="组件化开发思想"><a href="#组件化开发思想" class="headerlink" title="组件化开发思想"></a><strong>组件化开发思想</strong></h3><p>体现：标准、分治、重用、组合</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/a68852a8001097ea79c85cf5165b1d9a.png"></p><p>组件化规范: <strong>Web Components</strong></p><ul><li><p>  我们希望尽可能多的重用代码</p></li><li><p>  自定义组件的方式不太容易（html、css和js）</p></li><li><p>  多次使用组件可能导致冲突</p></li></ul><p>官网：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components</a></p><p><strong>Web Components 通过创建封装好功能的定制元素解决上述问题</strong></p><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a><strong>组件注册</strong></h3><p>组件是<strong>可复用的 Vue 实例</strong>，所以它们与 new Vue 接收相同的选项，例如<br><strong>data、computed、watch、methods</strong> 以及<strong>生命周期钩子</strong>等。仅有的例外是像 el<br>这样根实例特有的选项。</p><p><strong>全局组件注册语法：</strong>Vue.component(组件名称，{</p><p>data: 组件数据,</p><p>template: 组件模板内容</p><p>}</p><p>例：</p><pre><code class="hljs js"><span class="hljs-comment">//定义一个名为button-counter的新组件</span>vue.component (<span class="hljs-string">&#x27;button-counter&#x27;</span>, &#123;data: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> &#123;count: o&#125;,template: <span class="hljs-string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;点击了&#123;&#123; count &#125;&#125;次.&lt;/button&gt;&#x27;</span>&#125;)</code></pre><p><strong>注意：</strong></p><ol><li><p>一个<strong>组件的 data<br> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝（闭包）</p></li><li><p> <strong>组件模板内容必须是单个根元素</strong></p></li><li><p> <strong>组件模板内容可以是模板字符串</strong>，模板字符串需要浏览器提供支持（ES6语法）</p></li></ol><h3 id="组件用法"><a href="#组件用法" class="headerlink" title="组件用法"></a><strong>组件用法</strong></h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="组件重用"><a href="#组件重用" class="headerlink" title="组件重用"></a><strong>组件重用</strong></h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/ <span class="hljs-attr">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="组件命名方式"><a href="#组件命名方式" class="headerlink" title="组件命名方式"></a><strong>组件命名方式</strong></h3><ul><li><p>  短横线方式 Vue.component(‘my-component’, { /* … */ })</p></li><li><p>  驼峰方式 Vue.component(‘MyComponent’, { /* … */ })</p></li></ul><p><strong>注意：</strong>如果使用驼峰式命名组件，那么在使用组件的时候，只能在字符串模板中用驼峰的方式使用组件，但是在普通的标签模板中，必须使用短横线的方式使用组件</p><h3 id="局部组件注册"><a href="#局部组件注册" class="headerlink" title="局部组件注册"></a><strong>局部组件注册</strong></h3><p><strong>只能在注册它的父组件中使用</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> componentA = &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-keyword">var</span> componentB = &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-keyword">var</span> componentc = &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-keyword">new</span> vue (&#123;el: <span class="hljs-string">&#x27;#app&#x27;</span>components: &#123;<span class="hljs-string">&#x27;component-a&#x27;</span>: componentA,<span class="hljs-string">&#x27;component-b&#x27;</span>: componentB,<span class="hljs-string">&#x27;component-c&#x27;</span>: componentc,&#125;&#125;)</code></pre><h2 id="Vue调试工具"><a href="#Vue调试工具" class="headerlink" title="Vue调试工具"></a><strong>Vue调试工具</strong></h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/626f01495085b857ae5866e6b018dc18.png"></p><h2 id="组件间数据交互"><a href="#组件间数据交互" class="headerlink" title="组件间数据交互"></a><strong>组件间数据交互</strong></h2><h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a><strong>父组件向子组件传值</strong></h3><ol><li> 组件内部通过props接收传递过来的值</li></ol><pre><code class="hljs js">Vue.component (<span class="hljs-string">&#x27;menu-item&#x27;</span>, &#123;props: [<span class="hljs-string">&#x27;title&#x27;</span>],template: <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;&#x27;</span>&#125;)</code></pre><ol start="2"><li>父组件通过属性将值传递给子组件</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">menu-item</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;来自父组件的数据&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">menu-item</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">menu-item</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">menu-item</span>&gt;</span></code></pre><p><strong>props属性名规则</strong></p><ul><li><p>  在props中使用驼峰形式，</p></li><li><p>  标签中需要使用短横线的形式，字符串形式的模板中没有这个限制</p></li></ul><pre><code class="hljs js">Vue.component (<span class="hljs-string">&#x27;menu-item&#x27;</span>, &#123;<span class="hljs-comment">// 在Javascript中是驼峰式的</span>props: [<span class="hljs-string">&#x27;menuritle&#x27;</span>],template: <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123; menuTitle &#125;&#125;&lt;/div&gt;&#x27;</span>&#125;)<span class="hljs-comment">// 在html中是短横线方式的</span><span class="hljs-comment">// &lt;menu-item menu-title=&quot;nihao&quot;&gt;&lt;/menu-item&gt;</span></code></pre><p>原因：html标签对大小写不敏感</p><p><strong>props属性值类型</strong></p><ul><li><p>  可以传递静态值</p></li><li><p>  也可以传递动态值</p></li><li><p>  动态值可以是 字符串String 数字Number 布尔值Boolean 数组Array</p></li></ul><p>对象Object</p><p>props传递数据原则：单向数据流（不允许子组件直接向父组件传递数据）</p><h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a><strong>子组件向父组件传值</strong></h3><ul><li><p>  子组件用**$emit()**触发事件</p></li><li><p>  $emit() 第一个参数为 <strong>自定义的事件名称</strong> 第二个参数为<strong>需要传递的数据</strong></p></li><li><p>  父组件通过事件监听监听子组件传递过来的数据</p></li></ul><p>例：</p><ul><li>  <strong>子组件通过自定义事件向父组件传递信息</strong></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:</span> <span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;$emit(&quot;enlarge-text&quot;)&#x27;</span>&gt;</span>扩大字体<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><ul><li>  <strong>父组件监听子组件的事件</strong></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">menu-item</span> <span class="hljs-attr">v-on:enlarge-text</span>=<span class="hljs-string">&#x27; fontsize += 0.1&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">menu-item</span>&gt;</span></code></pre><ul><li>  <strong>子组件通过自定义事件向父组件传递信息</strong></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&#x27;$emit (&quot;enlarge-text&quot;，0.1)&#x27;</span>&gt;</span>扩大字体<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><ul><li>  <strong>父组件监听子组件的事件</strong></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">menu-item</span> <span class="hljs-attr">v-on:enlarge-text</span>=<span class="hljs-string">&#x27;fontsize += $event&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">menu-item</span>&gt;</span></code></pre><h3 id="非父子组件间传值"><a href="#非父子组件间传值" class="headerlink" title="非父子组件间传值"></a><strong>非父子组件间传值</strong></h3><p><strong>兄弟之间通讯</strong></p><p>兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据</p><p>提供事件中心 <strong>var hub = new Vue()</strong></p><ul><li><p>  传递数据方，通过一个事件触发<strong>hub.$emit(方法名，传递的数据)</strong></p></li><li><p>  接收数据方，通过mounted(){} 钩子中 触发**hub.$on()**方法名</p></li><li><p>  销毁事件 通过**hub.$off()**方法名销毁之后无法进行传递数据</p></li></ul><p>例：</p><ol><li><p>单独的事件中心管理组件间的通信</p><p>var eventHub = new Vue()</p></li><li><p>监听事件和销毁事件</p><p> eventHub.$on(‘add-todo’, addTodo)</p><p> eventHub.$off(‘add-todo’)</p></li><li><p>触发事件</p><p> eventHub.$emit(‘add-todo’, id)</p></li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/7d7708605d6fb3cba9735c4c36391e0c.png"></p><h3 id="组件插槽"><a href="#组件插槽" class="headerlink" title="组件插槽"></a><strong>组件插槽</strong></h3><ul><li>  <strong>插槽的作用</strong></li></ul><p>组件的最大特性就是复用性，而用好插槽能大大提高组件的可复用能力</p><ul><li>  <strong>插槽的使用</strong></li></ul><ol><li><p> 提供一个插槽的位置</p></li><li><p> 插槽的内容</p></li></ol><p><strong>父组件向子组件传递内容</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/97ffe2707451739b160d572d343d302a.png"></p><p><strong>插槽位置</strong></p><pre><code class="hljs js">Vue.component (<span class="hljs-string">&#x27;alert-box&#x27;</span>, &#123;termplate:<span class="hljs-string">`</span><span class="hljs-string">&lt;div class=&quot;demo-alert-box&quot;&gt;</span><span class="hljs-string">&lt;strong&gt;Error!&lt;/ strong&gt;</span><span class="hljs-string">&lt;slot&gt;&lt;/slot&gt;</span><span class="hljs-string">&lt;/div&gt;</span><span class="hljs-string">`</span>&#125;)</code></pre><p><strong>插槽内容</strong></p><p>&lt;alert-box&gt;Something bad happened.&lt;/alert-box&gt;</p><p><strong>具名插槽用法</strong></p><ul><li><p>  <strong>具名插槽和匿名插槽的区别：</strong>具名插槽有名字，匿名插槽没有名字</p></li><li><p>  具名插槽用法</p></li></ul><ol><li><p> 使用 &lt;slot&gt; 中的 “name” 属性绑定元素</p></li><li><p>通过slot属性来指定, 这个slot的值必须和下面slot组件得name值对应上<br> 如果没有匹配到 则放到匿名的插槽中</p></li></ol><p>template标签：应用在需要将多条标签放到插槽中，用template包裹</p><p><strong>插槽定义</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot; footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><strong>插槽内容</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hl</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>标题内容<span class="hljs-tag">&lt;/<span class="hljs-name">hl</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主要内容1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主要内容2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>底部内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></code></pre><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a><strong>作用域插槽</strong></h3><p>应用场景：<strong>父组件对子组件的内容进行加工处理</strong></p><p>作用域插槽的使用</p><p>子组件模板中,&lt;slot&gt;元素上有一个类似props传递数据给组件的写法msg=”xxx</p><p>插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。<br>如果父组件为这个插槽提供了内容，则默认的内容会被替换掉</p><p>例：</p><p><strong>插槽定义</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>= <span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">v-bind:</span> <span class="hljs-attr">key</span>= <span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;item.name&#125; &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p><strong>插槽内容</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">fruit-list</span> <span class="hljs-attr">v-bind</span> <span class="hljs-attr">:</span> <span class="hljs-attr">list</span>= <span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;slotProps.item.current&quot;</span>&gt;</span>&#123;&#123; slotProps.item.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">fruit-list</span>&gt;</span></code></pre><h2 id="Vue前后端交互"><a href="#Vue前后端交互" class="headerlink" title="Vue前后端交互"></a><strong>Vue前后端交互</strong></h2><h3 id="前后端交互模式"><a href="#前后端交互模式" class="headerlink" title="前后端交互模式"></a><strong>前后端交互模式</strong></h3><p><strong>接口调用方式</strong></p><ul><li><p>  原生Ajax</p></li><li><p>  基于jQuery的Ajax 在Vue中基本派不上用场</p></li><li><p>  fetch Ajax的升级版，标准</p></li><li><p>  axios 第三方库</p></li></ul><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/35a92b3c38cc2d8504b7479ed0aa6241.png"></p><h3 id="URL地址格式"><a href="#URL地址格式" class="headerlink" title="URL地址格式"></a><strong>URL地址格式</strong></h3><h4 id="传统形式的URL"><a href="#传统形式的URL" class="headerlink" title="传统形式的URL"></a><strong>传统形式的URL</strong></h4><p>格式：schema://host:post/path?query#fragment</p><ol><li><p> schema：协议。例如http、https、ftp等</p></li><li><p> host：域名或者IP地址</p></li><li><p> port：端口，http默认端口80，可以省略</p></li><li><p> path：路径，例如/abc/a/b/c</p></li><li><p> query：查询参数，例如uname=lisi&amp;age=12</p></li><li><p> frament：锚点（哈希Hash），用于定位页面的某个位置</p></li></ol><h4 id="Restful形式的URL"><a href="#Restful形式的URL" class="headerlink" title="Restful形式的URL"></a><strong>Restful形式的URL</strong></h4><p>HTTP请求方式：GET（查询）POST（添加）PUT（修改） DELETE（删除）</p><h2 id="Promise用法"><a href="#Promise用法" class="headerlink" title="Promise用法"></a><strong>Promise用法</strong></h2><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a><strong>异步调用</strong></h3><ul><li><p>  JS中常见的异步调用：定时任务，Ajax，事件函数</p></li><li><p>  多次异步调用的依赖分析</p></li></ul><p>多次异步调用的结果顺序不确定，异步调用结果如果存在依赖需要嵌套</p><h3 id="Promise概述"><a href="#Promise概述" class="headerlink" title="Promise概述"></a><strong>Promise概述</strong></h3><p>Promise使异步编程的一种解决方案，从语法上讲，Promise是一个对象，从它可以获取异步操作的消息。</p><h3 id="使用Promise主要有以下好处："><a href="#使用Promise主要有以下好处：" class="headerlink" title="使用Promise主要有以下好处："></a><strong>使用Promise主要有以下好处：</strong></h3><ul><li><p>  可以避免多层异步调用嵌套问题（回调地狱）</p></li><li><p>  Promise对象提供了简洁的API，使得控制异步操作更加容易</p></li></ul><h3 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a><strong>Promise基本用法</strong></h3><ul><li><p>  实例化<strong>Promise</strong>对象，构造函数中传递函数，该函数中用于处理异步任务</p></li><li><p>  <strong>resolve</strong>和<strong>reject</strong>两个参数用于处理成功和失败两种情况，并通过**.then**获取结果</p></li></ul><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>)</span>&#123;<span class="hljs-comment">// 成功时调用resolve()</span><span class="hljs-comment">// 失败时调用reject ()</span>&#125;);p.then ( funciton (ret) &#123;<span class="hljs-comment">// 从resolve得到正常结果</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-comment">// 从reject得到错误信息</span>&#125;);</code></pre><h3 id="基于Promise处理Ajax请求"><a href="#基于Promise处理Ajax请求" class="headerlink" title="基于Promise处理Ajax请求"></a><strong>基于Promise处理Ajax请求</strong></h3><ol><li> <strong>处理原生Ajax</strong></li></ol><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryData</span>(<span class="hljs-params">ur1</span>) </span>&#123;<span class="hljs-comment">// 1.1创建一个promise实例</span><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reso1ve，reject</span>)</span>&#123;<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">if</span>(xhr.readystate != <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">xhr.readystate == <span class="hljs-number">4</span> &amp;&amp;xhr.status == <span class="hljs-number">200</span></span>)</span> &#123;<span class="hljs-comment">// 1.2处理正常的情况</span>resolve(xhr.responserext);&#125;e1se&#123;<span class="hljs-comment">// 1.3处理异常情况</span>reject(<span class="hljs-string">&#x27;服务器错误&quot;);</span><span class="hljs-string">&#125;</span><span class="hljs-string">&#125;;</span><span class="hljs-string">xhr.open(&#x27;</span>get<span class="hljs-string">&#x27;, ur1);</span><span class="hljs-string">xhr.send(nu11);</span><span class="hljs-string">&#125;);</span><span class="hljs-string">return p;</span><span class="hljs-string">&#125;</span></code></pre><ol start="2"><li><strong>发送多次Ajax请求</strong></li></ol><pre><code class="hljs js">#注意:这里需要开启一个服务#在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了queryData(<span class="hljs-string">&#x27;http://localhost:3000/data&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;conso1e.log(data)#1.4想要继续链式编程下去需要return<span class="hljs-keyword">return</span> queryData(<span class="hljs-string">&#x27;http://localhost:3000/data1&#x27;</span>);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(data);<span class="hljs-keyword">return</span> queryData(<span class="hljs-string">&#x27;http://localhost:3000/data2&#x27;</span>);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(data)&#125;);</code></pre><p><strong>then参数中的函数返回值（了解一下）</strong></p><ol><li><p> 返回Promise实例对象：返回的该实例对象会调用下一个then</p></li><li><p> 返回普通值：返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值</p></li></ol><h3 id="Promise常用的API"><a href="#Promise常用的API" class="headerlink" title="Promise常用的API"></a><strong>Promise常用的API</strong></h3><ol><li> <strong>实例方法</strong></li></ol><ul><li><p>  <strong>.then()</strong> 得到异步任务的正确结果</p></li><li><p>  <strong>.catch()</strong> 获取异常信息</p></li><li><p>  <strong>.finally()</strong> 成功与否都会执行（尚且不是正式标准）</p></li></ul><pre><code class="hljs js">foo().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(data)&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(data)&#125;).final1y(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;finished&#x27;</span></span></span><span class="hljs-function"><span class="hljs-params">&#125;</span>)</span>;--------------------------------------------两种写法是等效的foo().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;#得到异步任务正确的结果<span class="hljs-built_in">console</span>.log(data)&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;#获取异常信息<span class="hljs-built_in">console</span>.log(data)&#125;)#成功与否都会执行（不是正式标准).fina1ly(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;finished&#x27;</span>)</span></span><span class="hljs-function"><span class="hljs-params">&#125;</span>)</span>;</code></pre><ol start="2"><li><strong>对象方法</strong></li></ol><ul><li><p><strong>Promise.all()</strong><br>  方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用<br>  Promise.resolve<br>  转换为一个promise)。它的状态由这三个promise实例决定。如果参数中 promise<br>  有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败<br>  promise 的结果。</p></li><li><p><strong>Promise.race()</strong> 方法同样接受一个数组作参数。当p1, p2,<br>  p3中有一个实例的状态发生改变（变为 fulfilled或 rejected<br>  ），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数<strong>（有返回值了马上返回）</strong></p></li></ul><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a><strong>fetch</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><strong>基本特性：</strong></p><ol><li>更加简单的数据获取方式，功能更强大、更灵活，可以看做是xhr的升级版，基于Promise实现</li></ol><p><strong>2. fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong></p><pre><code class="hljs js"><span class="hljs-comment">/*</span><span class="hljs-comment">Fetch API基本用法</span><span class="hljs-comment">fetch(ur1).then(</span><span class="hljs-comment">第一个参数请求的路径Fetch会返回promise所以我们可以使用then拿到请求成功的结果</span><span class="hljs-comment">*/</span>fetch(<span class="hljs-string">&#x27; http://localhost: 3000/fdata&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<span class="hljs-comment">// text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据</span><span class="hljs-keyword">return</span> data.text();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<span class="hljs-comment">// 在这个then里面我们能拿到最终的数据</span><span class="hljs-built_in">console</span>.log(data) ;&#125;)</code></pre><h3 id="fetch请求参数（fetch-url-options-then-）"><a href="#fetch请求参数（fetch-url-options-then-）" class="headerlink" title="fetch请求参数（fetch(url, options).then(）)"></a><strong>fetch请求参数（fetch(url, options).then(）)</strong></h3><p>HTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT</p><ul><li><p>  默认的是 GET 请求</p></li><li><p>  需要在 options 对象中 指定对应的 method method:请求使用的方法</p></li><li><p>  post 和 普通 请求的时候 需要在options 中 设置 请求头 headers 和 body</p></li></ul><p>传统URL get请求</p><pre><code class="hljs js">#1.1 GET参数传递–传统URL通过ur1 ? 的形式传参fetch(<span class="hljs-string">&#x27;http://localhost:3000/books?id-123&#x27;</span>，&#123;# get请求可以省略不写默认的是GETmethod: <span class="hljs-string">&#x27;get&#x27;</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;# 它返回一个promise实例对象，用于获取后台返回的数据<span class="hljs-keyword">return</span> data.text();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;# 在这个then里面我们能拿到最终的数据<span class="hljs-built_in">console</span>.log(data)&#125;);</code></pre><p>restful形式URL get请求</p><pre><code class="hljs js">#1.2—GET参数传递restful形式的uRL通过/的形式传递参数即id = 456和id后台的配置有关fetch(<span class="hljs-string">&#x27;http://loca1host:3000/books/456&#x27;</span>，&#123;#get请求可以省略不写默认的是GETmethod: <span class="hljs-string">&#x27;get&#x27;</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-keyword">return</span> data.text();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(data)  &#125;)</code></pre><p>delete请求</p><pre><code class="hljs js">#2.1DELETE请求方式参数传递 删除id是id=789fetch(<span class="hljs-string">&#x27;http://loca1host:3000/books/789&#x27;</span>，&#123;method: <span class="hljs-string">&#x27;delete&#x27;</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-keyword">return</span> data.text();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(data)&#125;);</code></pre><p>POST请求，请求头为urlencoded</p><pre><code class="hljs js">#3 POST请求传参fetch(<span class="hljs-string">&#x27;http://localhost:3000/books&#x27;</span>, &#123;method:<span class="hljs-string">&#x27; post &quot;，</span><span class="hljs-string"># 3.1 传递数据</span><span class="hljs-string">body: &#x27;</span>uname=lisi&amp;pwd=<span class="hljs-number">123</span><span class="hljs-string">&#x27;，</span><span class="hljs-string"># 3.2 设置请求头</span><span class="hljs-string">headers: &#123;</span><span class="hljs-string">&#x27;</span>Content-Type<span class="hljs-string">&#x27;: &#x27;</span>app1ication/x-www-form-urlencoded<span class="hljs-string">&#x27;</span><span class="hljs-string">&#125;</span><span class="hljs-string">&#125;)</span><span class="hljs-string">.then(function(data) &#123;</span><span class="hljs-string">return data.text();</span><span class="hljs-string">&#125;).then(function(data) &#123;</span><span class="hljs-string">console.log(data)</span><span class="hljs-string">&#125;);</span></code></pre><p>POST请求，请求头为JSON</p><pre><code class="hljs js">#POST请求传参fetch(<span class="hljs-string">&#x27;http://localhost: 3000/books&#x27;</span>， &#123;method: <span class="hljs-string">&#x27;post&#x27;</span>,body: <span class="hljs-built_in">JSON</span>.stringify(&#123;uname:<span class="hljs-string">&#x27;张三&#x27;</span>，pwd: <span class="hljs-string">&#x27;456&#x27;</span>  &#125;),headers: &#123;<span class="hljs-string">&#x27;content-rype&#x27;</span> : <span class="hljs-string">&quot;application/json&#x27;</span><span class="hljs-string">&#125;</span><span class="hljs-string">&#125;)</span><span class="hljs-string">.then(function(data) &#123;</span><span class="hljs-string">return data.text();</span><span class="hljs-string">&#125;).then(function(data) &#123;</span><span class="hljs-string">console.log(data)</span><span class="hljs-string">&#125;);</span></code></pre><p>PUT请求</p><pre><code class="hljs js">#PUT请求传参 修改id是<span class="hljs-number">123</span>的fetch(<span class="hljs-string">&#x27;http://localhost:3000/books/123&#x27;</span>，&#123;method: <span class="hljs-string">&#x27;put&#x27;</span>,body: <span class="hljs-built_in">JSON</span>.stringify(&#123;uname:<span class="hljs-string">&#x27;张三&#x27;</span>,pwd: <span class="hljs-string">&#x27;789&#x27;</span>&#125;),headers: &#123;<span class="hljs-string">&#x27;content-rype&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-keyword">return</span> data.text();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(data)&#125;);</code></pre><h3 id="fetch响应结果"><a href="#fetch响应结果" class="headerlink" title="fetch响应结果"></a><strong>fetch响应结果</strong></h3><p>用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如<br>JSON ， BLOB 或者TEXT 等等</p><h3 id="响应数据格式："><a href="#响应数据格式：" class="headerlink" title="响应数据格式："></a><strong>响应数据格式：</strong></h3><p>text()：将返回体处理成字符串类型</p><p>json()：返回结果和JSON.parse(responseText)一样</p><pre><code class="hljs js">fetch(<span class="hljs-string">&#x27;http://localhost:3000/json&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<span class="hljs-comment">//return data.json(); // 将获取到的数据使用json转换对象</span><span class="hljs-keyword">return</span> data.text(); <span class="hljs-comment">// 将获取到的数据转换成字符串</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<span class="hljs-comment">// console.log(data.uname)</span><span class="hljs-comment">// console.log(typeof data)</span><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(data);<span class="hljs-built_in">console</span>.log(obj.uname, obj.age, obj.gender)&#125;)</code></pre><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a><strong>axios</strong></h2><h3 id="axios基本特性"><a href="#axios基本特性" class="headerlink" title="axios基本特性"></a><strong>axios基本特性</strong></h3><p>axios是一个基于Promise用于浏览器和node.js的HTTP客户端。</p><ul><li><p>  支持浏览器和node.js</p></li><li><p>  支持promise</p></li><li><p>  能拦截请求和响应</p></li><li><p>  自动转换JSON数据</p></li><li><p>  能转换请求和响应数据</p></li></ul><h3 id="axios基础用法"><a href="#axios基础用法" class="headerlink" title="axios基础用法"></a><strong>axios基础用法</strong></h3><ul><li><p>  get和 delete请求传递参数</p></li><li><p>  通过传统的url 以 ? 的形式传递参数</p></li><li><p>  restful 形式传递参数</p></li><li><p>  通过params 形式传递参数</p></li><li><p>  post 和 put 请求传递参数</p></li><li><p>  通过选项传递参数（默认传递json格式）</p></li><li><p>  通过 <strong>URLSearchParams</strong> 传递参数（传递urlencoded格式）</p></li></ul><p>例：</p><pre><code class="hljs js">#1.友送get请求axios.get(<span class="hljs-string">&#x27; http://localhost:3000/adata &#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;#拿到ret是一个对象 所有的对象都存在ret的data属性里面<span class="hljs-comment">// 注意data属性是固定的用法，用于获取后台的实际数据</span><span class="hljs-comment">// console.log(ret.data)</span><span class="hljs-built_in">console</span>.log(ret)&#125;)# 2. get请求传递参数# 2.1通过传统的ur1以?的形式传递参数axios.get(<span class="hljs-string">&#x27;http://localhost:3000/axios?id=123&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(ret.data)&#125;)# 2.2restful形式传递参数axios.get(<span class="hljs-string">&#x27; http: / /loca1host:3000/axios/123&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(ret.data)&#125;)# 2.3通过params形式传递参数axios.get(<span class="hljs-string">&#x27; http://localhost: 3000/axios&#x27;</span>, &#123;params: &#123;id: <span class="hljs-number">789</span>&#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(ret.data)&#125;)#3axios delete请求传参 传参的形式和get请求一样axios.delete(<span class="hljs-string">&#x27;http://localhost:3000/axios&#x27;</span>, &#123;params: &#123;id: <span class="hljs-number">111</span>&#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(ret.data)&#125;)#4 axios的post请求#4.1通过选项传递参数axios.post(<span class="hljs-string">&#x27;http://localhost:3000/axios&#x27;</span>, &#123;uname: <span class="hljs-string">&#x27;lisi&#x27;</span>,pwd: <span class="hljs-number">123</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(ret.data)&#125;)#4.2通过URLSearchParams传递参数<span class="hljs-keyword">var</span> params = <span class="hljs-keyword">new</span> uRLSearchParams();params.append(<span class="hljs-string">&#x27;uname&#x27;</span>, <span class="hljs-string">&#x27;zhangsan &#x27;</span> );params.append( <span class="hljs-string">&#x27;pwd&#x27;</span>, <span class="hljs-string">&#x27;111&#x27;</span>);axios.post(<span class="hljs-string">&#x27;http://1ocalhost:3000/axios&#x27;</span>, params).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(ret.data)&#125;)#5axios put请求传参和post请求一样axios.put(<span class="hljs-string">&#x27; http://localhost:3000/axios/123&#x27;</span>, &#123;uname: <span class="hljs-string">&#x27;lisi&#x27;</span>,pwd: <span class="hljs-number">123</span>params: &#123;id: <span class="hljs-number">789</span>&#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-built_in">console</span><span class="hljs-number">.1</span>og(ret.data)&#125;#3 axios delete请求传参 传参的形式和get请求一样axios.delete(<span class="hljs-string">&#x27;http://localhost:3000/axios&#x27;</span>, &#123;params: &#123;id: <span class="hljs-number">111</span>&#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(ret.data)&#125;)</code></pre><h3 id="axios的响应结果"><a href="#axios的响应结果" class="headerlink" title="axios的响应结果"></a><strong>axios的响应结果</strong></h3><p>响应结果的主要属性：</p><ul><li><p>  data：实际响应回来的数据</p></li><li><p>  headers：响应头信息</p></li><li><p>  status：响应状态码</p></li><li><p>  statusText：响应状态信息</p></li></ul><h3 id="axios的全局配置"><a href="#axios的全局配置" class="headerlink" title="axios的全局配置"></a><strong>axios的全局配置</strong></h3><ul><li>  配置公共的请求头</li></ul><p>例：axios.defaults.baseURL = ‘<a href="https://api.example.com&/#39;">https://api.example.com&#39;</a>;</p><ul><li>  配置 超时时间</li></ul><p>例：axios.defaults.timeout = 2500;</p><ul><li>  配置公共的请求头</li></ul><p>例：axios.defaults.headers.common[‘Authorization’] = AUTH_TOKEN;</p><ul><li>  配置公共的 post 的 Content-Type</li></ul><p>例：axios.defaults.headers.post[‘Content-Type’] =<br>‘application/x-www-form-urlencoded’;</p><h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a><strong>axios拦截器</strong></h3><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/e223e4df10dce9e57c341f1008084767.png"></p><h4 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a><strong>请求拦截器</strong></h4><p>作用：在请求发送前进行一些操作</p><p>例如：在每个请求体里加上token，统一做了处理如果以后要改也非常容易</p><pre><code class="hljs js"><span class="hljs-comment">// 添加一个请求拦截器</span>axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>)</span>&#123;<span class="hljs-comment">// 在请求发出之前进行一些信息设置</span><span class="hljs-keyword">return</span> config;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;<span class="hljs-comment">// 处理响应的错误信息</span>&#125;);</code></pre><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/20088a1ea3d8e59f2fa154153287d4ce.png"></p><h4 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a><strong>响应拦截器</strong></h4><p>作用：在接收到响应后进行一些操作</p><p>例如：在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页</p><pre><code class="hljs js"><span class="hljs-comment">// 添加一个响应拦截器</span>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<span class="hljs-comment">// 在这里对返回的数据进行处理</span><span class="hljs-keyword">return</span> res;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;<span class="hljs-comment">// 处理响应的错误信息</span>&#125;)</code></pre><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a><strong>async和await</strong></h3><ul><li><p>  async作为一个关键字放在函数前面</p></li><li><p>  任何一个async函数都会隐式返回一个promise</p></li><li><p>  await关键字只能在使用async定义的函数中使用</p></li><li><p>  await可以得到异步结果</p></li><li><p>  await后面可以直接跟一个Promise实例对象</p></li><li><p>  <strong>async/await让异步代码看起来、表现起来更像同步代码</strong></p></li></ul><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryData</span> (<span class="hljs-params">id</span>)</span>&#123;<span class="hljs-keyword">const</span> ret = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;/data&#x27;</span>) ;<span class="hljs-keyword">return</span> ret;queryData.then(<span class="hljs-function"><span class="hljs-params">ret</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(ret)&#125;)</code></pre><p><strong>async/await处理多个异步请求</strong></p><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryData</span>(<span class="hljs-params">id</span>) </span>&#123;<span class="hljs-keyword">const</span> info = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;/asyncl&#x27;</span> );<span class="hljs-keyword">const</span> ret = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;async2?info=&#x27;</span> + info.data);<span class="hljs-keyword">return</span> ret;&#125;queryData.then(<span class="hljs-function"><span class="hljs-params">ret</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log (ret)&#125;)</code></pre><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a><strong>Vue-router</strong></h2><h3 id="路由的基本概念与原理"><a href="#路由的基本概念与原理" class="headerlink" title="路由的基本概念与原理"></a><strong>路由的基本概念与原理</strong></h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a><strong>路由</strong></h4><p>路由是一个比较广义和抽象的概念，<strong>路由的本质就是对应关系</strong>。</p><p>路由分为前端路由和后端路由</p><p>1).<strong>后端路由</strong>是由服务器端进行实现，并完成资源的分发</p><p>2).<strong>前端路由</strong>是依靠hash值(锚链接)的变化进行实现</p><h4 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a><strong>后端路由</strong></h4><p>概念：根据不同的用户URL请求，返回不同的内容</p><p>本质：URL请求地址与服务器资源之间的对应关系</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/92172d959139e9ab85f7e4d0bf2c1d8a.png"></p><h4 id="SPA（Single-Page-Application）"><a href="#SPA（Single-Page-Application）" class="headerlink" title="SPA（Single Page Application）"></a><strong>SPA（Single Page Application）</strong></h4><ul><li><p>  后端渲染（存在性能问题）</p></li><li><p>  Ajax前端渲染（前端渲染提高性能，但是不支持浏览器的前进后退操作）</p></li><li><p>  <strong>SPA单页面应用程序：</strong>整个网站只有一个页面，内容变化通过Ajax局部更新实现、同时支持浏览器地址栏的前进和后退操作</p></li><li><p>  SPA实现原理之一：<strong>基于URL地址的hash</strong>（hash的变化会导致浏览器记录访问历史的变化、但是hash的变化不会触发新的URL请求）</p></li><li><p>  在实现SPA过程中，<strong>最核心的技术点就是前端路由</strong></p></li></ul><h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a><strong>前端路由</strong></h4><p>概念：根据不同的用户事件，显示不同的页面内容</p><p>本质：用户事件与事件处理函数之间的对应关系</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/vue/0d2c5146ed7e6baf75b18d25a9206364.png"></p><p><strong>Vue Router</strong></p><p>Vue Router是vue官方的路由管理器</p><p>Vue Router的特性：</p><table><thead><tr><th>支持H5历史模式或者hash模式</th><th>支持嵌套路由</th></tr></thead><tbody><tr><td>支持路由参数</td><td>支持编程式路由</td></tr><tr><td>支持命名路由</td><td>支持路由导航守卫</td></tr><tr><td>支持路由过渡动画特效</td><td>支持路由懒加载</td></tr><tr><td>支持路由滚动行为</td><td></td></tr></tbody></table><h3 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a><strong>基本使用步骤</strong></h3><ol><li> 引入相关的库文件</li></ol><pre><code class="hljs html"><span class="hljs-comment">&lt;!--导入vue文件，为全局window对象挂载vue构造函数--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./lib/vue_2.5.22.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--导入vue-router文件，为全局window对象挂载VueRouter构造函数--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./lib/vue-router_3.0.2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><ol start="2"><li>添加路由链接</li></ol><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- router-link是vue中提供的标签，默认会被渲染为a标签--&gt;</span><span class="hljs-comment">&lt;!-- to属性默认会被渲染为href属性--&gt;</span><span class="hljs-comment">&lt;!-- to属性的值默认会被渲染为#开头的hash 地址--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/user&quot;</span>&gt;</span>User<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot; /register&quot;</span>&gt;</span>Register<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></code></pre><ol start="3"><li>添加路由填充位</li></ol><pre><code class="hljs html"><span class="hljs-comment">&lt;!--路由填充位（也叫做路由占位符)--&gt;</span><span class="hljs-comment">&lt;!--将来通过路由规则匹配到的组件，将会被渲染到router-view所在的位置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></code></pre><ol start="4"><li>定义路由组件</li></ol><pre><code class="hljs js"><span class="hljs-keyword">var</span> User = &#123;template: <span class="hljs-string">&#x27;&lt;div&gt;User&lt;/div&gt;&#x27;</span>&#125;<span class="hljs-keyword">var</span> Register = &#123;template: <span class="hljs-string">&#x27;&lt;div&gt;Register&lt;/div&gt;&#x27;</span>&#125;</code></pre><ol start="5"><li>配置路由规则并创建路由实例</li></ol><pre><code class="hljs js"><span class="hljs-comment">// 创建路由实例对象</span><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<span class="hljs-comment">// routes是路由规则数组</span>routes: [<span class="hljs-comment">// 每个路由规则都是一个配置对象，其中至少包含path和component两个属性:</span><span class="hljs-comment">// path表示当前路由规则匹配的hash地址</span><span class="hljs-comment">// component表示当前路由规则对应要展示的组件</span>    &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27; /user&#x27;</span>, <span class="hljs-attr">component</span>: User&#125;,&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27; /register&#x27;</span>, <span class="hljs-attr">component</span>: Register&#125;  ]&#125;)</code></pre><ol start="6"><li>把路由挂载到Vue根实例中</li></ol><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue (&#123;el: <span class="hljs-string">&#x27;#app&#x27;</span>,<span class="hljs-comment">// 为了能够让路由规则生效，必须把路由对象挂载到vue实例对象上</span>router&#125;);</code></pre><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a><strong>路由重定向</strong></h3><p>路由重定向指的是：用户在访问地址A的时候，强制用户跳转到地址C，从而展示特定的组件页面；</p><p>通过路由规则的<strong>redirect</strong>属性，指定一个新的路由地址，可以很方便地设置路由地重定向</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;routes: [<span class="hljs-comment">//其中，path表示需要被重定向的原地址，redirect表示将要被重定向到的新地址</span>&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/user&#x27;</span>&#125;,&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user &#x27;</span> ,<span class="hljs-attr">component</span>: User&#125;,&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register &#x27;</span>,<span class="hljs-attr">component</span>: Register&#125;  ]&#125;)</code></pre><h3 id="vue-router嵌套路由"><a href="#vue-router嵌套路由" class="headerlink" title="vue-router嵌套路由"></a><strong>vue-router嵌套路由</strong></h3><h4 id="嵌套路由用法"><a href="#嵌套路由用法" class="headerlink" title="嵌套路由用法"></a><strong>嵌套路由用法</strong></h4><ol><li> <strong>父路由组建模板</strong>：父级路由链接、父组件路由填充位</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/user&quot;</span>&gt;</span>User<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/register&quot;</span>&gt;</span>Register<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 控制组件的显示位置 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><ol start="2"><li><strong>子级路由模板</strong>：子级路由链接、子级路由填充位</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> Register = &#123;template: <span class="hljs-string">`&lt;div&gt;</span><span class="hljs-string">&lt;h1&gt;Register组件&lt;/h1&gt;</span><span class="hljs-string">&lt;hr/&gt;</span><span class="hljs-string">&lt;router-link to=&quot;/register/tab1&quot; &gt;Tabl&lt;/router-link&gt;</span><span class="hljs-string">&lt;router-link to=&quot; /registertab2&quot; &gt;Tab2&lt;/router-link&gt;</span><span class="hljs-string">&lt;!--子路由填充位置—-&gt;</span><span class="hljs-string">&lt;router-view/&gt;</span><span class="hljs-string">&lt;/div&gt;`</span>&#125;</code></pre><ol start="3"><li><strong>嵌套路由配置</strong>：父级路由通过children属性配置子级路由</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;routes : [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">component</span>: User &#125;,    &#123;      path: <span class="hljs-string">&#x27;/register&#x27;</span>,component: Register,<span class="hljs-comment">//通过children属性，为/register 添加子路由规则</span>children:[        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register/tab1&#x27;</span> , <span class="hljs-attr">component</span>: Tab1 &#125;,&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register/tab2&#x27;</span> , <span class="hljs-attr">component</span>: Tab2 &#125;      ]    &#125;  ]&#125;)</code></pre><h3 id="vue-router动态路由匹配"><a href="#vue-router动态路由匹配" class="headerlink" title="vue-router动态路由匹配"></a><strong>vue-router动态路由匹配</strong></h3><h4 id="动态匹配路由的基本用法"><a href="#动态匹配路由的基本用法" class="headerlink" title="动态匹配路由的基本用法"></a><strong>动态匹配路由的基本用法</strong></h4><p>应用场景：通过动态路由参数的模式进行路由匹配</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;routes: [<span class="hljs-comment">//动态路径参数以冒号开头</span>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: User &#125;&#125;)<span class="hljs-keyword">const</span> User = &#123;<span class="hljs-comment">// 路由组件中通过$route.params获取路由参数</span>template: <span class="hljs-string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span>&#125;</code></pre><h4 id="路由组件传递参数"><a href="#路由组件传递参数" class="headerlink" title="路由组件传递参数"></a><strong>路由组件传递参数</strong></h4><p>$route与对应路由形成高度耦合，不够灵活，所以可以使用props将组件和路由解耦</p><ol><li> <strong>props的值为布尔类型</strong></li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> router =<span class="hljs-keyword">new</span> VueRouter(&#123;routes: [<span class="hljs-comment">//如果props 被设置为true，route.params将会被设置为组件属性</span>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: User, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> &#125;]&#125;)<span class="hljs-keyword">const</span> User = &#123;props: [<span class="hljs-string">&#x27;id&#x27;</span>], <span class="hljs-comment">// 使用props接收路由参数</span>template: <span class="hljs-string">&#x27;&lt;div&gt;用户ID: &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span> <span class="hljs-comment">// 使用路由参数</span>&#125;</code></pre><ol start="2"><li><strong>props的值为对象类型</strong></li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> vueRouter (&#123;routes: [<span class="hljs-comment">//如果props 是一个对象，它会被按原样设置为组件属性</span> &#123;      path: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-attr">component</span>: User,     props: &#123; <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>&#125;    &#125; ]&#125;)<span class="hljs-keyword">const</span> User = &#123;props:[<span class="hljs-string">&#x27;uname&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>],template: <span class="hljs-string">&#x27;&lt;div&gt;用户信息:&#123;&#123; uname + &#x27;</span>---<span class="hljs-string">&#x27; + age&#125; &#125;&lt;/div&gt;&#x27;</span>&#125;</code></pre><ol start="3"><li><strong>props的值为函数类型（本质是就是返回了一个对象，里面有params上定义的值）</strong></li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> router =<span class="hljs-keyword">new</span> VueRouter ( &#123;routes: [<span class="hljs-comment">// 如果props是一个函数，则这个函数接收route对象为自己的形参</span>&#123;    path: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,component: User,props: <span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> (&#123; <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">id</span>: route.params.id &#125;)  &#125;  ]&#125;)<span class="hljs-keyword">const</span> User = &#123;props:[ <span class="hljs-string">&#x27;uname &#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> , <span class="hljs-string">&#x27;id&#x27;</span>],template: <span class="hljs-string">&#x27;&lt;div&gt;用户信息:&#123; uname + &#x27;</span>---<span class="hljs-string">&#x27; + age + &#x27;</span>---<span class="hljs-string">&#x27; + id&#125; &#125;&lt;/div&gt;&#x27;</span>&#125;</code></pre><h3 id="vue-router编程式导航"><a href="#vue-router编程式导航" class="headerlink" title="vue-router编程式导航"></a><strong>vue-router编程式导航</strong></h3><h4 id="页面导航的两种方式"><a href="#页面导航的两种方式" class="headerlink" title="页面导航的两种方式"></a><strong>页面导航的两种方式</strong></h4><p><strong>声明式导航：</strong>通过<strong>点击链接</strong>实现导航的方式，叫做声明式导航</p><p>例如：普通网页中的&lt;a&gt;&lt;/a&gt;链接或vue中的&lt;router-link&gt;&lt;/router-link&gt;</p><p><strong>编程式导航：</strong>通过<strong>调用JavaScript</strong>形式的API实现导航的方式，叫做编程式导航</p><p>例如：普通网页中的location.href</p><h4 id="编程式导航基本用法"><a href="#编程式导航基本用法" class="headerlink" title="编程式导航基本用法"></a><strong>编程式导航基本用法</strong></h4><p>常用的编程式导航API如下：</p><ul><li><p>  <strong>this.$router.push(‘hash地址’)</strong></p></li><li><p>  <strong>this.$router.go(n)</strong></p></li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;template: <span class="hljs-string">&#x27;&lt;div&gt;&lt;button click=&quot;goRegister&quot;&gt;跳转到注册页面&lt;/button&gt;&lt;/div&gt;&#x27;</span>，methods: &#123;goRegister: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//用编程的方式控制路由跳转</span><span class="hljs-built_in">this</span>.$router.push ( <span class="hljs-string">&#x27;/register&#x27;</span> );    &#125;&#125;&#125;</code></pre><h4 id="编程式导航参数规则"><a href="#编程式导航参数规则" class="headerlink" title="编程式导航参数规则"></a><strong>编程式导航参数规则</strong></h4><p><strong>router.push()方法的参数规则</strong></p><pre><code class="hljs js"><span class="hljs-comment">// 字符串(路径名称)</span>router.push (<span class="hljs-string">&#x27;/home&#x27;</span>)<span class="hljs-comment">// 对象</span>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span> &#125;)<span class="hljs-comment">// 命名的路由(传递参数)</span>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-number">123</span> &#125;&#125;)<span class="hljs-comment">// 带查询参数，变成/register?uname=lisi</span>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;lisi&#x27;</span> &#125;&#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化笔记</title>
    <link href="/2020/12/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/2020/12/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化概述"><a href="#模块化概述" class="headerlink" title="模块化概述"></a>模块化概述</h3><p><strong>传统开发模式的主要问题：</strong>1. 命名冲突 2. 文件依赖</p><p><strong>通过模块化解决上述问题</strong></p><ul><li><p>  <strong>模块化</strong>就是把单独的一个功能封装到一个模块（文件）中，模块之间相互隔离，但是可以通过特定的接口公开内部成员，也可以依赖别的模块</p></li><li><p>  模块化开发的好处：方便代码的重用，从而提升开发效率，并且方便后期的维护</p></li></ul><h3 id="浏览器端的模块化（了解）"><a href="#浏览器端的模块化（了解）" class="headerlink" title="浏览器端的模块化（了解）"></a>浏览器端的模块化（了解）</h3><p>1).AMD(Asynchronous Module Definition,异步模块定义)</p><p>代表产品为：Require.js</p><p>2).CMD(Common Module Definition,通用模块定义)</p><p>代表产品为：Sea.js</p><h3 id="服务器端模块化规范"><a href="#服务器端模块化规范" class="headerlink" title="服务器端模块化规范"></a>服务器端模块化规范</h3><p><strong>1. CommonJS</strong></p><ol><li><p> 模块分为<strong>单文件模块</strong>与<strong>包</strong></p></li><li><p> 模块成员导出：<strong>module.exports</strong> 和 <strong>exports</strong></p></li><li><p> 模块成员导入：<strong>require（’模块标识符’）</strong></p></li></ol><p><strong>2. ES6模块化</strong></p><ol><li><p> 每一个js文件都是独立的模块</p></li><li><p> <strong>导入模块成员</strong>使用<strong>import</strong>关键字</p></li><li><p> <strong>暴露模块成员</strong>使用<strong>export</strong>关键字</p></li></ol><p>小结：推荐使用ES6模块化，因为AMD，CMD局限使用与浏览器端，而CommonJS在服务器端使用。<strong>ES6模块化是浏览器端和服务器端通用的规范。</strong></p><p>使用</p><p>Node.js中通过<strong>babel（语法转换工具）</strong>体验ES6模块化</p><ol><li><p>npm install –save-dev @babel/core @babel/cli @babel/preset-env<br> @babel/node</p></li><li><p> npm install –save @babel/polyfill</p></li><li><p> 项目根目录创建babel.config.js</p></li><li><p> babel.config.js文件内容如下</p></li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> presets = [[<span class="hljs-string">&quot;@babel/env&quot;</span>, &#123;targets: &#123;edge: <span class="hljs-string">&quot;17&quot;</span>,firefox: <span class="hljs-string">&quot;60&quot;</span>,chrome: <span class="hljs-string">&quot;67&quot;</span>,safari: <span class="hljs-string">&quot;11.1&quot;</span>&#125;&#125;]]<span class="hljs-built_in">module</span>.exports = &#123; presets &#125;</code></pre><ol><li><p> 在项目目录中创建index.js文件作为入口文件，在index.js中输入需要执行的js代码</p></li><li><p> 通过npx babel-node ./index.js执行代码</p></li></ol><h3 id="ES6模块化的基本用法"><a href="#ES6模块化的基本用法" class="headerlink" title="ES6模块化的基本用法"></a>ES6模块化的基本用法</h3><ol><li> <strong>默认导入与导出</strong></li></ol><ul><li><p>  默认导出语法<strong>export default</strong> 默认导出的成员</p></li><li><p>  默认导入语法 <strong>import</strong> 接收名称<strong>from</strong> ‘模块标识符’</p></li></ul><pre><code class="hljs js"><span class="hljs-comment">// 当前文件模块为m1.js</span><span class="hljs-comment">// 定义私有成员a和c</span><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><span class="hljs-keyword">let</span> c = <span class="hljs-number">20</span><span class="hljs-comment">// 外界访问不到变量d， 因为它没有被暴露出去</span><span class="hljs-keyword">let</span> d = <span class="hljs-number">30</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-comment">// 将本模块中的私有成员暴露出去，供其他模块使用</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;a,c,show&#125;==================<span class="hljs-comment">// 导入模块成员</span><span class="hljs-keyword">import</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./m1.js&#x27;</span><span class="hljs-built_in">console</span>.log(m1)<span class="hljs-comment">// 打印输出的结果为：</span><span class="hljs-comment">// &#123; a: 10, c: 20, show: [Function: show] &#125;</span></code></pre><p><strong>注意：</strong>每个模块中，只允许使用<strong>唯一的一次</strong> export default，否则会报错！</p><p>导入空的模块不会报错</p><ol start="2"><li><strong>按需导入与按需导出</strong></li></ol><p>按需导出语法 export let s1 = 10</p><p>按需导入语法 import {s1} from ‘模块标识符’</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/9787491b049be2e68d06dd673a68f9e9.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/c6a2aa45c45593ec077deb79c6fc1d4f.png"></p><p>注意：每个模块中，可以使用<strong>多次</strong>按需导出</p><ol start="3"><li><strong>直接导入并执行模块代码</strong></li></ol><p>应用场景：<strong>只想单纯执行某个模块中的代码，并不需要得到模块中向外暴露的成员。</strong></p><p>import “./test.js”</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>webpack</strong>是一个流行的<strong>前端项目构建工具（打包工具）</strong>，可以解决当前web开发中所面临的困境。</p><p>webpack提供了<strong>友好的模块化支持</strong>，以及<strong>代码压缩混淆</strong>、<strong>处理js兼容问题</strong>、<strong>性能优化</strong>等强大的功能，从而让程序员把工作的重心放在具体的功能实现上，提高了开发的效率和项目的可维护性。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/dbad678564244ec4b2832eee8bdf1240.png"></p><h3 id="webpack的基本使用"><a href="#webpack的基本使用" class="headerlink" title="webpack的基本使用"></a>webpack的基本使用</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol><li><p> 打开项目目录终端，输入命令:npm install <strong>webpack webpack-cli</strong> -D 安装</p></li><li><p> 然后在项目根目录中，创建一个 <strong>webpack.config.js</strong> 的配置文件用来配置webpack</p></li><li><p> 在 webpack.config.js 文件中编写代码进行webpack配置，如下：</p></li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/bd7c5006c7ed18a4c17fb029bf28ec47.png"></p><p>补充：<strong>mode设置的是项目的编译模式</strong>。</p><p>如果设置为<strong>development</strong>则表示项目处于开发阶段，不会进行压缩和混淆，打包速度会快一些</p><p>如果设置为<strong>production</strong>则表示项目处于上线发布阶段，会进行压缩和混淆，打包速度会慢一些</p><ol start="4"><li>修改项目中的package.json文件添加运行脚本dev，如下：</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/698b0630a64e50b3443e4b84b5b1e43e.png"></p><ol start="5"><li><p>运行终端命令：<strong>npm run dev</strong>，将会启动webpack进行项目打包</p></li><li><p>等待webpack打包完毕之后，找到默认的dist路径中生成的main.js文件，将其引入到html页面中。</p></li></ol><h4 id="配置打包入口与出口"><a href="#配置打包入口与出口" class="headerlink" title="配置打包入口与出口"></a>配置打包入口与出口</h4><p>webpack的4.x版本中默认约定：</p><ul><li><p>  打包的<strong>入口文件</strong>为src -&gt; index.js</p></li><li><p>  打包的<strong>输出文件</strong>为dist -&gt; main.js</p></li></ul><p>如果要修改打包的入口与出口，可以在webpack.config.js中新增如下配置信息：</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/0849d34474bf0dfbb0b836d0d449efcc.png"></p><h4 id="配置webpack的自动打包功能"><a href="#配置webpack的自动打包功能" class="headerlink" title="配置webpack的自动打包功能"></a>配置webpack的自动打包功能</h4><p>默认情况下，我们更改入口js文件的代码，需要重新运行命令打包webpack，才能生成出口的js文件，那么每次都要重新执行命令打包，这是一个非常繁琐的事情，那么，自动打包可以解决这样繁琐的操作。</p><p><strong>实现自动打包功能的步骤如下：</strong></p><ol><li> 安装自动打包功能的包:webpack-dev-server</li></ol><p><strong>npm install webpack-dev-server -D</strong></p><ol start="2"><li>修改package.json中的dev指令如下：</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/5c5f2c2f8bf195e23e6a7da588d59728.png"></p><ol start="3"><li><p>将引入的js文件路径更改为：&lt;script src=”/bundle.js”&gt;&lt;/script&gt;</p></li><li><p>运行npm run dev，进行打包</p></li><li><p>打开网址查看效果：<a href="http://localhost:8080/">http://localhost:8080</a></p></li></ol><p><strong>注意：</strong>webpack-dev-server自动打包的输出文件，默认放到了服务器的根目录中.</p><p>补充：设置自定义服务器</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/f245c67f13cb3fdf4fd1fbd2ccf64fe8.png"></p><p><strong>配置html-webpack-plugin生成预览页面</strong></p><p>因为当我们访问默认的<br><a href="http://localhost:8080/%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%9C%8B%E5%88%B0%E7%9A%84%E6%98%AF%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E6%83%B3%E8%A6%81%E6%9F%A5%E7%9C%8B%E6%88%91%E4%BB%AC%E7%9A%84%E9%A1%B5%E9%9D%A2%E8%BF%98%E9%9C%80%E8%A6%81%E7%82%B9%E5%87%BB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%82%B9%E5%87%BB%E6%96%87%E4%BB%B6%E6%89%8D%E8%83%BD%E6%9F%A5%E7%9C%8B%EF%BC%8C%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E9%BB%98%E8%AE%A4%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9C%8B%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E6%88%96%E8%80%85%E7%9B%AE%E5%BD%95%E3%80%82">http://localhost:8080/的时候，看到的是一些文件和文件夹，想要查看我们的页面还需要点击文件夹点击文件才能查看，那么我们希望默认就能看到一个页面，而不是看到文件夹或者目录。</a></p><ol><li> 安装默认预览功能的包:html-webpack-plugin</li></ol><p><strong>npm install html-webpack-plugin -D</strong></p><ol start="2"><li>修改webpack.config.js文件，如下：</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/1bbec5f75cf5427f66037b2670925be0.png"></p><ol start="3"><li>继续修改webpack.config.js文件，添加plugins信息：</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/c773c3c2916d862aced362da25bc638c.png"></p><h2 id="webpack中的加载器"><a href="#webpack中的加载器" class="headerlink" title="webpack中的加载器"></a>webpack中的加载器</h2><h3 id="通过loader打包非JS模块"><a href="#通过loader打包非JS模块" class="headerlink" title="通过loader打包非JS模块"></a>通过loader打包非JS模块</h3><p>默认情况下，webpack只能打包js文件，如果想要打包非js文件，<strong>需要调用loader加载器才能打包</strong></p><p>loader加载器可以协助webpack打包处理特定的文件模块，比如：</p><ol><li><p> less-loader 可以打包处理 .less相关的文件</p></li><li><p> sass-loader 可以打包处理 .sass相关的文件</p></li><li><p> url-loader:打包处理css中与url路径有关的文件</p></li><li><p> babel-loader:处理高级js语法的加载器</p></li><li><p> postcss-loader</p></li><li><p> css-loader,style-loader 处理css文件</p></li></ol><h3 id="loader的调用过程"><a href="#loader的调用过程" class="headerlink" title="loader的调用过程"></a>loader的调用过程</h3><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/a275d5731b8b8fabd6467931c46475e0.png"></p><h3 id="webpack中加载器的基本使用"><a href="#webpack中加载器的基本使用" class="headerlink" title="webpack中加载器的基本使用"></a>webpack中加载器的基本使用</h3><ol><li><p><strong>打包处理css文件</strong></p><ul><li><p>运行<strong>npm i style-loader css-loader -D</strong>命令，安装处理css文件的loader</p></li><li><p>在webpack.config.js的<strong>module -&gt; rules</strong> 数组中，添加loader规则如下：</p></li></ul></li></ol><pre><code class="hljs js"><span class="hljs-comment">//所有第三方文件模块的匹配规则</span><span class="hljs-built_in">module</span>: &#123;rules: [&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>, use: [ <span class="hljs-string">&#x27; style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span> ] &#125;]&#125;</code></pre><p>其中，<strong>test</strong>表示匹配的文件类型，<strong>use</strong>表示对应要调用的loader</p><p><strong>注意：</strong></p><ul><li><p>  use数组中指定的loader顺序是固定的</p></li><li><p>  多个loader的调用顺序是：从后往前调用</p></li></ul><ol start="2"><li><strong>打包处理less文件</strong></li></ol><ul><li><p>运行<strong>npm i less-loader less -D</strong> 命令</p></li><li><p>在webpack.config.js的module-&gt;rules 数组中，添加loader规则如下：</p></li></ul><pre><code class="hljs js"><span class="hljs-comment">//所有第三方文件模块的匹配规则</span><span class="hljs-built_in">module</span>: &#123;rules: [&#123; <span class="hljs-attr">test</span>:<span class="hljs-regexp">/.less$/</span>,use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>， <span class="hljs-string">&#x27;less-loader&#x27;</span> ]&#125;]&#125;</code></pre><ol start="3"><li><strong>打包处理sc ss文件</strong></li></ol><ul><li><p>运行<strong>npm i sass-loader node-sass -D</strong>命令</p></li><li><p>在webpack.config.js的<strong>module</strong>-&gt;<strong>rules</strong>数组中，添加loader规则如下：</p></li></ul><pre><code class="hljs js"><span class="hljs-comment">//所有第三方文件模块的匹配规则</span><span class="hljs-built_in">module</span>: &#123;rules: [&#123; test: <span class="hljs-regexp">/\.scss$/</span>,use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]&#125;]&#125;</code></pre><ol start="4"><li><strong>配置postCSS自动添加css的兼容前缀</strong></li></ol><ul><li><p>运行<strong>npm i postcss-loader autoprefixer -D</strong> 命令</p></li><li><p>在项目根目录中创建postcss的配置文件postcss.config.js，并初始化如下配置：</p></li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> autoprefixer = <span class="hljs-built_in">require</span> ( <span class="hljs-string">&#x27;autoprefixer&#x27;</span>) <span class="hljs-comment">//导入自动添加前缀的插件</span><span class="hljs-built_in">module</span>.exports = &#123;plugins: [ autoprefixer ] <span class="hljs-comment">//挂载插件</span>&#125;</code></pre><ul><li>在webpack.config.js的<strong>module-&gt;rules</strong>数组中，修改css的loader规则如下：</li></ul><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;rules: [&#123; test: <span class="hljs-regexp">/\.css$/</span>,use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>]&#125;]&#125;</code></pre><ol start="5"><li><strong>打包样式表中的图片和字体文件</strong><ul><li>运行<strong>npm i url-loader file-loader -D</strong>命令</li><li>在webpack.config.js的<strong>module-&gt;rules</strong>数组中，添加loader规则如下：</li></ul></li></ol><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;rules: [&#123;test: <span class="hljs-regexp">/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/</span>,use: <span class="hljs-string">&quot;url-loader?limit=16940&quot;</span>&#125;]&#125;</code></pre><p>其中?之后的是loader的<strong>参数项</strong></p><p>limit用来指定图片的大小，单位是字节（byte），只有小于limit大小的图片，才会被转为base64图片</p><ol start="6"><li><strong>打包处理js文件中的高级语法</strong></li></ol><ul><li>安装babel转换器</li></ul><p>npm install babel-loader @babel/core @babel/runtime -D</p><ul><li>安装babel语法插件包</li></ul><p>npm install @babel/preset-env @babel/plugin-transform-runtime<br>@babel/plugin-proposal-class-properties -D</p><ul><li>在项目根目录创建并配置babel.config.js文件</li></ul><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;presets: [ <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span> ],plugins: [ <span class="hljs-string">&#x27; babel/plugin-transform-runtime&#x27;</span>, <span class="hljs-string">&#x27;@babel/plugin-proposal-</span><span class="hljs-string">class-properties&#x27;</span>]&#125;</code></pre><ul><li>在webpack.config.js的module-&gt;rules数组中，添加loader规则如下：</li></ul><pre><code class="hljs js"><span class="hljs-comment">// exclude为排除项，表示babel-loader不需要处理node_modules中的js 文件</span>&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>, use: <span class="hljs-string">&#x27;babel-loader&#x27;</span>, <span class="hljs-attr">exclude</span>: /node_modulesl &#125;</code></pre><h2 id="Vue单文件组件"><a href="#Vue单文件组件" class="headerlink" title="Vue单文件组件"></a>Vue单文件组件</h2><h3 id="传统组件的问题和解决方案"><a href="#传统组件的问题和解决方案" class="headerlink" title="传统组件的问题和解决方案"></a>传统组件的问题和解决方案</h3><ul><li>  <strong>传统Vue组件的缺陷：</strong></li></ul><ol><li><p> 全局定义的组件不能重名</p></li><li><p> 字符串模板缺乏语法高亮</p></li><li><p> 不支持css(当html和js组件化时，css没有参与其中)</p></li><li><p> 没有构建步骤限制，只能使用H5和ES5，不能使用预处理器（babel）</p></li></ol><ul><li>  <strong>解决方案：</strong></li></ul><p>使用Vue单文件组件，每个单文件组件的后缀名都是.vue</p><h3 id="Vue单文件组件的基本用法"><a href="#Vue单文件组件的基本用法" class="headerlink" title="Vue单文件组件的基本用法"></a>Vue单文件组件的基本用法</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>这里用于定义vue组件的模板内容<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> <span class="hljs-comment">// 这里用于定义vue组件的业务逻辑</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="javascript">data:  &#123; <span class="hljs-keyword">return</span> &#123;&#125; &#125;,<span class="hljs-comment">//私有数据</span></span><span class="javascript">methods: &#123;&#125; <span class="hljs-comment">//处理函数</span></span><span class="javascript"><span class="hljs-comment">// ...其它业务逻辑</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css"><span class="hljs-comment">/*这里用于定义组件的样式*/</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><h3 id="单文件组件的组成结构"><a href="#单文件组件的组成结构" class="headerlink" title="单文件组件的组成结构"></a>单文件组件的组成结构</h3><ul><li><p>  <strong>template</strong> 组件的模板区域</p></li><li><p>  <strong>script</strong> 业务逻辑区域</p></li><li><p>  <strong>style</strong> 样式区域（scoped防止样式冲突）</p></li></ul><h3 id="webpack中配置vue组件的加载器"><a href="#webpack中配置vue组件的加载器" class="headerlink" title="webpack中配置vue组件的加载器"></a>webpack中配置vue组件的加载器</h3><ol><li><p> 运行<strong>npm i vue-loader vue-template-compiler -D</strong>命令</p></li><li><p> 在webpack.config.js配置文件中，添加vue-loader的配置项如下：</p></li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> VueLoaderPlugin = <span class="hljs-built_in">require</span> ( <span class="hljs-string">&#x27;vue-loader/lib/plugin&#x27;</span>)<span class="hljs-built_in">module</span>.exports = &#123;<span class="hljs-built_in">module</span>: &#123;rules: [<span class="hljs-comment">// ...其它规则</span>&#123; <span class="hljs-attr">test</span>: l.vue$l , <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;vue-loader&#x27;</span>&#125;&#125;,plugins: [<span class="hljs-comment">// ...其它插件</span><span class="hljs-keyword">new</span> vueLoaderPlugin() <span class="hljs-comment">// 请确保引入这个插件!</span>  ]&#125;</code></pre><h3 id="在webpack项目中使用vue"><a href="#在webpack项目中使用vue" class="headerlink" title="在webpack项目中使用vue"></a><strong>在webpack项目中使用vue</strong></h3><ol><li><p> 运行npm i vue -S 安装vue</p></li><li><p> 在src-&gt;index.js入口文件中，通过<strong>import Vue from ‘vue’</strong> 来导入vue构造函数</p></li><li><p> 创建vue的实例对象，并指定要控制的el区域</p></li><li><p> 通过render函数渲染App根组件</p></li></ol><pre><code class="hljs js"><span class="hljs-comment">// 1．导入vue 构造函数</span><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-comment">// 2．导入App根组件</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/App.vue&#x27;</span><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> vue (&#123;<span class="hljs-comment">// 3．指定vm实例要控制的页面区域</span>el: <span class="hljs-string">&#x27;#app&#x27;</span>,<span class="hljs-comment">// 4．通过render函数，把指定的组件渲染到el区域中</span>render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h (App)&#125;)</code></pre><h3 id="webpack打包发布"><a href="#webpack打包发布" class="headerlink" title="webpack打包发布"></a><strong>webpack打包发布</strong></h3><p>上线之前需要通过webpack将应用进行整体打包，可以通过package.json文件配置打包命令：（在项目打包之前，可以将dist目录删除，生成全新的dist目录）</p><pre><code class="hljs js"><span class="hljs-comment">// 在package.json文件中配置webpack打包命令</span><span class="hljs-comment">// 该命令默认加载项目根目录中的webpack.config.js配置文件</span><span class="hljs-string">&quot;scripts&quot;</span> : &#123;<span class="hljs-comment">// 用于打包的命令</span><span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack -p&quot;</span>,<span class="hljs-comment">// 用于开发调试的命令</span><span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open --host 127.0.0.1 --port 3000&quot;</span>,&#125;</code></pre><h2 id="Vue脚手架"><a href="#Vue脚手架" class="headerlink" title="Vue脚手架"></a><strong>Vue脚手架</strong></h2><h3 id="Vue脚手架的基本用法"><a href="#Vue脚手架的基本用法" class="headerlink" title="Vue脚手架的基本用法"></a><strong>Vue脚手架的基本用法</strong></h3><p>Vue脚手架可以<strong>快速生成Vue项目基础的架构</strong>。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a><strong>使用步骤</strong></h3><ol><li><p> 安装2.x版本的Vue脚手架：</p></li><li><p> <strong>npm install -g @vue/cli</strong></p></li><li><p> <strong>基于2.x版本的脚手架创建vue项目</strong></p></li></ol><pre><code class="hljs js"><span class="hljs-comment">// 1．基于交互式命令行的方式，创建新版vue项目</span>vue create my-project<span class="hljs-comment">// 2．基于图形化界面的方式，创建新版vue项目</span>vue ui<span class="hljs-comment">// 3．基于2.x的旧模板，创建旧版vue项目</span>npm install -g @vue/cli-initvue init webpack my-project</code></pre><h3 id="Vue脚手架生成项目的结构分析"><a href="#Vue脚手架生成项目的结构分析" class="headerlink" title="Vue脚手架生成项目的结构分析"></a><strong>Vue脚手架生成项目的结构分析</strong></h3><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/webpack/9472017747775edca8c69d165d4f2b60.png"></p><h3 id="Vue脚手架自定义配置"><a href="#Vue脚手架自定义配置" class="headerlink" title="Vue脚手架自定义配置"></a><strong>Vue脚手架自定义配置</strong></h3><ol><li> <strong>通过package.json配置项目（不推荐使用）</strong></li></ol><pre><code class="hljs js"><span class="hljs-comment">// 必须是符合规范的json语法</span><span class="hljs-string">&quot;vue&quot;</span>: &#123;<span class="hljs-string">&quot;devserver&quot;</span> : &#123;<span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;8888&quot;</span>,<span class="hljs-string">&quot;open&quot;</span> : <span class="hljs-literal">true</span>&#125;</code></pre><p>post：端口号 open：打包成功后自动打开浏览器</p><ol><li><p> <strong>通过单独的配置文件配置项目</strong></p></li><li><p> 在项目的根目录创建文件<strong>vue.config.js</strong></p></li><li><p> 在该文件中进行相关配置，从而覆盖默认配置</p></li></ol><pre><code class="hljs js"><span class="hljs-comment">// vue.config.js</span><span class="hljs-built_in">module</span>.exports = &#123;devserver: &#123;port: <span class="hljs-number">8888</span>  &#125;&#125;</code></pre><h2 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element-UI"></a><strong>Element-UI</strong></h2><p><strong>Element-UI</strong>:一套基于2.0的<strong>桌面端组件库</strong></p><ol><li><p><strong>基于命令行方式手动安装</strong></p><ul><li><p>安装依赖包 <strong>npm i element-ui -S</strong></p></li><li><p>导入Element-UI相关资源</p></li></ul></li></ol><pre><code class="hljs js"><span class="hljs-comment">// 导入组件库</span><span class="hljs-keyword">import</span> ElementuI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<span class="hljs-comment">// 导入组件相关样式</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<span class="hljs-comment">// 配置Vue插件</span>Vue.use(ElementUI);</code></pre><p><strong>2. 基于图形化界面自动安装</strong></p><ul><li><p>运行<strong>vue ui</strong>命令，打开图形化界面</p></li><li><p>通过<strong>Vue项目管理器</strong>，进入具体的项目配置面板</p></li><li><p>点击<strong>插件-》添加插件</strong>，进入插件查询面板</p></li><li><p>搜索<strong>vue-cli-plugin-element</strong>并安装</p></li><li><p>配置插件，实现按需导入，从而减少打包后项目的体积</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git笔记</title>
    <link href="/2020/12/18/git/"/>
    <url>/2020/12/18/git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>版本管理是一种记录文件变化的方式，以便将来查询特定版本的文件内容。</p><h2 id="人为维护文档版本的问题"><a href="#人为维护文档版本的问题" class="headerlink" title="人为维护文档版本的问题"></a>人为维护文档版本的问题</h2><ol><li><p> 文档数量多且命名不清晰导致文档版本混乱</p></li><li><p> 每次编辑文档需要复制</p></li><li><p> 多人同时编辑同一个文档，容易产生覆盖</p></li></ol><h2 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h2><p>Git是一个版本管理控制系统，它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/cb0b070d48d97cba50f1145cfc4cb158.png"></p><h2 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/a1a2a7c46e10f4ece25c9c43271d09dd.png"></p><h2 id="Git使用前配置"><a href="#Git使用前配置" class="headerlink" title="Git使用前配置"></a>Git使用前配置</h2><p>在使用git前，需要告诉git你是谁，再向git仓库中提交时需要用到。</p><p>配置提交人姓名：git config –global user.name 提交人姓名</p><p>配置提交人邮箱：git config –global user.email 提交人邮箱</p><p>查看git配置信息</p><p>注意</p><ol><li><p> 如果要对配置信息进行修改，重复上述命令即可。</p></li><li><p> 配置只需要执行一次。</p></li></ol><h2 id="提交步骤"><a href="#提交步骤" class="headerlink" title="提交步骤"></a>提交步骤</h2><ol><li><p> <strong>`git init`</strong> 初始化git仓库</p></li><li><p> <strong>`git status`</strong> 查看文件状态</p></li><li><p> **`git add** 文件列表` 追踪文件</p></li><li><p> **`git commit -m** 提交信息` 向仓库中提交代码</p></li><li><p> <strong>`git log`</strong> 查看提交记录</p></li></ol><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>用暂存区中的文件覆盖工作目录中的文件：<strong>`git checkout 文件`</strong></p><p>- 将文件从暂存区中删除：<strong>`git rm –cached文件`</strong></p><p>- 将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：<strong>`git rest<br>–hard commitID`</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/3ec1b86c73438b0ff3d3c8a6a20e2a67.png"></p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本。</p><p>使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/481fffdb6b654025ea6c1c2c49fd27f3.png"></p><h3 id="分支细分"><a href="#分支细分" class="headerlink" title="分支细分"></a>分支细分</h3><ol><li>主分支（master）：第一次向 git 仓库中提交更新记录时自动产生的一个分支。</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/b666c4d98f8bfb5bdf661741c9ee0616.png"></p><ol start="2"><li>、开发分支（develop）：作为开发的分支，基于 master 分支创建。</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/8068cf60bb105e3d029e324fde35a894.png"></p><ol start="3"><li>功能分支（feature）：作为开发具体功能的分支，基于开发分支创建</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/da62ac4baa44ce986ec8a8e89d487317.png"></p><p><strong>功能分支 -&gt; 开发分支 -&gt; 主分支</strong></p><h3 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h3><p><strong>`git branch`</strong> 查看分支</p><p><strong>`git branch 分支名称`</strong> 创建分支</p><p><strong>`git checkout 分支名称`</strong> 切换分支</p><p><strong>`git merge 来源分支`</strong> 合并分支</p><p><strong>`git branch -d 分支名称`</strong> 删除分支（分支被合并后才允许删除）（-D 强制删除）</p><p>注意：<strong>切换分支前要先提交</strong></p><p><strong>暂时保存更改</strong></p><p>在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。</p><p>使用场景：分支临时切换</p><p>存储临时改动：<strong>`git stash`</strong></p><p>恢复改动：<strong>`git stash pop`</strong></p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="多人协作开发流程"><a href="#多人协作开发流程" class="headerlink" title="多人协作开发流程"></a>多人协作开发流程</h2><p>- A在自己的计算机中创建本地仓库</p><p>- A在github中创建远程仓库</p><p>- A将本地仓库推送到远程仓库</p><p>- B克隆远程仓库到本地进行开发</p><p>- B将本地仓库中开发的内容推送到远程仓库</p><p>- A将远程仓库中的最新内容拉去到本地</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/72dd3372edf4604c8490ae03c55a9611.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/c6ec1f25e658c5b9276e652f0ee24c97.png"></p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>填写仓库基本信息</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/8f55fee198e48647826b8bb682abae8c.png"></p><ol start="2"><li>将本地仓库推送到远程仓库</li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/c396fbe686fe99709fd8610685085bfc.png"></p><ol><li><p>git push 远程仓库地址 分支名称</p></li><li><p>git push 远程仓库地址别名 分支名称</p></li><li><p>git push -u 远程仓库地址别名 分支名称</p></li></ol><p><strong>-u 记住推送地址及分支，下次推送只需要输入git push即可</strong></p><ol start="4"><li>git remote add 远程仓库地址别名 远程仓库地址</li></ol><p>例：起别名：<strong>git remote add origin 远程仓库地址</strong></p><h2 id="拉取操作"><a href="#拉取操作" class="headerlink" title="拉取操作"></a>拉取操作</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>克隆远端数据仓库到本地：<strong>`git clone 仓库地址`</strong></p><h3 id="拉取远程仓库中最新的版本"><a href="#拉取远程仓库中最新的版本" class="headerlink" title="拉取远程仓库中最新的版本"></a>拉取远程仓库中最新的版本</h3><p>拉取远程仓库中最新的版本：<strong>`git pull 远程仓库地址 分支名称`</strong></p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。<strong>冲突需要人为解决</strong>。</p><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><ol><li><p>程序员 C fork仓库</p></li><li><p>程序员 C 将仓库克隆在本地进行修改</p></li><li><p>程序员 C 将仓库推送到远程</p></li><li><p>程序员 C 发起pull reqest</p></li><li><p>原仓库作者审核</p></li><li><p>原仓库作者合并代码</p></li></ol><h3 id="ssh免登陆"><a href="#ssh免登陆" class="headerlink" title="ssh免登陆"></a>ssh免登陆</h3><p>https协议仓库地址：<a href="https://github.com/itcast-frontEnd/git-demo.git">https://github.com/itcast-frontEnd/git-demo.git</a></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/3d0f1dbc61fcb18cd1a614d216767a71.png"></p><p>生成秘钥：`ssh-keygen`</p><p>秘钥存储目录：C:\Users\用户\\.ssh</p><p>公钥名称：id_rsa.pub</p><p>私钥名称：id_rsa</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/5df2d5f4ad2fa2d5ecec0a1b2a0abd39.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/git/6af2cf3b794d9e52fd299ba4839e72af.png"></p><h2 id="GIT忽略清单"><a href="#GIT忽略清单" class="headerlink" title="GIT忽略清单"></a>GIT忽略清单</h2><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。</p><p>git忽略清单文件名称：**.gitignore**</p><p>将工作目录中的文件全部添加到暂存区：<strong>`git add .`</strong></p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB笔记</title>
    <link href="/2020/12/18/MongoDB%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/18/MongoDB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库概述及环境搭建"><a href="#数据库概述及环境搭建" class="headerlink" title="数据库概述及环境搭建"></a>数据库概述及环境搭建</h1><h2 id="为什么要做数据库？"><a href="#为什么要做数据库？" class="headerlink" title="为什么要做数据库？"></a>为什么要做数据库？</h2><ul><li><p>  动态网站中的数据都是存储在数据库中的</p></li><li><p>  数据库可以用来持久存储客户端通过表单收集的用户信息</p></li><li><p>  数据库软件本身可以对数据进行高效的管理</p></li></ul><h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>数据库即存储数据的仓库，可以将数据进行有序的分门别类的存储。它是独立于语言之外的软件，可以通过API去操作它。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/mongo/4a8f128b0daeb3e088336a1c15c3b800.png"></p><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/mongo/294589b78616cdfb4aa210b654afd461.png"></p><h2 id="Mongoose-第三方包"><a href="#Mongoose-第三方包" class="headerlink" title="Mongoose 第三方包"></a>Mongoose 第三方包</h2><p>使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose</p><p>安装：npm install mongoose</p><h2 id="启动MongoDB"><a href="#启动MongoDB" class="headerlink" title="启动MongoDB"></a>启动MongoDB</h2><p>在命令行工具中运行<strong>net start mongoDB</strong>即可启动MongoDB，否则MongoDB将无法连接。</p><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>使用mongoose提供的<strong>connect</strong>方法即可连接数据库。</p><pre><code class="hljs js">mongoose.connect(<span class="hljs-string">&#x27;mongodb://localhost/playground&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;数据库连接成功&#x27;</span>)).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;数据库连接失败&#x27;</span>, err))</code></pre><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>在MongoDB中<strong>不需要显式创建数据库</strong>，如果正在使用的数据库不存在，<strong>MongoDB会自动创建</strong>。</p><h1 id="MongoDB增删改查操作"><a href="#MongoDB增删改查操作" class="headerlink" title="MongoDB增删改查操作"></a>MongoDB增删改查操作</h1><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>创建集合分为两布，一是<strong>对集合设定规则</strong>，二是<strong>创建集合</strong>，创建</p><p>mongoose.Schema构造函数的实例即可创建集合。</p><pre><code class="hljs js"><span class="hljs-comment">// 设定集合规则</span><span class="hljs-keyword">const</span> courseSchema = <span class="hljs-keyword">new</span> mongoose.Schema(&#123;name: <span class="hljs-built_in">String</span>,author: <span class="hljs-built_in">String</span>,isPublished: <span class="hljs-built_in">Boolean</span>&#125;)<span class="hljs-comment">// 创建集合并应用规则</span><span class="hljs-keyword">const</span> Course = mongoose.model(<span class="hljs-string">&#x27;Course&#x27;</span>, courseSchema) <span class="hljs-comment">// courses</span></code></pre><p><strong>model返回的是一个构造函数</strong></p><p>注意：</p><ol><li><p>创建集合中，<strong>集合名首字母必须是大写</strong>，但是在数据库中集合名首字母会变成小写并且末尾加s。</p></li><li><p>创建的集合必须加入数据才能在mongoDB中显示。</p></li></ol><h2 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h2><p>创建文档实际上就是<strong>向集合中插入数据。</strong></p><p>分两步：</p><ol><li><p> 创建集合实例。</p></li><li><p> 调用实例对象下的save方法将数据保存到数据库中。</p></li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> course = <span class="hljs-keyword">new</span> Course(&#123;name: <span class="hljs-string">&#x27;hello&#x27;</span>,author: <span class="hljs-string">&#x27;cat&#x27;</span>,tags: [<span class="hljs-string">&#x27;node&#x27;</span>, <span class="hljs-string">&#x27;mongodb&#x27;</span>],isPublished: <span class="hljs-literal">true</span>&#125;)course.save()</code></pre><p><strong>另一种方法</strong></p><p>运用集合下的create方法</p><p>集合构造函数.create( { 数据 }, (err, doc) =&gt; { //err：错误对象，doc：当前文档 });</p><pre><code class="hljs js">Course.create(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;javascript&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-attr">isPublish</span>: <span class="hljs-literal">true</span>&#125;, <span class="hljs-function">(<span class="hljs-params">err, doc</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 错误对象</span><span class="hljs-built_in">console</span>.log(err)  <span class="hljs-comment">// 当前插入的文档</span><span class="hljs-built_in">console</span>.log(doc)&#125;)</code></pre><p>create中有回调函数，说明是异步操作，同时它可以用then方法，也就是说它返回一个promise对象。</p><pre><code class="hljs js">Course.create(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;javascript&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-attr">isPublish</span>: <span class="hljs-literal">true</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">doc</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(doc)).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err))</code></pre><h2 id="mongoDB数据库导入数据"><a href="#mongoDB数据库导入数据" class="headerlink" title="mongoDB数据库导入数据"></a>mongoDB数据库导入数据</h2><p>mongoimport -d 数据库名称 -c 集合名称 –file 要导入的数据文件</p><p>找到mongodb数据库的安装目录，将安装目录下的bin目录放置在环境变量中。这也才可以使用mongoimport</p><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><ol><li><p> <strong>集合名.find().then(result=&gt;{}) 返回数组，里面是文档的集合</strong></p></li><li><p> <strong>findOne（）方法返回当前集合的第一条文档，是一个对象。</strong></p></li></ol><h3 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h3><ol><li> 括号中加<strong>对象</strong>来做查找条件</li></ol><p>例（{_id : ‘5c09f1e5aeb04b22f8460965’}）</p><ol start="2"><li>运用<strong>$gt(大于) $lt（小于）</strong>来做匹配查找，判断字段值是否在此区间</li></ol><p>例 ({age: {$gt: 20, $lt: 50} }).then()</p><ol start="3"><li>运用<strong>$in(包含)</strong> 来做匹配查找，找出文档的数组中是否包含的某一项</li></ol><p>例 （{hobbies：{$in: [‘敲代码’] } }.then()</p><ol start="4"><li>选择查询字段 <strong>运用select()方法</strong>，来显示查询字段数据 <strong>-字段名</strong>表示不查询</li></ol><p>例：find().select(‘name email’)</p><ol start="5"><li>运用sort（）方法，对查收文档进行排序, <strong>-字段名</strong>表示降序</li></ol><p>例：find().sort(‘age’).then()</p><ol start="6"><li>运用skip跳过多少条数据，limit限制查询数量</li></ol><p>例：find().skip(2).limit(2).then() // 跳过前两条数据，只查找两条数据</p><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><ol><li> 删除单个 <strong>findOneAndDelete</strong></li></ol><p>例：集合名.findOneAndDelete({}).then() //返回删除文档</p><ol start="2"><li>删除多个 <strong>delectMany</strong></li></ol><p>例：集合名.delectMany({}).then() //返回对象{ n: 2, ok: 1};<br>n代表受影响数量，ok代表成功。delectcount表示删除数</p><h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><ol><li> 更新一条 <strong>updateOne</strong></li></ol><p>例：集合名.updateOne( {条件}, {更新数据} ).then() //返回对象n和ok等</p><ol start="2"><li>更新多条 <strong>updateMany</strong></li></ol><p>例：集合名. updateMany( {条件}, {更新数据} ).then() //返回对象n 和ok等</p><h2 id="mongoose验证"><a href="#mongoose验证" class="headerlink" title="mongoose验证"></a>mongoose验证</h2><p>在创建集合规则时，可以设置当前字段的验证规则，验证失败就则输入插入失败。</p><ul><li>  require: true 设置为true是<strong>必传字段</strong>，不传会报错 <strong>可自定义错误信息</strong></li></ul><p>例：require: [ true, ‘请输入数据’ ]</p><ul><li><p>  type: 类型</p></li><li><p>  minlength: <strong>字符串最小长度 可自定义错误信息</strong></p></li><li><p>  maxlength：<strong>字符串最大长度 可自定义错误信息</strong></p></li><li><p>  trim：true 去除头尾空格</p></li><li><p>  min：<strong>数值的最小值 可自定义错误信息</strong></p></li><li><p>  max：<strong>数值的最大值 可自定义错误信息</strong></p></li><li><p>  default：<strong>默认值</strong>，不传入值将用默认值</p></li><li><p>enum：<strong>枚举</strong> 列举出当前字段可以拥有的值，没有就报错 可自定义错误信息</p><p>例：enum：[—-]</p><p>或</p><p> enum：{</p><p>​    values: [—-],</p><p>​    message: ‘自定义错误信息’</p><p>}</p></li><li><p>  validate：自定义验证器</p></li></ul><p>例：</p><p>validate：{</p><p>​            validator: v=&gt; {</p><p>​                    //返回布尔值 v是要验证的值</p><p>​                    return</p><p>​                },</p><p>​            //自定义错误信息message</p><p>​            message: ‘传入的值不符合验证规则’</p><p>}</p><h2 id="集合关联"><a href="#集合关联" class="headerlink" title="集合关联"></a>集合关联</h2><p>通常<strong>不同集合的数据之间是有关系的</strong>，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。</p><p>调用某文档id：mongoose.Schema.Types.ObjectId, ref: ‘User’(对应的数据库)</p><p><strong>populate方法：查询具体信息</strong></p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node笔记</title>
    <link href="/2020/12/16/Node%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/16/Node%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Node是什么"><a href="#Node是什么" class="headerlink" title="Node是什么"></a>Node是什么</h1><p><strong>Node</strong>是一个基于ChromeV8引擎的JavaScript<strong>代码运行环境</strong>。</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript的代码运行环境。</p><p>Node（软件）能够运行JavaScript代码，Node就是JavaScript的代码运行环境。</p><h1 id="Node-js的组成"><a href="#Node-js的组成" class="headerlink" title="Node.js的组成"></a>Node.js的组成</h1><p>Node.js是由<strong>ECMAScript</strong>及<strong>Node环境</strong>提供的一些<strong>附加API</strong>组成的，包括文件、网络、路径等待一些强大的API。所有ECMAScript语法在Node环境中都可以使用。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/ced1f2319044b7cb3ea939a1a11013e7.png"></p><h1 id="Node-js模块化开发"><a href="#Node-js模块化开发" class="headerlink" title="Node.js模块化开发"></a>Node.js模块化开发</h1><p>多个JavaScript调用有文件依赖和变量命名冲突问题。</p><p>一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。</p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>Node.js规定一个<strong>JavaScript文件</strong>就是一个模块，模块<strong>内部定义的变量和函数</strong>默认情况下在外部无法得到</p><p>模块内部可以使用<strong>exports对象进行成员导出</strong>，使用<strong>require方法</strong>导入其他模块。</p><p>导出exports：</p><p>exports.属性名 = 变量</p><p>例：const sayHi = name =&gt; `您好${name}`； exports.sayHi = sayHi;</p><p>导入：</p><p>let a = require(‘文件名’);</p><p><strong>另一种导出方式module.exports</strong></p><p><strong>exports</strong>是<strong>module.exports</strong>的别名<strong>（地址引用关系）</strong>，<strong>导出对象最终以module.exports<br>为准</strong></p><h2 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h2><p>当两者指向同一对象，两者无区别。当两者指向不同对象，导出以module.exports为准，exports导出无效。</p><p>Node.js全局对象global</p><p>在浏览器中全局对象是window，在Node中全局对象是global。</p><p>Node中全局对象下有以下方法，可以在任何地方使用，global可以省略。</p><p>console.log() 在控制台中输出</p><p>setTimeout() 设置超时定时器</p><p>clearTimeout() 清除超时定时器</p><p>setInterval() 设置间歇定时器</p><p>clearInterval() 清除间歇定时器</p><h2 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h2><p>含义：Node运行环境提供的API。因为这些API都是以模块化方式进行开发的，所以我们又称Node运行环境提供的API为系统模块</p><h3 id="fs文件操作"><a href="#fs文件操作" class="headerlink" title="fs文件操作"></a>fs文件操作</h3><p>f：file ，s：system，文件操作系统</p><p>引用：const fs = require(‘fs’)；</p><p>方法：</p><p><strong>读取文件内容</strong> fs.readFile(‘文件路径/文件名称’[，’文件编码’], callbcak);</p><p>文件读取是硬盘的操作，需要耗时，只有读取完毕触发回调函数才能引用读取结果。</p><pre><code class="hljs js"><span class="hljs-comment">// 读取上一级css目录下中的base.css</span>fs.readFile(<span class="hljs-string">&#x27;..css/base.css&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, doc</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 如果文件读取发生错误 参数err的值为错误对象 否则err的值为null</span>    <span class="hljs-comment">// doc参数为文件内容</span>    <span class="hljs-keyword">if</span> (err == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 控制台中输出文件内容</span>        <span class="hljs-built_in">console</span>.log(doc)&#125;&#125;)</code></pre><p>错误优先的回调函数</p><p><strong>写入文件内容</strong> fs.writeFile(‘文件路径/文件名称’, ‘数据’, callback);</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> content = <span class="hljs-string">&#x27;&lt;h3&gt;正在使用fs.writeFile写入文件内容&lt;/h3&gt;&#x27;</span>fs.writeFile(<span class="hljs-string">&#x27;../index.html&#x27;</span>, content, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) &#123;<span class="hljs-built_in">console</span>.log(err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;文件写入成功&#x27;</span>)&#125;)</code></pre><h2 id="系统模块path-路径操作"><a href="#系统模块path-路径操作" class="headerlink" title="系统模块path 路径操作"></a>系统模块path 路径操作</h2><p>为什么要进行路径拼接</p><p>不同操作系统的路径分隔符不统一，windows上是\或/，Linux上是/</p><p>路径拼接语法 path.join(‘路径’，‘路径’，‘路径’，·····—) 下例</p><pre><code class="hljs js"><span class="hljs-comment">// 导入path模块</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">// 路径拼接</span><span class="hljs-keyword">let</span> finialPath = path.join(<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c.css&#x27;</span>)<span class="hljs-comment">// 输出结果cat\a\b\c.css</span><span class="hljs-built_in">console</span>.log(finialPath)</code></pre><h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><ul><li><p>  大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录</p></li><li><p>  读取文件或者设置文件路径时都会选择绝对路径</p></li><li><p>  使用<strong>__dirname</strong>获取当前文件所在的绝对路径</p></li><li><p>  require比较特殊，它指向的就是文件所在的路径，所以可以用相对路径</p></li></ul><h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>就是别人写好的，具有特定功能的，可以直接使用的模块就是第三方模块，由于第三方模块通常都是多个文件组成并且被放置在一个文件夹中，所以又名包。</p><p>存在形式：1. 以js文件的形式存在，提供实现项目具体功能的API接口。</p><ol start="2"><li>以命令行工具形式存在，辅助项目开发。</li></ol><h3 id="获取第三方模块"><a href="#获取第三方模块" class="headerlink" title="获取第三方模块"></a>获取第三方模块</h3><p>npmjs.com: 第三方模块的存储和分发仓库</p><p>npm(node package manager): node的第三方模块管理工具</p><p>下载：npm install 模块名称</p><p>卸载：npm uninstall package 模块名称</p><p>全局安装与本地安装</p><p>命令行工具：全局安装 加-g</p><p>库文件：本地安装</p><h3 id="第三方模块nodemon"><a href="#第三方模块nodemon" class="headerlink" title="第三方模块nodemon"></a>第三方模块nodemon</h3><p>在Node.js中，每次修改文件都要在命令行工具重新执行该文件，nodemon帮我们解决这个问题。</p><p>安装后要把node换成nodemon</p><p><strong>终止操作就按ctrl + c</strong></p><h3 id="第三方模块nrm"><a href="#第三方模块nrm" class="headerlink" title="第三方模块nrm"></a>第三方模块nrm</h3><p>nrm(npm registry manager): npm下载地址切换工具</p><p>npm默认的下载地址在国外，国内下载速度慢</p><p>使用npm install nrm -g 下载</p><p>nrm ls 查看可用下载地址列表</p><p>切换npm下载地址 nrm use</p><h1 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h1><p>第三方模块，基于node平台开发的前端构建工具</p><p>将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令，任务就能自动执行了，提高效率。</p><h2 id="Gulp能做什么"><a href="#Gulp能做什么" class="headerlink" title="Gulp能做什么"></a>Gulp能做什么</h2><ul><li><p>  项目上线，HTML、css、js文件压缩合并</p></li><li><p>  语法转换（es6、less、—）</p></li><li><p>  公共文件抽离</p></li><li><p>  修改文件浏览器自动刷新</p></li></ul><p>即：</p><ol><li><p> 把一个文件拷贝到另一个位置</p></li><li><p> 把多个js或css文件合并成一个文件，以减少网络请求数</p></li><li><p> 对js文件和css文件进行压缩合并 以减少网络流量</p></li><li><p> 把sess或less文件编译成css</p></li><li><p> 压缩图像文件，以减少网络流量</p></li><li><p> 创建一个可以实时刷新页面内容和本地服务器等等</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p> 安装：npm install gulp</p></li><li><p> 在项目根目录下建立gulpfile.js文件</p></li><li><p> 重构项目的文件夹结构src目录放置源代码文件dist目录放置构建后文件</p></li><li><p> 在gulpfile.js文件中编写任务</p></li><li><p> 在命令行工具中执行gulp任务</p></li></ol><h2 id="Gulp中提供的方法"><a href="#Gulp中提供的方法" class="headerlink" title="Gulp中提供的方法"></a>Gulp中提供的方法</h2><ul><li><p>  gulp.src()：获取任务要处理的文件</p></li><li><p>  gulp.dest()：输出文件</p></li><li><p>  gulp.task()：建立gulp任务</p></li><li><p>  gulp.watch()：监控文件的变化</p></li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>)<span class="hljs-comment">// 使用gulp.task()方法建立任务</span>gulp.task(<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 获取要处理的文件</span>gulp.src(<span class="hljs-string">&#x27;./src/css/base.css&#x27;</span>)    <span class="hljs-comment">// 将处理后的文件输出到dist目录</span>.pipe(gulp.dest(<span class="hljs-string">&#x27;./dist/css&#x27;</span>))&#125;)</code></pre><h2 id="Gulp插件"><a href="#Gulp插件" class="headerlink" title="Gulp插件"></a>Gulp插件</h2><ul><li><p>  gulp-htmlmin: html文件压缩</p></li><li><p>  gulp-csso：压缩css</p></li><li><p>  gulp-babel：JavaScript语法转化</p></li><li><p>  gulp-less：less语法转化</p></li><li><p>  gulp-uglify：压缩混淆JavaScript</p></li><li><p>  gulp-file-include：公共文件包含</p></li><li><p>  browsersync：浏览器实时同步</p></li></ul><h2 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h2><p>gulp.task(‘default’, gulp.series(任务名));</p><p>gulp.series：按照顺序执行 gulp.paralle：可以并行计算</p><p>现在gulp.task只接受两个参数</p><h2 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h2><h3 id="node-modules文件夹的问题"><a href="#node-modules文件夹的问题" class="headerlink" title="node_modules文件夹的问题"></a>node_modules文件夹的问题</h3><ul><li><p>  文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢</p></li><li><p>  复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错</p></li></ul><h3 id="package-json文件的作用"><a href="#package-json文件的作用" class="headerlink" title="package.json文件的作用"></a>package.json文件的作用</h3><p>项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。使用<strong>npm<br>init -y</strong>命令生成。</p><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a><strong>项目依赖</strong></h3><ul><li><p>  在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖，例如，jQuery</p></li><li><p>使用npm<br>  install包名命令下载的文件会默认被添加到package.json文件的dependencies字段中</p></li></ul><h3 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h3><ul><li><p>  在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖，例如gulp</p></li><li><p>使用npm install 包名<br>  <strong>–save-dev</strong>命令将包添加到package.json文件的devDependencies字段中</p></li></ul><p><strong>–production 下载项目依赖内容</strong></p><p><strong>script作用：运用命令的别名，来简化一些操作。例如将一段命令语句声明一个别名，通过npm<br>run 别名 就可以执行这条别名里的命令</strong></p><h2 id="package-lock-json文件的作用"><a href="#package-lock-json文件的作用" class="headerlink" title="package-lock.json文件的作用"></a>package-lock.json文件的作用</h2><ul><li><p>  <strong>锁定包的版本</strong>，确保再次下载时不会因为包版本不同而产生问题</p></li><li><p>  <strong>加快下载速度</strong>，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工</p></li></ul><h1 id="Node-js中模块加载机制"><a href="#Node-js中模块加载机制" class="headerlink" title="Node.js中模块加载机制"></a>Node.js中模块加载机制</h1><p><strong>模块查找规则-当模块拥有路径但没有后缀时</strong></p><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;/find.js&#x27;</span>)<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;/find&#x27;</span>)</code></pre><ol><li><p> require方法根据模块路径查找模块，如果是完整路径，直接引入模块。</p></li><li><p> 如果模块后缀省略，先找同名JS文件再找同名JS文件夹</p></li><li><p> 如果找到了同名文件夹，找文件夹中的index.js</p></li><li><p> 如果文件夹中没有index.js就会去当前文件夹中的package.js文件中查找main选项中的入口文件</p></li><li><p> 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</p></li></ol><p><strong>模块查找规则-当模块没有路径且没有后缀时</strong></p><ol><li><p> Node.js会假设它是系统模块</p></li><li><p> Node.js会去node_modules文件夹中</p></li><li><p> 首先看是否有该名字的JS文件</p></li><li><p> 再看是否有该名字的文件夹</p></li><li><p> 如果是文件夹看里面是否有index.js</p></li><li><p> 否则找不到报错</p></li></ol><h1 id="服务器端基础概念"><a href="#服务器端基础概念" class="headerlink" title="服务器端基础概念"></a>服务器端基础概念</h1><h2 id="网站的组成"><a href="#网站的组成" class="headerlink" title="网站的组成"></a>网站的组成</h2><p>网站应用程序主要分为两大部分：客户端和服务器端</p><p>客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。</p><h2 id="Node网站服务器"><a href="#Node网站服务器" class="headerlink" title="Node网站服务器"></a>Node网站服务器</h2><p>能够提供网站访问服务的机器就是网站服务器，他能够接受客户端的<strong>请求</strong>，能够对请求做出<strong>响应</strong>。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>互联网中设备的唯一标识</p><p>IP是Internet Protocol Address的简写，代表互联网协议地址</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时<strong>上网所使用的网址</strong>。</p><p>虽然在地址栏中输入的是网址，但是最终还是会将域名转换为ip才能访问到指定的网站服务器。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>统一资源定位符，又叫URL（Uniform Resource<br>Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。</p><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>传输协议://服务器IP或域名:端口/资源所在位置标识</p><p>http：超文本传输协议，提供了一种发布和接受HTML页面的方法。</p><h2 id="开发过程中客户端和服务器端说明"><a href="#开发过程中客户端和服务器端说明" class="headerlink" title="开发过程中客户端和服务器端说明"></a>开发过程中客户端和服务器端说明</h2><p>在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/9667d2f0ef5d3194fd01c98ef7938fed.png"></p><p><strong>创建Web服务器</strong></p><p><strong>创建web服务器</strong></p><pre><code class="hljs js"><span class="hljs-comment">// 引用系统模块</span><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<span class="hljs-comment">// 创建web服务器</span><span class="hljs-keyword">const</span> app = http.createServer()<span class="hljs-comment">// 当客户端发送请求的时候</span>app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-comment">// 响应</span>res.end(<span class="hljs-string">&#x27;&lt;h1&gt;hi, user&lt;/h1&gt;&#x27;</span>)&#125;)<span class="hljs-comment">// 监听3000端口</span>app.listen(<span class="hljs-number">3000</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;服务器已启动，监听3000端口，请访问localhost:3000&#x27;</span>)</code></pre><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP协议的概念"><a href="#HTTP协议的概念" class="headerlink" title="HTTP协议的概念"></a>HTTP协议的概念</h3><p><strong>超文本传输协议</strong>（hyperText Transfer<br>Protocol，缩写：<strong>HTTP</strong>）规定了如何从网站服务器传输超文本到本地服务器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/b61a0c8588d9a22a13a18ff5ab1da97e.png"></p><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/5003849755bb396b5d1787fb60a7b41a.png"></p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ol><li><p> 请求方式（Request Method）：GET 请求数据 POST 发送数据</p></li><li><p> 请求地址（Request URL）：</p></li></ol><pre><code class="hljs js">app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;req.headers <span class="hljs-comment">// 获取请求报文</span>req.url <span class="hljs-comment">// 获取请求地址</span>req.method <span class="hljs-comment">// 获取请求方法</span>&#125;)</code></pre><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ol><li> HTTP状态码</li></ol><ul><li><p>  200 请求成功</p></li><li><p>  404 请求的资源没有被找到</p></li><li><p>  500 服务器端错误</p></li><li><p>  400 客户端请求有语法错误</p></li></ul><ol start="2"><li>内容类型</li></ol><p>text/html 说明返回html文件</p><p>text/css 说明返回css文件</p><p>application/javascript 说明返回js文件</p><p>image/jpeg 说明返回图片文件</p><p>application/json 说明返回json文件</p><p><strong>res.writeHead</strong> 方法，书写响应头</p><h3 id="HTTP请求与响应处理"><a href="#HTTP请求与响应处理" class="headerlink" title="HTTP请求与响应处理"></a>HTTP请求与响应处理</h3><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p><p>有两种请求参数</p><h4 id="GET请求参数"><a href="#GET请求参数" class="headerlink" title="GET请求参数"></a>GET请求参数</h4><p>参数被放置在浏览器地址栏中，例如：<strong>http:// localhost:3000/index?name=zhangsan&amp;age=20</strong></p><p>?开始，&amp;连接多个</p><p>url.parse(urlStr, [parseQueryString], [slashesDenoteHost]);</p><p>urlStr url字符串</p><p>parseQueryString 为true时将使用查询模块分析查询字符串，默认为false</p><p>slashesDenoteHost 为true时返回对象类型结果</p><h4 id="POST请求参数"><a href="#POST请求参数" class="headerlink" title="POST请求参数"></a>POST请求参数</h4><p>参数被放置在请求体中进行传输</p><p>获取POST参数需要使用data事件和end事件</p><p>使用querystring系统模块将参数转换为对象格式</p><p>post参数是通过事件的方式接受的</p><p>data 当请求参数传递的时候出发data事件</p><p>end 当参数传递完成的时候出发end事件</p><pre><code class="hljs js"><span class="hljs-comment">// 导入系统模块querystring用于将http参数转换为对象形式</span><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;<span class="hljs-keyword">let</span> postData = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">// 监听参数传输事件</span>req.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> postData += chunk)<span class="hljs-comment">// 监听参数传输完毕事件</span>req.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(querystring.parse(postData))&#125;)&#125;)</code></pre><h2 id="输出带有object-null-prototype问题"><a href="#输出带有object-null-prototype问题" class="headerlink" title="输出带有object: null prototype问题"></a>输出带有object: null prototype问题</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/8cb4d2f58bed5ad3000c19b3c242be7a.png"></p><p>解决方法：将对象进行JSON字符串转化（JSON.stringify()）, 然后再转化成对象</p><p>（JSON.parse()）</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件。</p><p><strong>mime 模块 判断请求资源的类型</strong></p><p><strong>动态资源</strong></p><p>相同的请求地址不同的响应资源，这种资源就是动态资源。</p><h1 id="Node-js异步编程"><a href="#Node-js异步编程" class="headerlink" title="Node.js异步编程"></a>Node.js异步编程</h1><h2 id="同步API，异步API"><a href="#同步API，异步API" class="headerlink" title="同步API，异步API"></a>同步API，异步API</h2><p>同步API：只有当前API执行完成后，才能继续执行下一个API</p><p>异步API：当前API的执行不会阻塞后续代码的执行</p><h2 id="同步API，异步API的区别（获取返回值）"><a href="#同步API，异步API的区别（获取返回值）" class="headerlink" title="同步API，异步API的区别（获取返回值）"></a>同步API，异步API的区别（获取返回值）</h2><p>同步API可以从返回值中拿到API执行的结果，但是异步API不可以</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>自己定义函数让别人去调用。</p><h2 id="同步API，异步API的区别（代码执行顺序）"><a href="#同步API，异步API的区别（代码执行顺序）" class="headerlink" title="同步API，异步API的区别（代码执行顺序）"></a>同步API，异步API的区别（代码执行顺序）</h2><p>同步API从上到下依次执行，前面代码会阻塞后面代码的执行</p><p>异步API不会等待API执行完成后再向下执行代码</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/ca95b39956909b22e1dc75005c8c0e6a.png"></p><h2 id="Node-js的异步API"><a href="#Node-js的异步API" class="headerlink" title="Node.js的异步API"></a>Node.js的异步API</h2><p>例：</p><p>fs.readFile(‘./demo.txt’, (err, result) =&gt; {});</p><p>var server = http.createServer(); server.on(‘request’, (req, res) =&gt; {});</p><p>回调地狱：异步API多层嵌套，导致代码难以维护。 <strong>promise可以解决这个问题。</strong></p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise出现的目的是解决Node.js异步编程中回调地狱的问题。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;resolve(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span> &#125;)&#125;<span class="hljs-keyword">else</span> &#123;reject(<span class="hljs-string">&#x27;失败了&#x27;</span>)&#125;&#125;， <span class="hljs-number">2000</span>)&#125;)promise.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result) <span class="hljs-comment">// &#123; name: &#x27;张三&#x27; &#125;)</span>.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error) <span class="hljs-comment">// 失败了)</span></code></pre><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">async</span> () =&gt; &#123;&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</code></pre><h4 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h4><ol><li><p> 普通函数定义前加async关键字 普通函数变成异步函数</p></li><li><p> 异步函数默认的<strong>返回值是promise对象</strong></p></li><li><p>在异步函数内部使用<strong>return关键字进行结果返回</strong> 结果会被包裹的promise对象中<br> return关键字代替了resolve方法</p></li><li><p> 在异步函数内部·使用<strong>throw关键字</strong>进行<strong>错误的抛出</strong></p></li><li><p> 调用异步函数再链式调用then方法获取异步函数执行结果</p></li><li><p> 调用异步函数再链式调用catch方法获取异步函数执行的错误信息</p></li></ol><h4 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h4><ol><li><p> <strong>await关键字只能出现在异步函数中</strong></p></li><li><p> await promise <strong>await后面只能写promise对象</strong> 写其他类型的API是不可以的</p></li><li><p> await关键字它可以暂停异步函数的执行，等待promise对象返回结果后再向下执行。</p></li></ol><p><strong>promisify util模块中的方法，用来改造现有异步函数api 让其返回promise对象<br>从而支持异步函数语法</strong></p><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><p>Express是一个基于<strong>Node平台</strong>的<strong>web应用开发框架</strong>，它提供了一系列的强大特性，帮助你<strong>创建各种Web应用</strong>。</p><p><strong>下载：</strong>npm install express</p><p><strong>框架特性：</strong></p><ul><li><p>  提供了方便<strong>简洁的路由定义</strong>方式</p></li><li><p>  对获取HTTP<strong>请求参数</strong>进行了<strong>简化处理</strong></p></li><li><p>  对<strong>模板引擎支持程度高</strong>，方便渲染动态HTML页面</p></li><li><p>  提供了<strong>中间件</strong>机制有效<strong>控制HTTP请求</strong></p></li><li><p>  拥有大量第三方中间件对功能进行扩展</p></li></ul><p>响应方法不再是end（）而是<strong>send（）</strong></p><ol><li><p> send方法内部会检测响应内容的类型</p></li><li><p> send方法会自动设置http状态码</p></li><li><p> send方法会帮我们自动设置响应的内容类型以及编码</p></li></ol><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>，中间件就是一堆方法，可以接收客户端发来的请求，可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/d2423f8ce4f619f6d55bf3e55d5c8069.png"></p><p>中间件主要由两部分构成，<strong>中间件方法</strong>以及<strong>请求处理函数</strong></p><p>中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。例如路由方法。</p><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;请求路径&#x27;</span>, <span class="hljs-string">&#x27;处理函数&#x27;</span>) <span class="hljs-comment">// 接收并处理get请求</span>app.post(<span class="hljs-string">&#x27;请求路径&#x27;</span>, <span class="hljs-string">&#x27;处理函数&#x27;</span>) <span class="hljs-comment">// 接收并处理post请求</span></code></pre><p>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p><p>默认情况下，请求从上往下一次匹配中间件，一旦匹配成功，终止匹配。</p><p>可以调用<strong>next方法</strong>将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;req.name = <span class="hljs-string">&#x27;张三&#x27;</span>&#125;)app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;res.send(req.name)&#125;)</code></pre><h3 id="app-use中间件用法"><a href="#app-use中间件用法" class="headerlink" title="app.use中间件用法"></a>app.use中间件用法</h3><p>app.use匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有请求</p><p>第一个参数也可以是传入请求地址，代表无论什么请求方式，只要是这个请求地址就接收这个请求。</p><pre><code class="hljs js">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(req.url)next()&#125;)app.use(<span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(req.url)next()&#125;)</code></pre><h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><ol><li><p> 路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p></li><li><p> 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</p></li><li><p> 自定义404页面</p></li></ol><h3 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h3><p>在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。</p><pre><code class="hljs js">app.use(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">&#x27;服务器发生未知错误&#x27;</span>)&#125;)</code></pre><p>同步函数抛出错误会被马上捕获到，但<strong>异步函数</strong>不行，所以要调用<strong>next（）方法</strong>，并且将错误信息通过参数的形式传递给next（）方法，即可触发错误处理中间件</p><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123; fs.readFile(<span class="hljs-string">&#x27;/file-does-not-exist&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123; <span class="hljs-keyword">if</span> (err) &#123; next(err) &#125; &#125;)&#125;)</code></pre><h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p>在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。</p><p><strong>try catch</strong>可以<strong>捕获异步函数以及其他同步代码在执行过程中发生的错误</strong>，但是不能捕获其他类型的API发生的错误，例如promise，回调函数</p><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (req, res, next) =&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">await</span> User.find(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;)&#125;<span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">ex</span>)</span> &#123;next(ex)&#125;&#125;)</code></pre><h2 id="Express请求处理"><a href="#Express请求处理" class="headerlink" title="Express请求处理"></a>Express请求处理</h2><h3 id="构建模块化路由"><a href="#构建模块化路由" class="headerlink" title="构建模块化路由"></a>构建模块化路由</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-comment">// 创建路由对象</span><span class="hljs-keyword">const</span> home = express.Router()<span class="hljs-comment">// 将路由和请求路径进行匹配</span>app.use(<span class="hljs-string">&#x27;/home&#x27;</span>, home)<span class="hljs-comment">// 在home路由下继续创建路由</span>home.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// /home/index</span>res.send(<span class="hljs-string">&#x27;欢迎来到博客展示页面&#x27;</span>)&#125;)</code></pre><pre><code class="hljs js"><span class="hljs-comment">// home.js</span><span class="hljs-keyword">const</span> home = express.Router()home.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;res.send(<span class="hljs-string">&#x27;欢迎来到博客展示页面&#x27;</span>)&#125;)<span class="hljs-built_in">module</span>.exports = home</code></pre><pre><code class="hljs js"><span class="hljs-comment">// admin.js</span><span class="hljs-keyword">const</span> admin = express.Router()admin.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;res.send(<span class="hljs-string">&#x27;欢迎来到博客管理页面&#x27;</span>)&#125;)<span class="hljs-built_in">module</span>.exports = admin</code></pre><pre><code class="hljs js"><span class="hljs-keyword">const</span> home = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./route/home.js&#x27;</span>)<span class="hljs-keyword">const</span> admin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./route/admin.js&#x27;</span>)app.use(<span class="hljs-string">&#x27;/home&#x27;</span>, home)app.use(<span class="hljs-string">&#x27;/admin&#x27;</span>, admin)</code></pre><h3 id="GET参数的获取"><a href="#GET参数的获取" class="headerlink" title="GET参数的获取"></a>GET参数的获取</h3><p>Express框架中使用<strong>req.query</strong>即可获取GET参数，框架内部会将GET参数转换为对象并返回。</p><pre><code class="hljs js"><span class="hljs-comment">// 接收地址栏中问号后面的参数</span><span class="hljs-comment">// 例如：http://localhost:3000/?name=zhangsan&amp;age=30</span>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(req.query) <span class="hljs-comment">// &#123; &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot; &#125;</span>&#125;)</code></pre><h3 id="POST参数的获取"><a href="#POST参数的获取" class="headerlink" title="POST参数的获取"></a>POST参数的获取</h3><p>Express中接收post请求参数需要借助第三方包<strong>body-parser</strong>。</p><pre><code class="hljs js"><span class="hljs-comment">// 引入body-parser模块</span><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<span class="hljs-comment">// 配置body-parser模块</span>app.use(bodyParser.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<span class="hljs-comment">// 接收请求</span>app.post(<span class="hljs-string">&#x27;/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-comment">// 接收请求参数</span><span class="hljs-built_in">console</span>.log(req.body)&#125;)</code></pre><p>extended拓展，默认值为false，即使用系统模块querystring处理请求参数的格式，当为true时，运用第三方模块qs来对请求参数进行处理，虽然qs的功能比querystring强大，但目前用querystring就足够了。</p><h3 id="Express路由参数"><a href="#Express路由参数" class="headerlink" title="Express路由参数"></a>Express路由参数</h3><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/find/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(req.params) <span class="hljs-comment">// &#123; id: 123 &#125;</span>&#125;)<span class="hljs-comment">// localhost:3000/find/123</span></code></pre><p>不传递参数将无法访问页面</p><h3 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h3><p>通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript文件等。</p><pre><code class="hljs js">app.use(express.static(<span class="hljs-string">&#x27;pubilc&#x27;</span>))</code></pre><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方原art-template模板引擎的基础上封装了express-art-template。</p><p>下载：</p><p>npm install –save art-template</p><p>npm install –save express-art-template</p><pre><code class="hljs js"><span class="hljs-comment">// 当渲染后缀为art的模板时 使用express-art-template</span>app.engine(<span class="hljs-string">&#x27;art&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))<span class="hljs-comment">// 设置模板存放目录</span>app.set(<span class="hljs-string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>))<span class="hljs-comment">// 渲染模板时不写后缀 默认拼接art后缀</span>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;art&#x27;</span>)app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 渲染模板</span>res.render(<span class="hljs-string">&#x27;index&#x27;</span>)&#125;)</code></pre><p>views是固定的，要在文件夹中生成views文件夹</p><h3 id="app-locals对象"><a href="#app-locals对象" class="headerlink" title="app.locals对象"></a>app.locals对象</h3><p>将变量设置到app.locals对象z下面，这个数据在所有的模板中都可以获取到。</p><pre><code class="hljs js">app.locals.users = [&#123;name: <span class="hljs-string">&#x27;张三&#x27;</span>,age: <span class="hljs-number">20</span>&#125;, &#123;name: <span class="hljs-string">&#x27;李四&#x27;</span>,age: <span class="hljs-number">20</span>&#125;]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML5笔记</title>
    <link href="/2020/12/15/HTML5%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/15/HTML5%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h1><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/9f8352f5b5b1520bf42cad8dbc5c2ebb.png"></p><h1 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h1><h2 id="lt-audio-gt-音频标签"><a href="#lt-audio-gt-音频标签" class="headerlink" title="&lt;audio&gt;音频标签"></a>&lt;audio&gt;音频标签</h2><p>支持格式</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/273f885407d856d683348e4e7736486b.png"></p><p>可以放多个不同格式资源在标签中，用source加载</p><p>&lt;source src=”路劲” type=”声明”/&gt;</p><p>常见属性：</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/fb7778f79a495252cfc25bf099fb87fa.png"></p><h2 id="lt-video-gt-视频标签"><a href="#lt-video-gt-视频标签" class="headerlink" title="&lt;video&gt;视频标签"></a>&lt;video&gt;视频标签</h2><p>支持格式</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/b52661c227025070a1658813470ea6df.png"></p><p>常见属性</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/4c4747d335f9bea6e45ee3dcd64478a6.png"></p><h2 id="新增input表单"><a href="#新增input表单" class="headerlink" title="新增input表单"></a>新增input表单</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/4f17f03037bb6d7fb2881ddd33376305.png"></p><h2 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/0f93bb646ce64bc05cc47268a6db1975.png"></p><h1 id="CSS3选择器"><a href="#CSS3选择器" class="headerlink" title="CSS3选择器"></a>CSS3选择器</h1><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/985017c2d1e0ae1c1db2768061efb7bc.png"></p><h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/5d664e5ce4ccdcf9c339924c703c98a5.png"></p><p>注：n可以是关键词 even 是偶数 odd是基数，也可以是公式（从0开始算起）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/1096dfcab8e490e5043d030fa6c52b61.png"></p><p>但是第0个元素或者超出了元素的个数会被忽略</p><p>nth-child（n）选择父元素里面的第n个孩子，他不管里面的孩子是否同一种类型；</p><p>如果div里有p和span标签，想选择其中的span标签，则用of-type 选择指定类型的元素</p><p>例：div span:nth-of-type(n)</p><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/1e272e7bae034f3a7a668ed2653003ce.png"></p><p>注意：1.before和after必须要有content属性</p><p>2.before在里面的内容的前面，after在里面的内容的后面</p><p>3.before和after创建一个元素，但是行内元素（inline）</p><p>4.在dom在看不到创建的元素，所以叫伪元素</p><p>5.伪元素和标签选择器一样，权重为1</p><h1 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h1><p>转换（transform）是css3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果。</p><p>二维坐标系</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/a03d02a8c95e6a8518973bc5fe0d9d32.png"></p><h2 id="移动（translate）"><a href="#移动（translate）" class="headerlink" title="移动（translate）"></a>移动（translate）</h2><p>语法：transform：translate(x,y); 或者分开写 transform: translateX(n);</p><p>transform: translateY(n);</p><p>重点：1.translate最大的优点：不会影响其他元素的位置</p><p>2.可以用%。%的长度取决于盒子自身的宽度或高度</p><p>3.对行内标签没有效果</p><h2 id="旋转（rotate）"><a href="#旋转（rotate）" class="headerlink" title="旋转（rotate）"></a>旋转（rotate）</h2><p>语法：transform：rotate( num deg)</p><p>重点：1.角度为正时，顺时针；负时，为逆时针</p><p>2.默认旋转的中心点是元素的中心点</p><h2 id="中心点（transform-origin）"><a href="#中心点（transform-origin）" class="headerlink" title="中心点（transform-origin）"></a>中心点（transform-origin）</h2><p>语法：transform-origin：x y</p><p>重点：1.注意两个参数要用空格隔开</p><p>2.x y默认50%</p><p>3.x y可以设置数值或者方位名词（top bottom left right center）</p><h2 id="缩放（scale）"><a href="#缩放（scale）" class="headerlink" title="缩放（scale）"></a>缩放（scale）</h2><p>语法：transform:scale(x, y)</p><p>优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</p><h2 id="2D转换综合写法"><a href="#2D转换综合写法" class="headerlink" title="2D转换综合写法"></a>2D转换综合写法</h2><p>1.同时使用多个转换，其格式为：transform：translate() rotate() scale()..等等</p><p>2.其顺序会影响转换的效果。（先旋转会改变坐标轴方向）所以一般把位移放在最前面。</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>动画（animation）是css3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p><p>制作动画分两步：1.先定义动画 2.调用动画</p><h2 id="用keynames定义动画（类似定义类选择器）"><a href="#用keynames定义动画（类似定义类选择器）" class="headerlink" title="用keynames定义动画（类似定义类选择器）"></a>用keynames定义动画（类似定义类选择器）</h2><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> 动画名称 &#123;0% &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;&#125;100% &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;&#125;&#125;</code></pre><p>1.可以做多个状态变化 keyframe（关键帧）</p><p>2.里面的百分比要用整数</p><h2 id="动画序列"><a href="#动画序列" class="headerlink" title="动画序列"></a>动画序列</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/9f9b6bf598ca2486bd48a0f08ebf9e2a.png"></p><p><strong>动画属性</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/e628dfa8e2e7084fb1b4fa34c1472626.png"></p><h2 id="动画简写属性"><a href="#动画简写属性" class="headerlink" title="动画简写属性"></a>动画简写属性</h2><p>animation：动画名称 持续时间 运动速度 何时开始 播放次数 是否反方向<br>动画起始或者结束的状态</p><p>注意：</p><ol><li><p>简写属性里面不包括animation-play-state</p></li><li><p>同一个元素添加多个动画效果时，一个animation属性，用逗号（<strong>，</strong>）隔开。</p></li></ol><h2 id="速度曲线细节（animation-timing-function）"><a href="#速度曲线细节（animation-timing-function）" class="headerlink" title="速度曲线细节（animation-timing-function）"></a>速度曲线细节（animation-timing-function）</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/9d4d9052c822821941c4f4839370efc9.png"></p><h1 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h1><h2 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/d71f70b9d442b726ea7c671c380c629a.png"></p><h2 id="移动（translate3d）"><a href="#移动（translate3d）" class="headerlink" title="移动（translate3d）"></a>移动（translate3d）</h2><p>跟2D移动差不多，多了一个z轴。z轴移动一般用px单位。translate3d中的xyz值不能省略，没有就写0。</p><h2 id="透视（perspective）"><a href="#透视（perspective）" class="headerlink" title="透视（perspective）"></a>透视（perspective）</h2><p>透视我们也称之为视距：视距就是人的眼睛到屏幕的距离。想要网页产生3D效果需要透视。</p><p>注意：</p><p>1.距离透视点越近的在电脑平面成像越大，越远就越小。</p><p><strong>2.透视写在被观察元素的父盒子上面的</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/707b8f847530e84d2423e73b515c0b66.png"></p><p>d：视距，人眼睛到屏幕距离。</p><p>z：z轴，物体距离屏幕的距离。z轴越大，看到的物体越大</p><h2 id="3D旋转-rotate3d"><a href="#3D旋转-rotate3d" class="headerlink" title="3D旋转(rotate3d)"></a>3D旋转(rotate3d)</h2><p>可以指定x,y,z轴，让元素旋转。</p><p>语法：transform：rotateX( num deg); transform：rotateY( num deg);<br>transform：rotateZ( num deg);</p><p>transform: rotate3d(x, y, z, deg)；:<br>沿着自定义旋转deg为角度。xyz是表示旋转的矢量(1,<br>-1)，是表示你是否希望沿着该轴旋转，最后一个表示旋转角度。</p><p><strong>左手准则</strong>：左手拇指指向x，y轴的正方向，其余手指的弯曲方向就是该元素沿着x，y轴旋转的方向</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/9c23210ed743abf45d045a9a54566b8b.png"></p><h2 id="3D呈现（transform-style）"><a href="#3D呈现（transform-style）" class="headerlink" title="3D呈现（transform-style）"></a>3D呈现（transform-style）</h2><p>作用：控制子元素是否开启三维立体环境。</p><p>参数：flat——子元素不开启3d立体空间，默认的。 preserve-3d——子元素开启立体空间</p><p>注意：代码写给父级，但影响的是子元素。</p><h1 id="浏览器私有前缀"><a href="#浏览器私有前缀" class="headerlink" title="浏览器私有前缀"></a>浏览器私有前缀</h1><p>浏览器私有前缀是为了兼容老版本的写法，比较新版本的浏览器无须添加</p><p>-moz-：代表firebox浏览器私有属性</p><p>-ms-：代表ie浏览器私有属性</p><p>-webkit-：代表safari-chrome私有属性</p><p>-o-：代表Opera私有属性</p><h1 id="移动布局基础"><a href="#移动布局基础" class="headerlink" title="移动布局基础"></a>移动布局基础</h1><p>国内主流的浏览器内核一般为webkit，所以兼容移动端的浏览器，考虑webkit的兼容就可以了。</p><p>调试方法：**1.**Chrome DevTool（谷歌浏览器）的模拟手机调试</p><p>2.搭建本地web服务器，用手机访问服务器</p><p>3.用外网的服务器，直接IP或域名访问</p><h2 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h2><p>就是浏览器显示页面内容的屏幕区域。视口可以分为布局视口、视觉视口和理想视口。</p><ul><li>布局视口（layout viewport）</li></ul><p>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题</p><p>ios，android基本都将这个视口分辨率设置为980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。大小即整个网页大小</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/adf94f2f01a6c4c496d30ebe549ebf2c.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/648f4161ad36b78219c0c9e9204413ef.jpeg"></p><ul><li>视觉视口（visual viewport）</li></ul><p>字面意思，它是用户正在看到的网站的区域。大小即手机屏幕大小。</p><ul><li><strong>理想视口</strong>（ideal viewport）</li></ul><p>为了使网站在移动端最理想的浏览器和阅读宽度而设定</p><p>需要手动添写<strong>meta视口标签</strong>通知浏览器操作</p><p>meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，设备有多宽，我们布局的视口就多宽。</p><p><strong>meta视口标签</strong></p><p>标准viewport设置：&lt;meta name=”viewport” content=”width=device-width,<br>user-scalable=no, initial-scale=1.0 maximum-scale=1.0, minimum-scale=1.0”&gt;</p><p>上例：宽度等于设备宽度，不允许用户缩放，不缩放。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/825eab8d102239b4d7b746314bc800a9.png"></p><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><h3 id="物理像素和物理像素比"><a href="#物理像素和物理像素比" class="headerlink" title="物理像素和物理像素比"></a>物理像素和物理像素比</h3><ol><li><p>物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了，比如6\7\8<br> 是750*1334</p></li><li><p> 开发的时候1px不是一定等于一个物理像素的。PC端页面，1个px等于1个物理像素的，但手机上不同</p></li><li><p> 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比。</p></li></ol><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/a744f84e28ff58de7abaff6f7b1f91bc.png"></p><p>原因：Retina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。</p><h2 id="多倍图"><a href="#多倍图" class="headerlink" title="多倍图"></a>多倍图</h2><p>对于图片，在Retina屏中打开，按照物理像素比放大，会造成图片模糊</p><p>在标准的viewport设置中，使用倍图来提高图片质量。通常用二倍图，也有三倍、四倍。按实际开发需求</p><p>方法：二倍图放在宽高为一倍的盒子内。</p><h3 id="背景缩放（background-size：背景图片宽度-背景图片高度）"><a href="#背景缩放（background-size：背景图片宽度-背景图片高度）" class="headerlink" title="背景缩放（background-size：背景图片宽度 背景图片高度）"></a>背景缩放（background-size：背景图片宽度 背景图片高度）</h3><p>background-size属性规定背景图像的尺寸</p><p>只写一个参数，为宽度，高度等比例缩放。</p><p>单位：长度|百分比|cover|contain</p><p>cover：把背景图片等比例拉伸 完全覆盖盒子 可能有部分背景图片显示不全</p><p>contain：把背景图片等比例拉伸<br>当宽度或者高度到达边界，则停止缩放。所以可能有部分空白。</p><p>背景图片二倍图缩放方法：运用background-size</p><h3 id="多倍图切图（cutterman）"><a href="#多倍图切图（cutterman）" class="headerlink" title="多倍图切图（cutterman）"></a>多倍图切图（cutterman）</h3><p>ps中，选择图片，选择cutterman，选择ios/android，@3X：3倍图 @2X：2倍图<br>@1X：一倍图</p><h2 id="二倍精灵图做法"><a href="#二倍精灵图做法" class="headerlink" title="二倍精灵图做法"></a>二倍精灵图做法</h2><ol><li><p> 在firework里面把精灵图等比例缩放为原来的一半</p></li><li><p> 根据大小测量坐标</p></li><li><p> background-size：精灵图原来宽度的一半</p></li></ol><h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><ol><li><p> 单独制作移动端页面（主流）</p></li><li><p> 响应式页面兼容移动端：一个页面，兼容电脑和手机。（花费精力大，但未来应该会向这边靠拢）</p></li></ol><p>移动端技术解决方案</p><ol><li><p> 注意属性是否加webkit私有前缀</p></li><li><p> CSS初始化 normalize.css</p></li></ol><h2 id="CSS3盒子模型（box-sizing）"><a href="#CSS3盒子模型（box-sizing）" class="headerlink" title="CSS3盒子模型（box-sizing）"></a>CSS3盒子模型（box-sizing）</h2><p>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</p><p>CSS盒子模型：盒子宽度 =<br>CSS中设置的宽度width里面包含了border和padding，即padding和border不会撑大盒子。</p><p>CSS3盒子模型：box-sizing：border-box</p><p>传统盒子模型：box-sizing：content-box</p><h3 id="特殊样式"><a href="#特殊样式" class="headerlink" title="特殊样式"></a>特殊样式</h3><p>点击高亮清除：-webkit-tap-highlight-color：transparent；</p><p>去除按钮和输入框自定义样式：-webkit-appearance：none；</p><p>禁用长按页面时的弹出菜单：-webkit-touch-callout：none；</p><h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><ol><li>单独制作移动端页面</li></ol><p><strong>流式布局（百分比布局） flex弹性布局 less+rem+媒体查询布局 混合布局</strong></p><ol start="2"><li>响应式页面兼容移动端</li></ol><p><strong>媒体查询 bootstarp</strong></p><h3 id="流式布局（百分比布局）"><a href="#流式布局（百分比布局）" class="headerlink" title="流式布局（百分比布局）"></a>流式布局（百分比布局）</h3><p>通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。</p><p>为了保护元素不被无限缩放，引入最大最小宽高。</p><p><strong>max-width 最大宽度 （max-height 最小宽度）</strong></p><p><strong>min-width 最小宽度 (min-height 最小高度)</strong></p><p><strong>图片格式</strong></p><p>DPG：京东独有的图片压缩技术，节省加载时间。压缩后与webp的清晰度对比没有差距</p><p>webp：谷歌开发的一种皆在加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3</p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>传统布局：兼容性好、布局繁琐、局限性</p><p>flex弹性布局：操作简单，布局简单、PC端浏览器支持情况较差</p><p>含义：flex是flexible<br>Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局。</p><p>采用flex布局的元素，称为Flex容器（flex<br>container），简称“容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex<br>item），简称“项目”。</p><p><strong>注意：当我们父盒子设为flex布局以后，子元素的float、clear和vertical-align属性将失效</strong></p><p><strong>父项常见属性</strong></p><p><strong>flex-direction</strong>：设置主轴的方向（横向、纵向）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/fc963efa7b7904a3cabbe5564b7fb173.png"></p><p><strong>justify-content</strong>：设置<strong>主轴</strong>上的元素的子元素排列方式</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/a29503bde9861e5171627d0837fca7a4.jpeg"></p><p><strong>flex-wrap</strong>：设置子元素是否换行（flex默认不换行，如果元素过多，会挤压盒子缩小宽高放在一行内）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/71f1c1854696dacabd9f7c3862434318.png"></p><p><strong>align-items</strong>：设置<strong>侧轴</strong>上的子元素排列方式<strong>（单行）（stretch拉伸不要给子元素高度，否则无效果）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/54aabc147ca6b7d38714c85d55b2fa0b.png"></p><p>align-content：设置侧轴上的子元素的排列方式<strong>（多行）（对单行无效果）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/b9007880a294849fb06450e90a2c0405.jpeg"></p><p>使用情景</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/47e0d1794205a8231d4911dd5ec0d754.png"></p><p>flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap</p><h4 id="子项常见属性"><a href="#子项常见属性" class="headerlink" title="子项常见属性"></a>子项常见属性</h4><p><strong>flex属性</strong></p><p>flex属性定义子项目分配剩余空间，用flex来表示占多少份数</p><p>语法：flex：number （默认是0）</p><p><strong>align-self</strong> 控制子项自己在侧轴上的排列方式</p><p>align-self属性允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><p><strong>order</strong><br>属性定义项目的排列顺序，数值越小，排列越靠前，默认为0。（在主轴上排列的前后）</p><p><strong>背景线性渐变</strong></p><p>background：-webkit-linear-gradient（起始方向，颜色1，颜色2,。。。）；</p><p>背景渐变必须添加私有前缀</p><p>起始方向可以是方位名词（top，left，bottom，right）如果省略默认就是top</p><h3 id="rem适配布局"><a href="#rem适配布局" class="headerlink" title="rem适配布局"></a>rem适配布局</h3><p><strong>rem基础</strong></p><p>rem（root em）是一个相对单位，类似于em，em是<strong>父元素</strong>字体大小</p><p>不同的是rem的基准是相对于<strong>html元素</strong>的字体大小</p><p>比如，根元素（html）设置font-size=12px；非根元素设置width：2rem；则换成px表示就是24px。</p><p>rem的优点：可以通过修改html里面的文字大小来改变页面中元素的大小可以整体控制，而与em相比，因为父元素很多，所有不好控制。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>rem布局是为了适应某个特殊时期发明的布局方式，不建议使用。现在的移动端布局依旧使用百分比布局+flex布局较好。</p><h2 id="媒体查询（Media-Query）"><a href="#媒体查询（Media-Query）" class="headerlink" title="媒体查询（Media Query）"></a>媒体查询（Media Query）</h2><p>媒体查询是CSS3新语法</p><p>特点：</p><p>1.使用 @media 查询，可以针对不同的媒体类型定义不同的样式</p><p><strong>2.@media 可以针对不同的屏幕尺寸设置不同的样式</strong></p><p>3.当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面</p><p>4.目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询</p><p>语法：</p><pre><code class="hljs css"><span class="hljs-keyword">@media</span> 媒体类型 关键字 (媒体特性) &#123;<span class="hljs-selector-tag">CSS-Code</span>;  &#125;<span class="hljs-comment">/* 用@media开头注意@符号 */</span></code></pre><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/3948858191f2a9e22f37ed306aae9c26.png"></p><p><strong>关键字</strong>：将媒体类型或多个媒体特性连接到一起做为媒体查询的条件</p><p>and：可以将多个媒体特性连接到一起，相当于“且”的意思</p><p>not：排除某个媒体类型，相当于“非”的意思，可以省略</p><p>only：指定某个特定的媒体类型，可以省略</p><h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><p>每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。暂且了解三个</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/92d59a8372e506312b6f0a58e6bb95df.png"></p><p>媒体查询为了代码更简洁，我们按从小到大的顺序写。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/2dfb83167f1a54ed1f8d0b15f2d620c9.png"></p><h2 id="引入资源"><a href="#引入资源" class="headerlink" title="引入资源"></a>引入资源</h2><p>当样式比较繁多的时候，我们可以针对不同的媒体使用不同的stylesheets（样式表）。</p><p>原理，就是直接在link中判断设备的尺寸，然后引用不同的css文件。</p><p>语法：&lt;link rel=”stylesheet” media = ”mediatype and|not|only (media feature)”<br>href = ”mystylesheet.css”&gt;</p><h1 id="less基础"><a href="#less基础" class="headerlink" title="less基础"></a>less基础</h1><h2 id="维护CSS的弊端"><a href="#维护CSS的弊端" class="headerlink" title="维护CSS的弊端"></a>维护CSS的弊端</h2><p>CSS是一门非程序式语言，没有变量，函数，SCOPE（作用域）等概念</p><p>1.CSS需要书写大量看似没有逻辑的代码，CSS冗余度是比较高的</p><p>2.不方便维护及扩展，不利于复用</p><p>3.CSS没有很好的计算能力</p><h2 id="什么是Less"><a href="#什么是Less" class="headerlink" title="什么是Less"></a>什么是Less</h2><p>Less（leaner Style Sheets的缩写）是一门CSS扩展语言，也成为CSS预处理器</p><p>作为CSS的一种形式的扩展，它并没有减少CSS的功能，而是在现有的CSS语法上，为CSS加入程序语言的特性。</p><p>它在CSS的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了CSS的编写，并且降低了CSS的维护成本。</p><p>常见的CSS预处理器：Sass、Less、Stylus</p><p>一句话：<strong>Less是一名门CSS预处理语言，它扩展了CSS的动态特性</strong></p><h2 id="Less变量"><a href="#Less变量" class="headerlink" title="Less变量"></a>Less变量</h2><p>创建.less文件，在文件中编写less变量和样式。</p><p>语法： @变量名：值；</p><p><strong>命名规范</strong>：1.必须要@为前缀 2.不能包含特殊字符 3.不能以数字开头 4.大小写敏感</p><h2 id="Less编译"><a href="#Less编译" class="headerlink" title="Less编译"></a>Less编译</h2><p>需要将less文件编译生成css文件，html页面才能使用。</p><p>工具：vscode插件：eazy less。保存less文件即可生成对应的css文件。</p><h2 id="Less嵌套"><a href="#Less嵌套" class="headerlink" title="Less嵌套"></a>Less嵌套</h2><p>CSS选择器嵌套 <strong>Less嵌套写法</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/36376a0470ba4078c0f5e1a28dfad046.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/0db62e55f99112c7bb1c01f5308132e0.png"></p><p>对于交集|伪类|伪元素选择器，如果直接写在里面，编译的时候就好在父元素和交集|伪类|伪元素选择器之间加入空格从而无效化。我们需要把交集|伪类|伪元素选择器写在里面并在前面加入**&amp;符号**，这样它就被解析为父元素自身或父元素的伪类。</p><p>CSS伪类写法  <strong>Less写法</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/30529968b2f54a0083bb51735bb8ffed.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/52728fced9c6f698e122056b9f874149.png"></p><h2 id="Less运算"><a href="#Less运算" class="headerlink" title="Less运算"></a>Less运算</h2><p>任何数字、颜色或者变量都可以参与运算。Less提供了四则算术运算。</p><p>注意：1.<strong>运算符左右两侧必须加空格隔开</strong></p><p>2.两个数参与运算，如果只有一个数有单位，那么最后以这个单位为准</p><p>3.两个数参与运算，如果两个数都有单位，最后的结果以第一个单位为准</p><h1 id="rem适配方案"><a href="#rem适配方案" class="headerlink" title="rem适配方案"></a>rem适配方案</h1><ol><li><p> 让一些不能等比自适应的元素，达到当设备尺寸发生改变时，等比例适配当前设备。</p></li><li><p> 使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。</p></li></ol><p>适配方案技术使用（市场主流）</p><p>方案一：less + 媒体查询 + rem</p><p>方案二：flexible + rem</p><p><strong>方案一</strong></p><p><strong>设计稿常见宽度（基本以750为准）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/79c256b6cffaae1773bfe53b816118ba.png"></p><p><strong>动态设置html标签font-size大小</strong></p><p>假设我们把整个屏幕划分为15等份，那么字体大小=屏幕宽度/等份</p><p><strong>元素大小取值方法</strong></p><ol><li><p> 屏幕宽度/划分份数 就是html font-size的大小</p></li><li><p> 最后公式：页面元素的rem值 = 页面元素值（px）/（屏幕宽度/划分的份数）</p></li><li><p> 或者：页面元素的rem值 = 页面元素值（px）/ html font-size字体大小</p></li></ol><p><strong>方案二</strong></p><p>flexible.js：手机淘宝团队出的简洁高效移动端适配库</p><p>原理：把当前设备划分为10等份，确定好当前设备的html文字大小就可以了。</p><h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><h2 id="响应式开发原理"><a href="#响应式开发原理" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h2><p>就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同的设备的目的。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/6882c60739864f421c001d9f775280f7.png"></p><h2 id="响应式布局容器"><a href="#响应式布局容器" class="headerlink" title="响应式布局容器"></a>响应式布局容器</h2><p>响应式布局需要一个父级的布局容器，来配合子级元素来实现变化效果。</p><p>原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</p><h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>Bootstrap是基于HTML、CSS和JAVASCRIPT的，它简洁灵活，使得WEB开发更便捷</p><p>优点：1.标准化得html +css编码规范</p><p>2.提供了一套简洁、直观、强悍的组件</p><p>3.不断更新迭代</p><p>4.提高开发效率</p><h2 id="Bootstrap使用"><a href="#Bootstrap使用" class="headerlink" title="Bootstrap使用"></a>Bootstrap使用</h2><p>使用样式：创建文件夹结构——创建html骨架结构——引入相关样式文件——书写内容</p><p>书写内容：1.直接拿Bootstrap预先定义好的样式来使用</p><p>2.修改Bootstrap原来的样式，注意权重问题</p><p>3.<strong>要清楚它定义了哪些样式，以及这些样式能实现什么样的效果</strong></p><h2 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h2><p>Bootstrap需要为页面内容和栅格系统包裹一个.contain容器，Bootstrap预先定义好了这个类，叫container。它提供了两个作此用处的类</p><ol><li> <strong>container类</strong></li></ol><p>响应式布局容器 固定宽度 大屏（&gt;=1200px）宽度定为1170px<br>中屏（&gt;=992px）宽度定为970px</p><p>小屏（&gt;=768px）宽度定为750px 超小屏（100%）</p><ol start="2"><li><strong>container-fluid类</strong></li></ol><p>流式布局容器 百分百宽度</p><p>占据全部视口（viewport）的容器</p><p>适合于单独做移动端开发</p><h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><p>栅格系统（grid systems）指页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局。</p><p>Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统自动分为最多<strong>12列</strong>。</p><p>Bootstrap里面container宽度是固定的，但是不同屏幕下，container的宽度不同，我们再把container划分为12等份。</p><h3 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h3><p>栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建的布局中。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/ca325f85393e1c4cf308e740feef9cc0.png"></p><p>注意：1.行（row）必须放到container布局容器里面</p><p>2.我们实现列的平均划分需要给列添加类前缀</p><p>3.列（column）大于12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。列小于12则填不满一行。</p><p>4.每一列默认有左右15像素的padding</p><p>5.可以同时为一列指定多个设备的类名，以便划分不同份数 例如class=“col-md-4<br>col-sm-6”</p><h3 id="列嵌套"><a href="#列嵌套" class="headerlink" title="列嵌套"></a>列嵌套</h3><p>栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一列再分成若干小列。可以通过添加一个新的.row元素和一系列.col-sm-*元素到已经存在的.col-sm-*元素内</p><p>列嵌套最好加一个行row，这样可以取消父元素的padding值</p><h3 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h3><p>使用.col-md-offset-*类可以将列向右侧偏移。这些类实际是通过使用*选择器为当前元素增加了左侧的边距。</p><p>偏移的份数 就是 12 – 两个盒子的份数</p><p>如果只有一个盒子，那么就偏移 = 12 – 盒子份数/2</p><h3 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h3><p>通过使用.col-md-push-*（向右推） 和.col-md-pull-*（向左拉）来改变顺序<br>（靠position：relative实现）</p><p>按x轴方向运动</p><h2 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h2><p>为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/html5/42b357c3e404a4993516d90980e8fc49.png"></p><p>与之相反的是visible-xs visible-sm visible-md visible-lg 在什么屏幕下显示。</p><h1 id="移动端技术选型"><a href="#移动端技术选型" class="headerlink" title="移动端技术选型"></a>移动端技术选型</h1><p>流式布局（百分比布局）</p><p><strong>flex弹性布局（推荐）</strong></p><p><strong>rem适配布局（不推荐）</strong></p><p>响应式布局</p><p>建议：选一种为主要技术选型，其他技术作为辅助，混合开发</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript笔记</title>
    <link href="/2020/12/05/JS%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/JS%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><p>arguments对象中存储了传递到函数里的所有实参。</p><p>prompt</p><p>prompt() 方法用于显示可提示用户进行输入的对话框</p><p>语法：prompt(text,defaultText)</p><p>text：可选。要在对话框中显示的纯文本</p><p>defaultText：可选。默认的输入文本。</p><p>如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段<strong>当前显示的文本</strong>。</p><h1 id="函数声明方式"><a href="#函数声明方式" class="headerlink" title="函数声明方式"></a>函数声明方式</h1><h2 id="1-利用函数关键字自定义函数（命名函数）"><a href="#1-利用函数关键字自定义函数（命名函数）" class="headerlink" title="1.利用函数关键字自定义函数（命名函数）"></a>1.利用函数关键字自定义函数（命名函数）</h2><p>function fn() {}</p><p>fn（）；</p><h2 id="2-函数表达式（匿名函数）"><a href="#2-函数表达式（匿名函数）" class="headerlink" title="2.函数表达式（匿名函数）"></a>2.函数表达式（匿名函数）</h2><p>var fun(变量名) = function() {}</p><p>fun（）；</p><p>注意：1.变量名不是函数名</p><p>2.函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存函数</p><p>3.函数表达式也可以进行传递参数</p><p>4.<strong>函数表达式调用必须写在函数声明下面</strong></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>Javascript作用域：就是代码名字（变量）在某个范围内起作用和效果 目的是为了提高程序的可靠性更重要的是减少命名冲突。</p><p>js的作用域（es6）之前：全局作用域 局部作用域</p><p><strong>全局作用域</strong>：整个script标签 或者是一个单独的js文件</p><p><strong>局部作用域</strong>：在函数内部就是局部作用域</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>根据作用域的不同我们变量分为全局变量和局部变量</p><ol><li><p><strong>全局变量</strong>：在全局作用域下的变量 在全局下都可以使用</p></li><li><p><strong>局部变量</strong> 在局部作用域下的变量 后者在函数内部的变量就是局部变量。只能在函数内部使用。</p></li><li><p><strong>从指向效率来看全局变量和局部变量</strong></p></li></ol><p>（1）  全局变量只有浏览器关闭的时候才会销毁，比较占内存资源</p><p>（2）  局部变量 当我们程序执行完毕就会销毁，比较节约内存资源</p><p><strong>注意</strong>：如果在函数内部 <strong>没有声明直接赋值的变量也属于全局变量</strong></p><p>函数的形参也可以看做是局部变量</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值 这种结构称作作用域链 就近原则。</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步：<strong>预解析和代码执行</strong></p><ol><li><p>预解析：js引擎会把js里面所有的var还有function提升到当前作用域的最前面</p></li><li><p>代码执行：按照代码书写顺序从上往下执行</p></li></ol><p>预解析分为 变量预解析（变量提升）和函数预解析（函数提升）</p><ol><li><p>变量提升：就是把所有的变量声明提升到当前的作用域最前面 <strong>不提升赋值操作</strong>。</p></li><li><p>函数提升：就是把所有的函数声明提升到当前作用域的最前面 <strong>不调用函数</strong></p></li></ol><p>例：    </p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;fun();                 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;         <span class="hljs-built_in">console</span>.log(num);          <span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span>;          &#125;</code></pre><p>相当于</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num;<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> num;<span class="hljs-built_in">console</span>.log(num);num = <span class="hljs-number">20</span>;&#125;num = <span class="hljs-number">10</span>fun();</code></pre><p>最后结果是undefined（就近原则）</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>JavaScript中，对象是一组无序的相关属性和方法的集合，例如字符串、数值、数组、函数等。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h3><p><strong>对象字面量</strong>：就是花括号**{}**里面包含了表达这个具体事物（对象）的属性和方法。</p><p><strong>使用对象</strong>：</p><p>（1）  调用对象的属性 用  对象名 <strong>.</strong> 属性名</p><p>（2）  调用属性还有一种方法 对象吗[‘属性名’] 方括号内一定要有引号</p><p>（3）  调用方法  对象名 <strong>.</strong> 方法()</p><h3 id="new-Object创建对象"><a href="#new-Object创建对象" class="headerlink" title="new Object创建对象"></a>new Object创建对象</h3><p>var 对象名 = new Object();</p><p>对象名.属性名 = 属性值  //创建新的属性</p><p>对象名.方法名 = function（）{} //创建新的方法</p><h3 id="利用构造函数创建对象"><a href="#利用构造函数创建对象" class="headerlink" title="利用构造函数创建对象"></a>利用构造函数创建对象</h3><p>构造函数 就是把对象里面一些相同的属性和方法抽象出来封装到函数里面</p><p>function 构造函数名（）{</p><p>  this.属性 = 值；</p><p>  this.方法 = function () {}</p><p>}</p><p>new 构造函数名（）；</p><p>注意: 1.构造函数名字首字母要大写</p><p>2.构造函数不需要return 就可以返回结果</p><p>3.调用构造函数必须使用new</p><p>4.属性和方法前面必须要添加this</p><h2 id="构造函数和对象的关系"><a href="#构造函数和对象的关系" class="headerlink" title="构造函数和对象的关系"></a>构造函数和对象的关系</h2><ol><li><p> 构造函数泛指某一大类，它类似java中的类（class）</p></li><li><p> 对象特指是一个具体的事物 </p></li><li><p> 我们利用构造函数创建对象的过程我们称之为<strong>对象的实例化</strong></p></li></ol><h2 id="new执行步骤"><a href="#new执行步骤" class="headerlink" title="new执行步骤"></a>new执行步骤</h2><ol><li><p> 在内存中创建一个新的空对象</p></li><li><p> 让this指向这个新的对象</p></li><li><p> 执行构造函数里面的代码，给这个新对象添加属性和方法</p></li><li><p> 返回这个新对象（所以构造函数里面不需要return）</p></li></ol><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><p>for in 遍历对象</p><p>例：</p><p>for (var k in obj){</p><p> console.log(k); //k 变量 输出得到的是<strong>属性名</strong></p><p>console.log(obj[k]); //obj[k] 得到的是<strong>属性值</strong></p><p>}</p><p>使用for in 里面的变量，我们喜欢用k 或者 key （习惯，就像i ,j）</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>JavaScript中的对象分为3种：自定义对象、内置对象、浏览器对象</p><p>前两种对象是js基础内容，属于ECMAScript；第三个浏览器对象属于JS独有的。</p><p>内置对象就是指js语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基础而必要的功能（属性和方法）</p><p>查文档：MDN</p><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p>Math对象不是构造函数，它具有数学常数和函数的属性和方法，跟数学相关的运算。</p><p>Math.max() 最大值</p><p>Math.min() 最小值</p><p>Math.PI 圆周率</p><p>Math.abs() 绝对值 (隐式转换 会把字符串中的 -1 转换为数字型</p><p>Math.floor() 向下取整(取最小的整数)</p><p>Math.ceil() 向上取整（取最大的整数）</p><p>Math.round() 四舍五入 其他数字都是四舍五入</p><p>Math.random() 不跟参数，返回随机小数 0&lt;= x &lt;1</p><h1 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h1><h2 id="JS的组成"><a href="#JS的组成" class="headerlink" title="JS的组成"></a>JS的组成</h2><p>WebAPIs是JS所独立的部分，主要实现交互功能。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/123.png"></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>API（应用程序编程接口）</strong>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p><p>简单理解：<strong>API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。</strong></p><p><strong>Web API是浏览器</strong>提供的一套操作<strong>浏览器功能</strong>和<strong>页面元素</strong>的API（BOM和DOM）。主要针对于浏览器做交互效果。</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h2><p>文档对象模型（Document Object Model，简称<strong>DOM</strong>），是W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准<strong>编程接口</strong>。</p><p>W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/dom.png"></p><p>文档：一个页面就是一个文档，DOM中使用document表示</p><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p><p>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示</p><p><strong>DOM把以上内容都看做是对象</strong></p><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>(因为我们文档页面是从上往下加载，所以先得有标签 所以我们script写到标签的下面)</p><h3 id="1-根据ID获取"><a href="#1-根据ID获取" class="headerlink" title="1.根据ID获取"></a>1.根据ID获取</h3><p><strong>getElementById(id) //参数id是大小写敏感的字符串，所以要‘ ’ 返回的是Element对象</strong></p><p><strong>console.dir</strong> <strong>打印我们返回的元素对象 更好的查看里面的属性和方法</strong></p><h3 id="2-根据标签名获取"><a href="#2-根据标签名获取" class="headerlink" title="2.根据标签名获取"></a>2.根据标签名获取</h3><p><strong>getElementsByTagName(TagName) //返回的是 获取的元素对象的集合 以伪数组的形式存储的（没有数组方法）</strong></p><p><strong>得到的对象是动态的</strong></p><p><strong>element.getElementsByTagName()</strong> <strong>可以获取这个元素中的某些标签</strong></p><p><strong>例：var nav = document.getElementById(id)</strong></p><p><strong>nav. getElementsByTagName(Tagname)</strong></p><h3 id="3-通过HTML5新增方法获取"><a href="#3-通过HTML5新增方法获取" class="headerlink" title="3.通过HTML5新增方法获取"></a>3.通过HTML5新增方法获取</h3><p><strong>document.getElementsByClassName(‘类名’); // 根据类名返回元素对象集合</strong></p><p><strong>document.querySelector(‘选择器‘); // 根据指定选择器返回</strong>第一个<strong>元素对象</strong></p><p><strong>里面的选择器要加符号 id：#、 class：.</strong></p><p><strong>document.querySelectorAll(); // 返回指定选择器的所有元素对象集合</strong></p><h3 id="4-获取特殊元素"><a href="#4-获取特殊元素" class="headerlink" title="4.获取特殊元素"></a>4.获取特殊元素</h3><p><strong>document.body // 获取body标签，返回body对象</strong></p><p><strong>document.documentElement // 返回html对象</strong></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是由三部分组成 事件源 事件类型 事件处理程序</p><ol><li><p> 事件源：事件被触发的对象</p></li><li><p> 事件类型：如何触发 什么事件 </p></li><li><p> 事件处理程序：通过一个函数赋值的方式 完成</p></li></ol><p>例：var btn = document.getElementById(‘btn’)</p><p>btn.onclick = function() { }</p><p><strong>步骤</strong>：获取事件源——注册事件——添加事件处理程序（采用函数赋值形式）</p><h3 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h3><p><strong>onClick</strong>：鼠标点击事件，多用在某个对象控制的范围内的鼠标点击</p><p>onDblClick：鼠标双击事件</p><p><strong>onfocus</strong>：获得鼠标焦点触发</p><p><strong>onblur</strong>：失去鼠标焦点触发</p><p><strong>onMouseDown</strong>：鼠标上的按钮被按下了</p><p><strong>onMouseUp</strong>：鼠标按下后，松开时激发的事件</p><p><strong>onMouseOver</strong>：当鼠标移动到某对象范围的上方时触发的事件</p><p><strong>onMouseMove</strong>：鼠标移动时触发的事件</p><p><strong>onMouseOut</strong>：当鼠标离开某对象范围时触发的事件</p><p>onKeyPress：当键盘上的某个键被按下并且释放时触发的事件</p><p><strong>onKeyDown</strong>：当键盘上某个按键被按下时触发的事件</p><p><strong>onKeyUp</strong>：当键盘上某个按键被按放开时触发的事件</p><h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><p><strong>element.innerText</strong>：从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉</p><p><strong>element.innerHTML</strong>：起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</p><p>区别：</p><p>1.innerText不识别html标签，innerHTML识别</p><p>2.innerText是非标准 innerHTML是W3C标准</p><h2 id="表单属性操作"><a href="#表单属性操作" class="headerlink" title="表单属性操作"></a>表单属性操作</h2><p>type、value、checked、selected、disabled</p><p>表单里面的值 文字内容是通过value来修改</p><p>表单禁用，disabled=true</p><h2 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h2><p><strong>element.style</strong> <strong>行内样式操作即修改具体样式</strong></p><p><strong>element.className</strong> <strong>类名样式操作即修改类名</strong></p><p>注意：</p><p><strong>1.JS里面的样式采取驼峰命名法 比如 fontSize、backgroundColor</strong></p><p><strong>2.JS修改style样式操作，产生的是行内样式，css权重比较高</strong></p><h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>去除其他元素独特的样式，给自己添加的独特样式</p><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p>即我们可以自定义元素的属性 应用：tab页</p><p><strong>获取</strong>属性方法：</p><p>1.获取元素的属性值——<strong>element.属性</strong> 先get元素，再得属性值</p><p>2.<strong>element.getAttribute(‘属性’)</strong> </p><p><strong>设置</strong>元素属性值1. <strong>element.属性 = ‘值’</strong> 设置内置的属性值</p><p><strong>2. element.setAttribute(‘属性’，值)</strong> 主要针对<strong>自定义属性</strong>，也可以改内置属性</p><p>注意：class比较特殊，里面是class，不是className</p><p><strong>移除</strong>属性方法：<strong>element.removeAttribute(‘属性’)</strong></p><h2 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h2><p><strong>自定义属性目的：是为了保存并使用数据。有些数据可以保持到页面中而不用保存到数据库中。</strong></p><p>H5规定自定义属性**data-**开头做为属性名并且赋值。</p><p>比如：&lt;div data-index=””&gt;&lt;/div&gt;</p><p>H5新增的获取自定义属性方法：<strong>element.dataset.index (就不用再加data-)</strong></p><p>注意：只能获取data-的自定义属性，兼容ie11以上版本</p><p><strong>dataset是一个集合里面存放了所有以data-开头的自定义属性</strong></p><p>注意：如果自定义属性里面有多个-链接的单词，我们获取的时候采取驼峰命名法。（例：data-list-name —— element.dataset.listName）</p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><ol><li>利用DOM提供的方法获取元素</li></ol><p>缺点：逻辑性不强、繁琐</p><ol start="2"><li>利用节点层级关系获取元素</li></ol><p>利用父子兄节点关系获取元素</p><p>特点：逻辑性强，但是兼容性稍差</p><p><strong>节点描述</strong>：一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><p>元素节点 nodeType 为 1</p><p>属性节点 nodeType 为 2</p><p>文本节点 nodeType 为 3</p><p><strong>节点层级</strong>：利用DOM树可以把节点划为不同的层级关系，最常见的是父子兄级关系</p><h3 id="父节点parentNode"><a href="#父节点parentNode" class="headerlink" title="父节点parentNode"></a>父节点parentNode</h3><p><strong>element.parentNode</strong>得到离元素最近的父级节点，如果找不到，返回为null</p><h3 id="子节点childNodes"><a href="#子节点childNodes" class="headerlink" title="子节点childNodes"></a>子节点childNodes</h3><p>parentNode.childNodes（标准） 返回包含指定节点的子节点的集合</p><p><strong>注意：返回值里面包含了所有的子节点，包括元素节点、文本节点等</strong></p><p><strong>如果只想获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes</strong></p><p><strong>子节点children</strong></p><p>parentNode.children（非标准）<strong>获取所有的子元素节点，虽然是非标准，但是得到了各个浏览器的支持。（常用）</strong></p><p><strong>子节点 firstChild</strong> 获得第一个子节点（不管是文本还是元素）</p><p><strong>子节点 lastChild</strong> 获得最后一个子节点（不管是文本还是元素）</p><p><strong>子节点 firstElementChild</strong> 返回第一个子元素节点</p><p><strong>子节点 lastElementChild</strong> 返回最后一个子元素节点</p><p>上两种方法兼容IE9以上版本</p><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><p><strong>node.nextSibling</strong> 返回当前元素的下一个兄弟节点（包括文本，元素），找不到返回null</p><p><strong>node.previousSibling</strong> 返回当前元素上一个兄弟节点</p><p><strong>node.nextElementSibling</strong> 返回当前节点的下一个兄弟元素节点</p><p><strong>node.previousElementSibling</strong> 返回当前节点的上一个兄弟元素节点</p><p>上两种方法兼容IE9以上版本</p><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p><strong>document.createElement(‘tagName’)</strong> 创建由tagName指定的HTML元素。因为这些元素原先不存在，是动态生成的。</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p><strong>1.node.appendChild(child)</strong> 将一个节点添加到指定父节点的子节点列表末尾。后面追加元素，类似于伪元素after</p><p>node（父级）child（子级）</p><p><strong>2.node.insertBefore(child,</strong> <strong>指定元素)</strong> 将添加父元素的指定子元素的前面添加。</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>node.removeChild(child) 方法从DOM中删除一个子节点，返回删除的节点</p><p>阻止链接跳转需要添加<strong>javascript:void(0);</strong> 或者 **javascript:; **在 a href=” ”中</p><h3 id="复制节点（克隆节点）"><a href="#复制节点（克隆节点）" class="headerlink" title="复制节点（克隆节点）"></a>复制节点（克隆节点）</h3><p>node.cloneNode() 返回调用该方法的节点的一个副本。</p><p>例：ul.children[0].cloneNode()</p><p>注意：括号为空或者里面是false 进行的是浅拷贝，只复制标签不复制里面的内容，改为true就是深拷贝，复制里面的所有内容。</p><h3 id="三种动态创建元素区别"><a href="#三种动态创建元素区别" class="headerlink" title="三种动态创建元素区别"></a>三种动态创建元素区别</h3><p><strong>document.write()</strong> </p><p><strong>element.innerHTML</strong></p><p><strong>document.createElement()</strong></p><p><strong>区别</strong></p><ol><li>document.write()是直接将内容写入页面的内容流，但是当页面文档流加载完毕，则它会导致页面全部重绘。</li></ol><p>2.innerHTML是将内容写入某个DOM节点，不会导致页面全部重绘</p><p>3.innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</p><p>4.createElement() 创建多个元素效率稍低一点点，但是结构更清晰</p><h2 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h2><h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p><strong>1.传统注册方式</strong></p><p>利用on开头的事件onclick </p><p>特点：注册事件的唯一性 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数。</p><p><strong>2.方法监听注册方式</strong></p><p>w3c标准 推荐方式</p><p><strong>addEventListener()</strong> 它是一个方法</p><p>IE9之前的IE不支持此方法，可使用attachEvent()代替</p><p>特点：同一个元素同一个事件可以注册多个监听器  按照注册顺序依次执行</p><p><strong>addEventListener事件监听方式</strong></p><p><strong>eventTarget.addEventListener(type, listener[, useCapture])</strong></p><p>eventTarget.addEventListener()方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，就会执行事件处理函数。</p><p>该方法接收三个参数：</p><p>type:事件类型字符串，比如click、mouseover，注意这里不要带on</p><p>listener：事件处理函数，事件发生时，会调用该监听函数</p><p>useCapture：可选参数，是一个布尔值，默认时false。</p><p><strong>attachEvent</strong> <strong>事件监听方式（非标准，了解一下）</strong></p><p>eventTarget.attachEvent()方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p><p>该方法接收两个参数：</p><p>eventNameWithOn：事件类型字符串，比如onclick、onmouseover，这里要带on</p><p>callback：事件处理函数，当目标触发事件时会回调函数被调用</p><h3 id="删除事件（解绑事件）"><a href="#删除事件（解绑事件）" class="headerlink" title="删除事件（解绑事件）"></a>删除事件（解绑事件）</h3><p><strong>1.传统注册方式</strong></p><p><strong>eventTarget.onclick = null</strong></p><p><strong>2.方法监听注册方式</strong></p><p><strong>eventTarget.removeEventListener(type, listener[,useCapture]);</strong></p><p>注意函数不能是匿名函数，兼容性问题（跟add一样）</p><p><strong>eventTarget.detachEvent(eventNameWithOn, callback);</strong></p><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件流描述的是从页面中接收事件的顺序</p><p>事件发生时会在元素节点之间按照特定的传播，这个传播过程即DOM事件流</p><p>DOM事件流分三个阶段：捕获阶段 当前目标阶段 冒泡阶段</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/684645.png"></p><p>事件冒泡：IE最早提出，事件开始时有最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程。</p><p>事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到具体的元素接收的过程。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/861.png"></p><p><strong>注意</strong></p><ol><li><p>JS代码中只能执行捕获或者冒泡其中的一个阶段</p></li><li><p>onclick和attachEvent只能得到冒泡阶段</p></li><li><p>addEventListener（type，listener[,useCapture]）第三个参数如果为true，表示事件捕获阶段调用事件处理程序；如果为false（默认为false），则在事件冒泡阶段调用事件处理程序。</p></li><li><p>实际开发很少使用事件捕获</p></li><li><p>有些事件没有冒泡，比如onblur、onfocus、onmouseover、onmouseleave</p></li></ol><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ol><li><p>event就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看</p></li><li><p>事件对象只有有了对象才会存在，它是系统给我们自动创建的，不需要我们传递参数</p></li><li><p>事件对象是我们事件的<strong>一系列相关数据的集合</strong> 跟事件相关的 <strong>有很多属性和方法</strong> 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标，如果是键盘事件就包含了键盘事件的信息</p></li><li><p><strong>这个事件对象我们可以自己命名 比如event、evt、e</strong></p></li><li><p>事件对象也有兼容性问题 ie678通过window.event </p></li></ol><p><strong>兼容性写法e = e | | window.event</strong></p><ol start="6"><li>event是个形参，不需要传递实参过去</li></ol><h4 id="事件对象常见的属性和方法"><a href="#事件对象常见的属性和方法" class="headerlink" title="事件对象常见的属性和方法"></a>事件对象常见的属性和方法</h4><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E4%BA%8B%E4%BB%B6.png"></p><p>1.<strong>e.target</strong>返回的是<strong>触发事件的对象</strong>（元素） <strong>this</strong>返回的是<strong>绑定事件的对象</strong>（元素）</p><p>2.了解一下 跟this有个相似的属性 currentTarget ie678不兼容</p><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><p><strong>标准写法：利用事件对象里面的stopPropagation（）方法</strong></p><p>兼容性：再添加判断条件 使用e.cancelBubble = true</p><h4 id="事件委托（代理、委派）"><a href="#事件委托（代理、委派）" class="headerlink" title="事件委托（代理、委派）"></a>事件委托（代理、委派）</h4><p><strong>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</strong></p><p>作用：操作一次DOM，提高了程序性能</p><p>关键：就是把事件绑定在父节点上</p><h3 id="常见鼠标事件"><a href="#常见鼠标事件" class="headerlink" title="常见鼠标事件"></a>常见鼠标事件</h3><ol><li>禁止鼠标右键菜单</li></ol><p><strong>contextmenu</strong>主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p><ol start="2"><li>禁止鼠标选中</li></ol><p><strong>selectstart（开始选中）</strong></p><p><strong>鼠标事件对象（MouseEvent）</strong></p><p> 1.鼠标在可视区的 X 和 Y 坐标</p><ul><li><p>e.clientX  返回鼠标相对于浏览器窗口可视区的坐标X</p></li><li><p>e.clientY  返回鼠标相对于浏览器窗口可视区的坐标Y</p></li></ul><p>2.鼠标在页面文档的 X 和 Y 坐标</p><ul><li><p>e.pageX  返回鼠标相对于页面文档的坐标X  IE9+ 支持</p></li><li><p>e.pageY  返回鼠标相对于页面文档的坐标Y  IE9+ 支持</p></li></ul><p>3.鼠标在电脑屏幕的 X 和 Y 坐标</p><ul><li><p>e.screenX  返回鼠标相对于电脑屏幕的 X 坐标</p></li><li><p>e.screenY  返回鼠标相对于电脑屏幕的 Y 坐标</p></li></ul><p>开发中pageXY比较常用</p><h3 id="常见的键盘事件"><a href="#常见的键盘事件" class="headerlink" title="常见的键盘事件"></a>常见的键盘事件</h3><p><strong>onkeyup</strong>：按键弹起时触发</p><p><strong>onkeydown</strong>：键盘按下时触发</p><p><strong>onkeypress</strong>：键盘按下触发 但是识别不了功能键</p><p>三个事件的执行顺序：keydown -&gt; keypress-&gt; keyup</p><h4 id="键盘事件对象-KeyboardEvent"><a href="#键盘事件对象-KeyboardEvent" class="headerlink" title="键盘事件对象 KeyboardEvent"></a>键盘事件对象 KeyboardEvent</h4><p> <strong>keyCode</strong>：返回该键的ASCII值</p><p>注意：</p><p>1.keyup和keydown事件不区分字母大小写 a和A得到都是65</p><p>2.keypress事件区分字母大小写 a 97 A 65</p><p>注意：keydown和keypress在文本框里面得特点：他们两个事件触发的时候，文字还没有落入文本框中。</p><p>keyup事件触发的时候，文字已经落入文本框里面了</p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM即<strong>浏览器对象模型</strong>，它提供了独立于内容而与<strong>浏览器窗口进行交互的对象</strong>，其核心对象是window</p><p>BOM由一系列相关的对象构成，并且每个对象都提供了很多方法和属性。</p><p>BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分。</p><h2 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h2><p><strong>window对象是浏览器的顶级对象</strong>，它具有双重角色</p><ol><li><p>它是JS访问浏览器窗口的一个接口</p></li><li><p>它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window。对话框都属于window对象方法（alert、prompt等）</p></li></ol><p><strong>注意：window下的一个特殊属性window.name，声明变量尽量不用name</strong></p><h2 id="window对象的常见事件"><a href="#window对象的常见事件" class="headerlink" title="window对象的常见事件"></a>window对象的常见事件</h2><h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><p><strong>window.onload= function(){ }</strong></p><ol><li><p>窗口加载事件，当文档内容（包括图像、脚本文件、CSS文件等）完全加载完成会触发事件，就调用函数。</p></li><li><p>传统的方式注册事件只能写一次，声明多个以最后一个为准。</p></li><li><p>如果用addEventListener则没有限制，没有on</p></li></ol><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><p><strong>document.addEventListener(‘DOMContentLoaded’, function(){ })</strong></p><p>DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片、flash等等</p><p>ie9以上支持</p><p>如果页面图片较多，加载时间长，用DOMContentLoaded事件比较合适</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p><strong>window.onresize = function(){}</strong></p><p><strong>window.addEventLIstener(‘resize’, function(){ })</strong></p><p>window.onresize 是调整窗口大小加载的事件，当触发时就调用的处理函数。</p><p>应用：响应式布局，<strong>window.innerWIdth当前屏幕的宽度</strong></p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p>window.setTimeout(调用函数，[延迟的毫秒数]);</p><p>setTimeout()方法用于设置定时器，该定时器在定时器到期后执行调用函数。</p><ol><li><p> window在调用时可以省略</p></li><li><p> 这个调用函数可以直接写函数，还可以写函数名 还有一个写法‘函数名（）’第三种不推荐（麻烦）</p></li><li><p> 页面中可能有多个定时器，要给定时器加标识符（名字）</p></li></ol><h3 id="停止setTImeout（）定时器"><a href="#停止setTImeout（）定时器" class="headerlink" title="停止setTImeout（）定时器"></a>停止setTImeout（）定时器</h3><p><strong>window.clearTimeout(timeout ID)</strong></p><p>window可以省略</p><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p>window.setInterval(回调函数，[间隔毫秒数]);</p><p>setInterval()方法用于设置定时器，该定时器每隔指定毫秒就执行调用一次函数，不断重复调用。</p><ol><li><p> window在调用时可以省略</p></li><li><p> 这个调用函数可以直接写函数，还可以写函数名 还有一个写法‘函数名（）’第三种不推荐（麻烦）</p></li><li><p> 页面中可能有多个定时器，要给定时器加标识符（名字）</p></li></ol><h3 id="停止setInterval-定时器"><a href="#停止setInterval-定时器" class="headerlink" title="停止setInterval()定时器"></a>停止setInterval()定时器</h3><p>window.clearInterval(intervalID);</p><p>clearInterval()方法取消了先前通过调用setInterval()建立的定时器</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this指向问题 一般情况下this的最终指向的是那个调用它的对象</p><ol><li><p>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</p></li><li><p>方法调用中谁调用this指向谁</p></li><li><p>构造函数中this指向构造函数的实例</p></li></ol><h2 id="JS执行队列"><a href="#JS执行队列" class="headerlink" title="JS执行队列"></a>JS执行队列</h2><h3 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一时间只能做一件事</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>如果执行过程中有一步需要等待很长时间，就会造成页面渲染不连贯。为了解决这个问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。于是，JS中出现了同步和异步。</p><p><strong>同步：</strong>前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</p><p><strong>异步：</strong>如果做一件事花费的时间很长，在做一件事的同时，可以处理其他事情。</p><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>同步任务都在主线程上执行，形成一个执行线。</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>JS的异步是通过回调函数实现的</p><p>一般而言，异步任务有以下三种类型：</p><p>1、    普通事件，如 click、resize等</p><p>2、    资源加载，如load、error等</p><p>3、    定时器，包括setInterval、setTImeout等</p><p>异步任务相关回调函数添加到<strong>任务队列</strong>中（任务队列也称为消息队列）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E6%89%A7%E8%A1%8C.png"></p><h4 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h4><ol><li><p>先执行<strong>执行栈中的同步任务</strong></p></li><li><p>异步任务（回调函数）放入任务队列中。</p></li><li><p>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取<strong>任务队列</strong>中的异步任务，于是被读取的异步任务结束等待状态，进入执行线，开始执行。</p></li></ol><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为<strong>事件循环（event loop）</strong>。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/qd516.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/1d56w.png"></p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>window对象给我们提供了一个<strong>location属性</strong>用于<strong>获取或设置窗体的URL</strong>，并且可以用于<strong>解析URL</strong>。因为这个属性返回的是一个对象，所以我们将这个属性也称为<strong>location对象</strong>。</p><p>URL：统一资源定位符（Uniform Resource Locator，URL）是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p>URL的一般语法格式为：</p><p> <strong>protocol://host[:port]/path/[?query]#frament</strong></p><p>例：<a href="http://www.amaodama.com/index.html?name=amao&amp;age22#link">http://www.amaodama.com/index.html?name=amao&amp;age22#link</a></p><p>protocol：通信协议 常用的http,ftp,maito等等</p><p>host：主机（域名）</p><p>port：端口号 可选，省略时使用方案的默认端口，如http的默认端口为80</p><p>path：路径 由 零或多个‘/’符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</p><p>query：参数 以键值对的形式，通过&amp;符号分隔开来</p><p>fragment：片段#后面内容 常见于链接锚点</p><h3 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage014.png"></p><p><strong>重点记住：href和search</strong></p><h3 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage015.png"></p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象<strong>包含有关浏览器的信息</strong>，它有很多属性，最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值。即得知是什么浏览器。</p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>该对象包含用户（在浏览器窗口中）访问过的URL</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage016.png"></p><h1 id="PC端网页特效"><a href="#PC端网页特效" class="headerlink" title="PC端网页特效"></a>PC端网页特效</h1><h2 id="元素offset系列"><a href="#元素offset系列" class="headerlink" title="元素offset系列"></a>元素offset系列</h2><h3 id="offset概述"><a href="#offset概述" class="headerlink" title="offset概述"></a>offset概述</h3><p>offset翻译过来就是偏移量，使用offset系列相关属性可以<strong>动态的</strong>得到该属性的位置（偏移）、大小等。</p><ul><li>获得元素距离带有定位父元素的位置</li></ul><ul><li>获得元素自身的大小</li></ul><p><strong>注意：返回的数值都不带单位</strong></p><h3 id="offset系列常用属性"><a href="#offset系列常用属性" class="headerlink" title="offset系列常用属性"></a>offset系列常用属性</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage017.png"></p><p>element.parentNode也可以返回父节点，返回的是最近一级的父节点。</p><p>element.offsetParent返回带有定位的父节点</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage018.png"></p><h3 id="offset和style区别"><a href="#offset和style区别" class="headerlink" title="offset和style区别"></a>offset和style区别</h3><p><strong>offset</strong></p><p>offset可以得到任何样式表中的样式值</p><p>offset系列获得的数值是没有单位的</p><p>offsetWIdth包含padding + border + width</p><p>offsetWidth等属性是只读属性，只能获取不能赋值</p><p>获取元素大小位置，用offset更合适</p><p><strong>style</strong></p><p>style只能得到行内样式表的样式值</p><p>style.width获得的是带有单位的</p><p>style可以赋值</p><p>给元素位置赋值，用style更合适</p><h2 id="元素可视区client系列"><a href="#元素可视区client系列" class="headerlink" title="元素可视区client系列"></a>元素可视区client系列</h2><p>client就是客户端，使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage019.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage020.png"> </p><p><strong>立即执行函数（function () {}）() 或者 （function（）{}（））</strong></p><p><strong>立即执行函数最大的作用是 独立创建了一个作用域，避免了命名冲突问题</strong></p><p><strong>pageshow： 重新加载页面触发的事件 添加给window</strong></p><h2 id="为什么用pageshow不用load事件？"><a href="#为什么用pageshow不用load事件？" class="headerlink" title="为什么用pageshow不用load事件？"></a>为什么用pageshow不用load事件？</h2><p><strong>有三种情况会刷新页面触发load事件：a标签的超链接、F5或者刷新按钮、前进后退按钮</strong></p><p><strong>但是火狐浏览器有“往返缓存”，保存了DOM和JavaScript的状态；此时后退按钮不能刷新页面。</strong></p><p><strong>这时候可以使用pageshow事件触发。这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发。</strong></p><p>根据事件对象中的<strong>persisted</strong>来判断<strong>是否是缓存中的页面触发</strong>的pageshow事件。</p><h2 id="元素滚动scroll系列"><a href="#元素滚动scroll系列" class="headerlink" title="元素滚动scroll系列"></a>元素滚动scroll系列</h2><p>scroll翻译过来就是滚动，scroll系列相关属性可以动态的得到该元素的大小、滚动距离。<strong>（元素内容的实际高度大小）</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage021.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage022.png"></p><p><strong>页面被卷去的头部：可以通过window.pageYOffset获得 如果是被卷去的左侧 window.pageXOffset</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage023.png"></p><p>DTD：<!DOCTYPE html></p><p><strong>三个系列对比</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage024.png"></p><p>主要用法：</p><ol><li><p>offset系列经常用于获得元素位置 <strong>offsetLeft offsetTop</strong></p></li><li><p>client经常用于获取元素大小 <strong>clientWidth clientHeight</strong></p></li><li><p>scroll经常用于获取滚动距离 <strong>scrollTop scrollLeft</strong></p></li><li><p>注意页面滚动的距离通过window.pageXOffset获得</p></li></ol><h2 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h2><p>mouseenter和mouseover都是鼠标移到元素上就会触发的事件</p><p>区别：mouseover鼠标<strong>经过自身盒子会触发</strong>，经过<strong>子盒子还会触发</strong>。mouseenter<strong>只会经过自身盒子触发</strong>。之所以这样，就是因为<strong>mouseenter不会冒泡</strong></p><p>跟mouseenter搭配mouseleave，同样也不会冒泡</p><h2 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h2><h3 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h3><p><strong>核心原理</strong>：通过定时器setInterval（）不断移动盒子位置。</p><p>实现步骤：</p><p>1.获得盒子当前位置</p><p>2.让盒子在当前位置加上1个移动距离</p><p>3.利用定时器不断重复这个操作</p><p>4.加一个结束定时器的条件</p><p><strong>5.注意此元素需要添加定位，才能使用element.style.left</strong></p><h3 id="动画函数简单的封装"><a href="#动画函数简单的封装" class="headerlink" title="动画函数简单的封装"></a>动画函数简单的封装</h3><p>注意函数需要传递2个参数，对象和移动距离</p><h3 id="动画函数给不同元素记录不同定时器"><a href="#动画函数给不同元素记录不同定时器" class="headerlink" title="动画函数给不同元素记录不同定时器"></a>动画函数给不同元素记录不同定时器</h3><p>如果多个元素都使用这个动画函数，每次都要var声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）</p><p>核心原理：利用JS是一门动态语言，可以很方便的给当前对象添加属性。</p><h3 id="缓动效果原理"><a href="#缓动效果原理" class="headerlink" title="缓动效果原理"></a>缓动效果原理</h3><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p><p>思路：</p><p>1.让每次移动距离慢慢变小，速度就会慢慢落下来</p><p>2.核心算法：（目标值-当前位置）/ 10 作为每次移动的距离步长</p><p>3.停止条件：让当前盒子位置等于目标位置就停止定时器。</p><h3 id="动画函数添加回调函数"><a href="#动画函数添加回调函数" class="headerlink" title="动画函数添加回调函数"></a>动画函数添加回调函数</h3><p><strong>回调函数原理：</strong>函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。</p><h3 id="动画函数封装到单独JS文件里面"><a href="#动画函数封装到单独JS文件里面" class="headerlink" title="动画函数封装到单独JS文件里面"></a>动画函数封装到单独JS文件里面</h3><p>经常用到这个函数，就单独创建js文件，把函数放进去。</p><p>轮播图</p><p>图片放在一个大ul，通过移动ul实现滚动效果。</p><p>无缝滚动效果：在最后一张后面复制一份第一张克隆，等到达克隆张，下次点击快速到达第一张，</p><p><strong>节流阀</strong></p><p>目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p><p>题外话：</p><p>if（callback）{callback（）；} == callback &amp;&amp; callback（）；</p><p>运用了短路运算符的特性，当两个都为true时，才会调用函数。</p><h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><p>window.scroll(x, y); 里面的xy不跟单位；</p><h1 id="移动端特效"><a href="#移动端特效" class="headerlink" title="移动端特效"></a>移动端特效</h1><h3 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h3><p>移动端浏览器兼容性较好，不需要考虑JS兼容性问题。但移动端也有独特的地方，比如触屏事件touch。</p><p>touch对象代表一个触摸点。</p><p>常见的触屏事件如下</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage025.png"></p><h4 id="触摸事件对象"><a href="#触摸事件对象" class="headerlink" title="触摸事件对象"></a>触摸事件对象</h4><p>每个事件都有对象产生</p><p>触摸事件对象常见的对象类别：</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage026.png"></p><p>如果监听的是一个DOM元素，touches和targetTouches一样。</p><p>手指离开屏幕，只有changedTouches还在。</p><p>一般都是触摸元素，最经常用targetTouches。</p><p><strong>注意：手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault();</strong></p><h3 id="移动端轮播图"><a href="#移动端轮播图" class="headerlink" title="移动端轮播图"></a>移动端轮播图</h3><p>要前后放两张图片（第一张和最后一张），同时为了显示第一张图片，ul要margin-left：-100%；移动一张图片的位置。</p><p>transitionend：过渡效果结束的时候触发。</p><h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。</p><p>添加类名：classList.add(‘类名’);</p><p>移除类名：classList.remove(‘类名’)；</p><p>切换类名：classList.toggle(‘类名’); //原来有就删除，没有就添加。</p><h3 id="click延时解决方案"><a href="#click延时解决方案" class="headerlink" title="click延时解决方案"></a>click延时解决方案</h3><p>点了第一下，300ms没有点第二下，就判断是点击。</p><p>移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放页面。</p><p>解决方案：</p><ol><li>禁用缩放。浏览器禁用默认的双击缩放行为并且去掉300ms的点击延迟。</li></ol><meta name=”viewport” content=”user-scalable=no”>2. 利用touch事件自己封装这个事件解决300ms延迟。<ol start="3"><li>利用fastclick插件解决（GitHub上找）</li></ol><p><strong>视频插件：zy.media.js</strong></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。</p><p>常用框架：bootstrap、vue、angular、react等</p><p>移动端常用插件：swiper、superslide、iscroll等</p><p>框架：大而全，一整套解决方案</p><p>插件：小而专一，某个功能的解决方案</p><h1 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h1><p>特性：1.数据存储在用户浏览器中</p><p>2.设置、读取方便、甚至页面刷新不丢失数据</p><p>3.容量较大，sessionStorage约5M、localStorage约20M</p><p>4.只能存储字符串，可以将对象JSON.stringfy()编码后存储</p><h2 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h2><ol><li><p>生命周期为<strong>关闭浏览器窗口</strong>（即关闭浏览器就消失）</p></li><li><p>在同一个窗口（页面）下数据可以共享</p></li><li><p>以键值对的形式存储使用</p></li></ol><p>存储数据：sessionStorage.setItem(key, value);</p><p>获取数据：sessionStorage.getItem(key);</p><p>删除数据：sessionStorage.removeItem(key);</p><p>清空数据：sessionStorage.clear();</p><h2 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h2><ol><li><p>生命周期<strong>永久生效</strong>，除非手动删除</p></li><li><p>可以多窗口（页面）共享（同一浏览器可以共享）</p></li><li><p>以键值对的形式存储使用</p></li></ol><p>存储数据：localStorage.setItem(key, value);</p><p>获取数据：localStorage.getItem(key);</p><p>删除数据：localStorage.removeItem(key);</p><p>清空数据：localStorage.clear();</p><p>change: 状态改变触发事件。</p><h1 id="JavaScript面向对象"><a href="#JavaScript面向对象" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h1><h2 id="面向对象编程介绍"><a href="#面向对象编程介绍" class="headerlink" title="面向对象编程介绍"></a>面向对象编程介绍</h2><p>面向过程（POP）就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p><p>即面向过程就是分析好问题，按步骤解决。</p><p>面向对象（OOP）是把事务分解成为一个个对象，然后由对象之间分工与合作。</p><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。</p><p>面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</p><p>特性：<strong>封装性 继承性 多态性</strong></p><p>缺点：面向对象性能比面向过程低</p><p><strong>通俗的讲：用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭</strong></p><h2 id="ES6中的类与对象"><a href="#ES6中的类与对象" class="headerlink" title="ES6中的类与对象"></a>ES6中的类与对象</h2><p><strong>在JavaScript中，对象是一组无序的相关属性和方法集合，所有事物都是对象。</strong></p><p>对象是由<strong>属性</strong>和<strong>方法</strong>组成的：</p><p>属性：事物的<strong>特征</strong>，在对象中用<strong>属性</strong>来表示</p><p>方法：事物的<strong>行为</strong>，在对象中用<strong>方法</strong>来表示</p><p>类：class ES6新增了类的概念 类抽象了对象的公共部分，它<strong>泛指</strong>某一大类（class）<strong>对象</strong>特指某一个，通过<strong>类</strong>实例化一个具体对象</p><p>面向对象的思维特点：</p><ol><li><p>抽取（抽象）对象共用的属性和行为组织（封装）成一个<strong>类</strong>（模板）</p></li><li><p>对类进行实例化，获取类的<strong>对象</strong></p></li></ol><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>语法：class name{ //class body} 创建实例： var xx = new name（）；</p><p><strong>注意：类必须使用new实例化对象</strong></p><h3 id="类constructor构造函数"><a href="#类constructor构造函数" class="headerlink" title="类constructor构造函数"></a>类constructor构造函数</h3><p><strong>constructor（）</strong>方法是类的构造函数（默认方法），<strong>用于传递参数，返回实例对象</strong>，通过new命令生成对象实例时，自动调用该方法。如果没有显示定义，类内部会自动给我们创建一个<strong>constructor（）</strong></p><p>注意</p><ol><li><p>通过class关键字创建类，<strong>类名我们还是习惯性定义首字母大写</strong></p></li><li><p>类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象</p></li><li><p>constructor函数只要new生成实例时，就会自动调用这个函数，如果我们不写这个函数，类也会自动生成这个函数</p></li><li><p>生成实例new不能省略</p></li><li><p>最后注意语法规范，创建类 类名后面不要加小括号，生成实例 类名后面加小括号，<strong>构造函数不需要加function</strong></p></li><li><p>多个函数和方法之间不需要逗号分隔</p></li></ol><h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><p>子类可以继承父类，使用父类中的属性和方法。</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p><strong>super关键字</strong>用于访问和调用对象父类上的函数。<strong>可以调用父类的构造函数（super(参数)）</strong>，也可以调用父类的普通函数（**super.方法()**）。</p><p>1.继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的这个方法。如果没有就查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原则）</p><p>2.<strong>super必须在this前面调用</strong></p><p><strong>注意点</strong></p><ol><li><p>在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p></li><li><p>类里面的共有的属性和方法一定要加this使用。</p></li><li><p>类里面的this指向问题</p></li><li><p>constructor里面的this指向实例对象，方法里面的this指向这个方法的调用者</p></li></ol><p><strong>添加元素高级做法</strong>：利用**insertAdjacentHTML(position, text)**可以直接把字符串格式元素添加到父元素中。</p><p><strong>position参数</strong></p><p><strong>beforebegin:元素自身的前面</strong></p><p><strong>afterbegin:插入元素内部的第一个子节点之前<br> beforeend:插入元素内部的最后一个子节点之后</strong></p><p><strong>afterend:元素自身的后面</strong></p><p><strong>remove()</strong> <strong>可以删除指定的元素 例：element.remove();</strong></p><h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在典型的OOP的语言中（如java），都存在类的概念，类就是对象的模板，对象就是类的实例，但是在ES6之前没有类的概念。</p><p>创建对象可以通过以下三种方式：</p><ol><li><p>对象字面量   例：var xx = {}</p></li><li><p>new Object（）</p></li><li><p>自定义构造函数</p></li></ol><p><strong>构造函数</strong>时一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在js中，使用构造函数时要注意以下两点：</p><ol><li><p>构造函数用于创建某一类对象，其<strong>首字母要大写</strong></p></li><li><p>构造函数要<strong>和new一起使用</strong>才有意义</p></li></ol><p>静态成员 在构造函数本身上添加的成员 sex就是静态成员</p><p>静态成员只能通过构造函数来访问</p><p>构造函数问题：<strong>存在浪费内存的问题</strong></p><h3 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h3><p>构造函数通过原型分配的函数是所有对象所<strong>共享</strong>的。</p><p>JavaScript规定，<strong>每一个构造函数都有一个prototype属性</strong>，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p><strong>我们可以把一些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。</strong></p><p>原型的作用是什么？<strong>共享方法</strong></p><p>语法：函数名.prototype.方法 = function（）{}</p><p>所以，一般情况下，公共属性定义到构造函数里面，公共的方法放到原型对象身上</p><h3 id="对象原型proto"><a href="#对象原型proto" class="headerlink" title="对象原型proto"></a>对象原型proto</h3><ul><li><p><strong>对象都会有一个属性<strong>proto</strong></strong>指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有__proto__原型的存在。（即__proto__对象原型和原型对象prototype是等价的）</p></li><li><p>__proto__是非标准的，实际开发不可以使用这个属性。他只是内部指向原型对象prototype的一条路线。</p></li></ul><p>方法查找原则：查找对象身上是否有指定方法，因为有__proto__，就接着查找构造函数原型对象prototype身上去查找。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage027.png"></p><h3 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h3><p>如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须<strong>手动的利用constructor指向</strong>原来的构造函数</p><p>例：函数名.prototype = { //通过这个方式给原型添加多个方法，但这样就把原来原型的方法覆盖掉了</p><p>constructor：函数名，//指回原来的构造函数</p><p>}</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage028.png"></p><h4 id="JS成员的查找机制"><a href="#JS成员的查找机制" class="headerlink" title="JS成员的查找机制"></a>JS成员的查找机制</h4><ol><li><p>当访问一个对象的属性（包括方法）时，首先查找这个<strong>对象自身</strong>有没有该属性。</p></li><li><p>如果没有就查找它的原型（也就是__proto__指向的<strong>prototype原型对象</strong>）。</p></li><li><p>如果还没有就查找原型对象的原型（<strong>Object的原型对象</strong>）。</p></li><li><p>依此类推一直找到Object为止（<strong>null</strong>）。</p></li></ol><h4 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h4><p>一般情况下，this指向的是调用函数的对象。</p><p>原型对象函数里面的this指向的是 实例对象</p><h4 id="扩张内置对象"><a href="#扩张内置对象" class="headerlink" title="扩张内置对象"></a>扩张内置对象</h4><p>可以通过内置对象原型，给内置对象添加方法。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>组合继承：（ES6前）构造函数 + 原型对象 模拟实现继承</p><p>call（） 调用这个函数，并且修改函数运行时的指向</p><p>语法：函数名.call(thisArg, arg1, arg2,—)</p><p><strong>thisArg：当前调用函数this的指向对象</strong></p><h5 id="借用父构造函数继承属性"><a href="#借用父构造函数继承属性" class="headerlink" title="借用父构造函数继承属性"></a>借用父构造函数继承属性</h5><p>例：子构造函数中</p><p>Father.call(this, 属性1，属性2)；//这样子构造函数就可以使用父构造函数中的属性。</p><h5 id="借用原型对象继承方法"><a href="#借用原型对象继承方法" class="headerlink" title="借用原型对象继承方法"></a>借用原型对象继承方法</h5><ol><li>直接赋值（误）</li></ol><p>Son.prototype = Father.prototype //这时候把父构造函数的原型对象地址给了子，子修改原型对象，父也会变化</p><ol start="2"><li>创建父实例，子==父实例</li></ol><p>例: Son.prototype = new Father(); //因为这样覆盖了子的constructor，所以要指回</p><p>Son.prototype.constructor = Son;</p><h2 id="ES5中新增的方法"><a href="#ES5中新增的方法" class="headerlink" title="ES5中新增的方法"></a>ES5中新增的方法</h2><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>迭代方法：</p><p>**forEach()**：遍历数据每一个数据 array.forEach(function(value, index, array){});</p><p><strong>filter():</strong> 主要用于筛选数组，找到所有满足条件的值，返回一个<strong>新数组</strong> arr.filter(function(value, index,array){})</p><p><strong>some():</strong> 检测数组中的元素是否满足指定条件，通俗点 查找数组中是否有满足条件的元素 返回值是<strong>布尔值</strong> 如果找到第一个满足条件的，就停止查找。</p><p>array.some(function(value, index, arr){});</p><p>map（）类似于forEach（）</p><p>every（）类似于some（）</p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>trim() 会从一个字符串的两端删除空白字符</p><p>str.trim() //返回新的字符串</p><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><ol><li><strong>Object.keys()</strong> 用于获取对象自身所有属性 效果类似for。。。in</li></ol><p>Object.keys(obj) //返回一个由属性名组成的数组</p><ol start="2"><li><strong>Object.defineProperty()</strong> 定义对象中新属性或修改原有的属性。</li></ol><p>Object.defineProperty(Obj, prop, descriptor)</p><p>第二个参数是属性名，字符串</p><p>第三个参数是descriptor说明：以对象形式{}书写，其中参数有</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage029.png"></p><p>重写就是修改的意思</p><p>枚举就是遍历的意思</p><p>configurable定义true后属性将不会被修改</p><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><ol><li><p>自定义函数 function fn() {}</p></li><li><p>函数表达式（匿名函数） var fun = function() {}</p></li><li><p>new Function  var fn = new Function(‘参数1’，’参数2’，’函数体’)；</p></li></ol><p>例：var fn = new Function(‘a’,’b’,’console.log(a+b)’);</p><p>不建议使用，效率低，但这种声明方式说明，所有函数都是Function的实例（对象），函数也属于对象</p><h3 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h3><ol><li>普通函数</li></ol><p>function fn() { }  fn();</p><ol start="2"><li>对象方法</li></ol><p>var o = {             o.fn();</p><p>fn: function(){}</p><p>}                 </p><ol start="3"><li>构造函数</li></ol><p>function Star(){}  new Star();</p><ol start="4"><li>绑定事件函数</li></ol><p>btn.onclick = function() {}; </p><ol start="5"><li>定时器函数</li></ol><p>setInterval(function() {}, 1000)</p><ol start="6"><li>立即执行函数</li></ol><p>(function() {})();</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this的指向，是当我们调用函数的时候确定的。调用方式不同决定了this的指向不同。一般指向我们的调用者。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage030.png"></p><p>构造函数this指向实例对象，原型对象中的this也是指向实例对象。</p><h3 id="改变函数内部this指向"><a href="#改变函数内部this指向" class="headerlink" title="改变函数内部this指向"></a>改变函数内部this指向</h3><p>常用的方法有bind(), call(), apply() 三种方法</p><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>语法：fn.call( thisArg, arg1, arg2, —);</p><p>作用：1. 可以调用函数 2. 可以改变函数内部的this指向</p><p>主要应用：可以实现继承</p><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>语法：fn.apply(thisArg, array);</p><p>作用：1. 调用函数 2. 可以改变函数内部的this指向</p><p>但是参数必须是数组（伪数组）</p><p>主要应用：可以利用apply借助于数学内置对象求最大值（ Math.max.apply(null, array) ）</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>语法：fn.bind(thisAsg, arg1, arg2,—-);</p><p>作用：1. <strong>不会调用函数</strong> 2. 可以改变函数内部的this指向</p><p>返回由指定的this值和初始化参数改造的<strong>原函数拷贝</strong></p><p>thisArg：当前调用函数this的指向对象</p><p>arg1,arg2：传递的其他参数</p><h4 id="call-apply-bind-总结"><a href="#call-apply-bind-总结" class="headerlink" title="call(), apply(), bind()总结"></a>call(), apply(), bind()总结</h4><ol><li><p>都可以改变函数内部this指向</p></li><li><p>call和apply可以调用函数，bind不调用函数</p></li><li><p>call、bind的参数一个一个传，apply的参数以数组方式传递</p></li><li><p>call主要用于继承，apply主要用于数组打交道的情况，bind用于不调用函数又要改变内部this指向。</p></li></ol><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES5的严格模式（strict mode）是采用具有限制性JavaScript变体的一种方式，即在严格的条件下运行JS代码。（IE10以上版本浏览器才支持）</p><ol><li><p>消除了JavaScript语法的一些不合理、不严谨之处，减少了一些怪异行为。</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全。</p></li><li><p>提高编译器效率，增加运行速度。</p></li><li><p>禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的JavaScript做好铺垫。比如保留字如class，export，import不能做变量名</p></li></ol><p>严格模式可以应用到整个脚本或个别函数中</p><ol><li>为脚本开启严格模式</li></ol><p>需要<strong>在所有语句之前放一个特定语句“use strict”；(或 ‘use strict’; )</strong></p><ol start="2"><li>为函数开启严格模式</li></ol><p>需要把<strong>“use strict”；(或 ‘use strict’; )声明放在函数体所有语句之前。</strong></p><h4 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h4><ol><li>变量规定</li></ol><ul><li><p><strong>严格模式下，变量都必须先用var命令声明，然后再使用。</strong></p></li><li><p><strong>严禁删除已经声明变量。例如，delete x；语法是错误的。</strong></p></li></ul><ol start="2"><li>严格模式下this指向问题</li></ol><ul><li><p><strong>严格模式下全局作用域函数中的this指向的是underfined</strong></p></li><li><p><strong>严格模式下不加new调用构造函数，会报错</strong></p></li><li><p><strong>定时器this还是指向window</strong></p></li><li><p><strong>事件、对象还是指向调用者</strong></p></li></ul><ol start="3"><li>函数变化</li></ol><ul><li><p><strong>函数不能有重名的参数</strong></p></li><li><p><strong>函数必须声明在顶层。为了与ES6接轨，不允许在非函数的代码块内声明函数。即不能在for、if等有大括号而不是函数的代码块中声明函数。</strong></p></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p><strong>高阶函数</strong>是对其他函数进行操作的函数，它<strong>接受函数作为参数</strong>或<strong>将函数作为返回值输出</strong>。</p><p>函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p><strong>闭包</strong>指有权<strong>访问</strong>另一个函数作用域中<strong>变量</strong>的<strong>函数</strong>。</p><p>简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。</p><p><strong>变量指向的函数就是闭包函数</strong></p><p>闭包的主要作用：<strong>延伸了变量的作用范围，使变量不会被立即释放</strong>。</p><p><strong>立即执行函数也称为小闭包</strong>因为立即执行函数里面的任何一个函数都可以调用它的变量。</p><p>缺点：<strong>比较占用内存</strong></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>定义：如果<strong>一个函数在内部可以调用其本身</strong>，那么这个函数就是<strong>递归函数</strong>。</p><p>由于递归很容易发生栈溢出错误，所以必须要加退出条件return</p><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><ol><li><p>浅拷贝只是拷贝一层，<strong>更深层次对象级别的只拷贝引用</strong></p></li><li><p>深拷贝拷贝多层，每一级别的数据都会拷贝</p></li><li><p><strong>Object.assign(target, …sources)</strong> es6新增方法可以<strong>浅拷贝</strong></p></li></ol><p>深拷贝就是把所有数据都拷贝过来，更深层次而不只是引用地址，从而会可能修改了原数据。深拷贝时要先拷贝数组数据，再拷贝对象。因为数组也属于对象。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><strong>概述：</strong>正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。</p><p>正则表单式里面不用加引号。</p><p>主要用途：</p><ol><li><p>通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户表单只能输入英文字母、数字或者下划线，昵称输入框中可以输入中文（<strong>匹配</strong>）。</p></li><li><p>常用于过滤掉页面内容中的一些敏感词（<strong>替换</strong>），或者从字符串中获取我们想要的特定部分（<strong>提取</strong>）等。</p></li></ol><p>特点：</p><ol><li><p>灵活性、逻辑性和功能性非常强</p></li><li><p>可以迅速的用极简单的方式达到字符串的复杂控制</p></li><li><p>刚开始比较晦涩难懂</p></li></ol><h4 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h4><p><strong>1.</strong>  <strong>通过调用RegExp对象的构造函数创建</strong></p><p>var 变量名 = new RegExp（/表达式/）；</p><p><strong>2.</strong>  <strong>通过字面量创建</strong></p><p>var 变量名 = /表达式/；</p><h4 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h4><p><strong>test（）</strong>正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false</p><p>regexpObj.test(str)</p><ol><li><p>regexp是写的正则表达式</p></li><li><p>str我们要测试的文本</p></li><li><p>就是检测str文本是否符合我们写的正则表达式规范。</p></li></ol><h4 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h4><p>正则表达式的组成</p><p>一个正则表达式<strong>可以由简单的字符构成</strong>，比如/abc/，<strong>也可以是简单和特殊字符的组合</strong>，比如/ab*c/。其中特殊字符也被称为<strong>元字符</strong>，在正则表达式中是具有<strong>特殊</strong>意义的专用<strong>符号</strong>，如^、$、+等。</p><p><strong>边界符</strong></p><p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage031.png"></p><p>/^abc$/意味着精准匹配abc，意为开头是它结尾也是它（同一个它）</p><p><strong>字符类</strong></p><p><strong>[ ]:</strong> 表示有一系列字符可供选择，只要匹配其中一个就可以了。</p><p><strong>-:</strong> 范围符，表示省略中间的字符，例如a-z，0-9</p><p><strong>字符组合：把要的字符都加进去，不用分隔，例如：a-zA-Z0-9_-</strong></p><p><strong>取反符：</strong>如果<strong>中括号里面有^ 表示取反的意思</strong> 和边界符完全不同</p><p><strong>量词符</strong></p><p>量词符用来<strong>设定某个模式的出现的次数</strong></p><p>*<strong>**     **相当于 &gt;=0 可以出现0次或者很多次</strong></p><p><strong>+</strong>     <strong>相对于&gt;=1 可以出现1次或者很多次</strong></p><p><strong>?</strong>     <strong>相当于1 || 0</strong></p><p><strong>{n}</strong>     <strong>就是重复n次</strong></p><p><strong>{n，}    大于等于n次</strong></p><p><strong>{n，m}   大于等于n次并且小于等于m次（中间不要有空格）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage032.png"></p><p><strong>括号总结</strong></p><p><strong>大括号</strong> 量词符，里面表示重复次数</p><p><strong>中括号</strong> 字符集合。匹配方括号中的任意字符。</p><p><strong>小括号</strong> 表示分组</p><p>可以在线测试：<a href="http://c.runoob.com/">http://c.runoob.com/</a></p><p>注意</p><p>/^abc{2}$/ 匹配的是abcc</p><p>/^(abc){2}$/ 匹配的是abcabc</p><p><strong>预定义类</strong></p><p>预定义类指的是<strong>某些常见模式的简写方式</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage033.png"></p><p>小写要，大写不要</p><p><strong>|</strong> <strong>表示或者</strong> 例：/^red | green $/ 匹配red或者green字符串</p><p><strong>替换</strong></p><p>replace替换</p><p>replace（）方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p><p>string.replace(substr/regexp,replacement)</p><p>第一个参数：被替换的字符串或者正则表达式</p><p>第二个参数：替换为的字符串</p><p>返回值是一个替换完毕的新字符串</p><p><strong>正则表达式参数</strong></p><p>/表达式/[switch]</p><p>switch（也称为修饰符）按照什么样的模式来匹配。有三种值：</p><p><strong>g：全局匹配</strong></p><p><strong>i：忽略大小写</strong></p><p><strong>gi：全局匹配 + 忽略大小写</strong></p><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="let变量"><a href="#let变量" class="headerlink" title="let变量"></a>let变量</h2><p>let声明的变量会与当前块级作用域绑定，不被其他块级作用域访问。</p><p>特点：</p><ol><li>let声明的变量只在所处于的块级作用域有效</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>&#125;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span></code></pre><p>例如：for循环中，索引值就不会变成全局变量而访问到，而且每一次循环都保留着它的i值。</p><ol start="2"><li>不存在变量提升</li></ol><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span></code></pre><ol start="3"><li>暂时性死区</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;tmp = <span class="hljs-string">&#x27;abc&#x27;</span><span class="hljs-keyword">let</span> tmp&#125;</code></pre><p>tmp只看当前块级作用域中的变量，不再往上查找。</p><h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>作用：声明常量，常量就是值（内存地址）不能变化的量。</p><p>特点：</p><ul><li>具有块级作用域</li></ul><ul><li>声明常量时必须赋值</li></ul><h2 id="let、const、var区别"><a href="#let、const、var区别" class="headerlink" title="let、const、var区别"></a>let、const、var区别</h2><ol><li><p>使用 <strong>var</strong> 声明的变量，其作用域为<strong>该语句所在的函数内，且存在变量提升现象。</strong> </p></li><li><p>使用 <strong>let</strong> 声明的变量，其作用域为<strong>该语句所在的代码块内，不存在变量提升。</strong> </p></li><li><p>使用 <strong>const</strong> 声明的是常量，在后面出现的代码中<strong>不能再修改该常量的值。</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage037.png"></p></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6中允许从数组或对象中提取值，按照对应位置，对变量赋值。</p><p>如果解构不成功，变量的值为underfined。</p><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;<span class="hljs-keyword">let</span> &#123; name, age &#125; = person<span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// 20</span></code></pre><p>也可以用属性名匹配对象，用变量实际赋值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge &#125; = person<span class="hljs-built_in">console</span>.log(myName) <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><span class="hljs-built_in">console</span>.log(myAge) <span class="hljs-comment">// 20</span></code></pre><h3 id="箭头函数（-gt-）"><a href="#箭头函数（-gt-）" class="headerlink" title="箭头函数（ ( )=&gt; { } ）"></a>箭头函数（ ( )=&gt; { } ）</h3><p>ES6中新增的定义函数的方式。用来简化函数定义语法的。<strong>一般把它赋值给一个变量，变量名就是函数名。</strong></p><p>特点：</p><ul><li>函数体中只有一句代码，且代码的执行结果就是<strong>返回值</strong>，可以省略大括号</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<span class="hljs-keyword">return</span> num1 + num2&#125;<span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> num1 + num2</code></pre><ul><li>如果形参只有一个，可以省略小括号</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">v</span>) </span>&#123;<span class="hljs-keyword">return</span> v&#125;<span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v</code></pre><ul><li>箭头函数不绑定this关键字。如果在箭头函数中使用this，<strong>this关键字指向箭头函数定义位置的this</strong></li></ul><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">first, ...args</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(first)<span class="hljs-built_in">console</span>.log(args)&#125;sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</code></pre><p>注：剩余参可以数和解构配合使用</p><h2 id="Array的扩展方法"><a href="#Array的扩展方法" class="headerlink" title="Array的扩展方法"></a>Array的扩展方法</h2><h3 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h3><ul><li>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]...ary <span class="hljs-comment">// 1, 2, 3</span><span class="hljs-built_in">console</span>.log(...ary) <span class="hljs-comment">// 1 2 3</span></code></pre><ul><li>扩展运算符可以将两个数组分散合并成一个数组</li></ul><ul><li>将类数组或可遍历对象转换为真正的数组</li></ul><h3 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h3><p>将类数组或可遍历对象转换为真正的数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>length: <span class="hljs-number">3</span>&#125;<span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.from(arrayLike) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></code></pre><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><h3 id="实例方法：find（）"><a href="#实例方法：find（）" class="headerlink" title="实例方法：find（）"></a>实例方法：find（）</h3><p>用于找出第一个符合条件的数组成员，<strong>返回当前项</strong>，如果没有找到返回underfined</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [&#123;id: <span class="hljs-number">1</span>,name: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;， &#123;id: <span class="hljs-number">2</span>,name: <span class="hljs-string">&#x27;李四&#x27;</span>]<span class="hljs-keyword">let</span> target = ary.find(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item.id == <span class="hljs-number">2</span>)</code></pre><h3 id="实例方法：findIndex（）"><a href="#实例方法：findIndex（）" class="headerlink" title="实例方法：findIndex（）"></a>实例方法：findIndex（）</h3><p>用于找出第一个符合条件的数组成员的位置，<strong>返回索引值</strong>，如果没有就返回-1</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]<span class="hljs-keyword">let</span> index = ary.findIndex(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> value &gt; <span class="hljs-number">9</span>)<span class="hljs-built_in">console</span>.log(index) <span class="hljs-comment">// 2</span></code></pre><h3 id="实例方法：includes（）"><a href="#实例方法：includes（）" class="headerlink" title="实例方法：includes（）"></a>实例方法：includes（）</h3><p>表示某个数组是否包含给定的值，<strong>返回布尔值</strong>。</p><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>) <span class="hljs-comment">// false</span></code></pre><h2 id="String的扩展方法"><a href="#String的扩展方法" class="headerlink" title="String的扩展方法"></a>String的扩展方法</h2><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>ES6新增的创建字符串的方式，使用反引号定义。</p><p>例：let name = ‘zhangsan’;</p><p>特点：</p><ul><li>模板字符串中可以<strong>解析变量</strong>（加变量）用**${ }**包裹</li></ul><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;张三&#x27;</span><span class="hljs-keyword">let</span> sayHello = <span class="hljs-string">`hello, my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span> <span class="hljs-comment">// hello, my name is 张三</span></code></pre><ul><li>模板字符串可以<strong>换行</strong></li></ul><ul><li>在模板字符串中<strong>可以调用函数</strong>，得到函数的返回值。</li></ul><h3 id="实例方法：startWith-和-endsWith"><a href="#实例方法：startWith-和-endsWith" class="headerlink" title="实例方法：startWith() 和 endsWith()"></a>实例方法：startWith() 和 endsWith()</h3><p>startWith()：表示参数字符串是否在原字符串的头部，返回布尔值</p><p>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</p><p>例：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world&#x27;</span>str.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span>str.endWith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-comment">// true</span></code></pre><h3 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h3><p>repeat方法表示将原字符串重复n次，返回一个新字符串</p><pre><code class="hljs js"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;xxx&quot;</span><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;hellohello&quot;</span></code></pre><h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成Set数据结构。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()</code></pre><p>Set函数可以接受一个数值作为参数，用来初始化。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</code></pre><p>Set默认去重，size是它的长度</p><p>实例方法</p><p>add（value）：添加某个值，返回Set结构本身</p><p>delete（value）：删除某个值，返回一个布尔值，表示删除成功</p><p>has（value）：返回一个布尔值，表示该值是否为Set的成员</p><p>clear（）：清除所有成员，没有返回值</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>) <span class="hljs-comment">// 向set结构中添加值</span>s.delete(<span class="hljs-number">2</span>) <span class="hljs-comment">// 删除set结构中的2值</span>s.has(<span class="hljs-number">1</span>) <span class="hljs-comment">// 表示set结构中是否有1这个值 返回布尔值</span>s.clear() <span class="hljs-comment">// 清除set结构中的所有值</span></code></pre><p>遍历</p><p>Set结构的实例和数组一样，也拥有forEach方法，用于对每个成员某种操作，没有返回值。</p><p>s.forEach( value =&gt; console.log(value) )</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>置底</title>
    <link href="/2020/11/18/hello-world/"/>
    <url>/2020/11/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>笔记是早期在电脑用word文档写的，后来用插件把它转成md上传到博客。可能转换的时候有点小瑕疵然后我又没留意到去改（有序列表错误，无意义的换行），代码块也可能有拼写错误。如果发现了，可以告诉我叫我修改。</p><p>后期的一些技术总结，问题探讨都会用md并且很规范的去写（避免错误），可以放心。</p><p>另外放一下我的联系方式：</p><ul><li>微信: ccm873125046</li><li>QQ: 873125046</li><li>邮箱: <a href="mailto:&#56;&#55;&#x33;&#49;&#x32;&#x35;&#48;&#x34;&#x36;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;">&#56;&#55;&#x33;&#49;&#x32;&#x35;&#48;&#x34;&#x36;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;</a>(这个比较会去看)</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
