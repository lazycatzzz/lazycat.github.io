

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/favicon.jpg">
  <link rel="icon" type="image/png" href="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Chaomao Chen">
  <meta name="keywords" content="">
  <title>Node笔记 - 阿猫的学习日记</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"🐱","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chaom</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Node笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-16 21:30" pubdate>
        2020年12月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      71
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Node笔记</h1>
            
            <div class="markdown-body">
              <h1 id="Node是什么"><a href="#Node是什么" class="headerlink" title="Node是什么"></a>Node是什么</h1><p><strong>Node</strong>是一个基于ChromeV8引擎的JavaScript<strong>代码运行环境</strong>。</p>
<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript的代码运行环境。</p>
<p>Node（软件）能够运行JavaScript代码，Node就是JavaScript的代码运行环境。</p>
<h1 id="Node-js的组成"><a href="#Node-js的组成" class="headerlink" title="Node.js的组成"></a>Node.js的组成</h1><p>Node.js是由<strong>ECMAScript</strong>及<strong>Node环境</strong>提供的一些<strong>附加API</strong>组成的，包括文件、网络、路径等待一些强大的API。所有ECMAScript语法在Node环境中都可以使用。</p>
<p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/ced1f2319044b7cb3ea939a1a11013e7.png" srcset="/img/loading.gif"></p>
<h1 id="Node-js模块化开发"><a href="#Node-js模块化开发" class="headerlink" title="Node.js模块化开发"></a>Node.js模块化开发</h1><p>多个JavaScript调用有文件依赖和变量命名冲突问题。</p>
<p>一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。</p>
<h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>Node.js规定一个<strong>JavaScript文件</strong>就是一个模块，模块<strong>内部定义的变量和函数</strong>默认情况下在外部无法得到</p>
<p>模块内部可以使用<strong>exports对象进行成员导出</strong>，使用<strong>require方法</strong>导入其他模块。</p>
<p>导出exports：</p>
<p>exports.属性名 = 变量</p>
<p>例：const sayHi = name =&gt; `您好${name}`； exports.sayHi = sayHi;</p>
<p>导入：</p>
<p>let a = require(‘文件名’);</p>
<p><strong>另一种导出方式module.exports</strong></p>
<p><strong>exports</strong>是<strong>module.exports</strong>的别名<strong>（地址引用关系）</strong>，<strong>导出对象最终以module.exports<br>为准</strong></p>
<h2 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h2><p>当两者指向同一对象，两者无区别。当两者指向不同对象，导出以module.exports为准，exports导出无效。</p>
<p>Node.js全局对象global</p>
<p>在浏览器中全局对象是window，在Node中全局对象是global。</p>
<p>Node中全局对象下有以下方法，可以在任何地方使用，global可以省略。</p>
<p>console.log() 在控制台中输出</p>
<p>setTimeout() 设置超时定时器</p>
<p>clearTimeout() 清除超时定时器</p>
<p>setInterval() 设置间歇定时器</p>
<p>clearInterval() 清除间歇定时器</p>
<h2 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h2><p>含义：Node运行环境提供的API。因为这些API都是以模块化方式进行开发的，所以我们又称Node运行环境提供的API为系统模块</p>
<h3 id="fs文件操作"><a href="#fs文件操作" class="headerlink" title="fs文件操作"></a>fs文件操作</h3><p>f：file ，s：system，文件操作系统</p>
<p>引用：const fs = require(‘fs’)；</p>
<p>方法：</p>
<p><strong>读取文件内容</strong> fs.readFile(‘文件路径/文件名称’[，’文件编码’], callbcak);</p>
<p>文件读取是硬盘的操作，需要耗时，只有读取完毕触发回调函数才能引用读取结果。</p>
<pre><code class="hljs js"><span class="hljs-comment">// 读取上一级css目录下中的base.css</span>
fs.readFile(<span class="hljs-string">&#x27;..css/base.css&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, doc</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// 如果文件读取发生错误 参数err的值为错误对象 否则err的值为null</span>
    <span class="hljs-comment">// doc参数为文件内容</span>
    <span class="hljs-keyword">if</span> (err == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-comment">// 控制台中输出文件内容</span>
        <span class="hljs-built_in">console</span>.log(doc)
	&#125;
&#125;)</code></pre>

<p>错误优先的回调函数</p>
<p><strong>写入文件内容</strong> fs.writeFile(‘文件路径/文件名称’, ‘数据’, callback);</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> content = <span class="hljs-string">&#x27;&lt;h3&gt;正在使用fs.writeFile写入文件内容&lt;/h3&gt;&#x27;</span>
fs.writeFile(<span class="hljs-string">&#x27;../index.html&#x27;</span>, content, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;
	<span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) &#123;
		<span class="hljs-built_in">console</span>.log(err)
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;文件写入成功&#x27;</span>)
&#125;)</code></pre>

<h2 id="系统模块path-路径操作"><a href="#系统模块path-路径操作" class="headerlink" title="系统模块path 路径操作"></a>系统模块path 路径操作</h2><p>为什么要进行路径拼接</p>
<p>不同操作系统的路径分隔符不统一，windows上是\或/，Linux上是/</p>
<p>路径拼接语法 path.join(‘路径’，‘路径’，‘路径’，·····—) 下例</p>
<pre><code class="hljs js"><span class="hljs-comment">// 导入path模块</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)
<span class="hljs-comment">// 路径拼接</span>
<span class="hljs-keyword">let</span> finialPath = path.join(<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c.css&#x27;</span>)
<span class="hljs-comment">// 输出结果cat\a\b\c.css</span>
<span class="hljs-built_in">console</span>.log(finialPath)</code></pre>

<h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><ul>
<li><p>  大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录</p>
</li>
<li><p>  读取文件或者设置文件路径时都会选择绝对路径</p>
</li>
<li><p>  使用<strong>__dirname</strong>获取当前文件所在的绝对路径</p>
</li>
<li><p>  require比较特殊，它指向的就是文件所在的路径，所以可以用相对路径</p>
</li>
</ul>
<h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>就是别人写好的，具有特定功能的，可以直接使用的模块就是第三方模块，由于第三方模块通常都是多个文件组成并且被放置在一个文件夹中，所以又名包。</p>
<p>存在形式：1. 以js文件的形式存在，提供实现项目具体功能的API接口。</p>
<ol start="2">
<li>以命令行工具形式存在，辅助项目开发。</li>
</ol>
<h3 id="获取第三方模块"><a href="#获取第三方模块" class="headerlink" title="获取第三方模块"></a>获取第三方模块</h3><p>npmjs.com: 第三方模块的存储和分发仓库</p>
<p>npm(node package manager): node的第三方模块管理工具</p>
<p>下载：npm install 模块名称</p>
<p>卸载：npm uninstall package 模块名称</p>
<p>全局安装与本地安装</p>
<p>命令行工具：全局安装 加-g</p>
<p>库文件：本地安装</p>
<h3 id="第三方模块nodemon"><a href="#第三方模块nodemon" class="headerlink" title="第三方模块nodemon"></a>第三方模块nodemon</h3><p>在Node.js中，每次修改文件都要在命令行工具重新执行该文件，nodemon帮我们解决这个问题。</p>
<p>安装后要把node换成nodemon</p>
<p><strong>终止操作就按ctrl + c</strong></p>
<h3 id="第三方模块nrm"><a href="#第三方模块nrm" class="headerlink" title="第三方模块nrm"></a>第三方模块nrm</h3><p>nrm(npm registry manager): npm下载地址切换工具</p>
<p>npm默认的下载地址在国外，国内下载速度慢</p>
<p>使用npm install nrm -g 下载</p>
<p>nrm ls 查看可用下载地址列表</p>
<p>切换npm下载地址 nrm use</p>
<h1 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h1><p>第三方模块，基于node平台开发的前端构建工具</p>
<p>将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令，任务就能自动执行了，提高效率。</p>
<h2 id="Gulp能做什么"><a href="#Gulp能做什么" class="headerlink" title="Gulp能做什么"></a>Gulp能做什么</h2><ul>
<li><p>  项目上线，HTML、css、js文件压缩合并</p>
</li>
<li><p>  语法转换（es6、less、—）</p>
</li>
<li><p>  公共文件抽离</p>
</li>
<li><p>  修改文件浏览器自动刷新</p>
</li>
</ul>
<p>即：</p>
<ol>
<li><p> 把一个文件拷贝到另一个位置</p>
</li>
<li><p> 把多个js或css文件合并成一个文件，以减少网络请求数</p>
</li>
<li><p> 对js文件和css文件进行压缩合并 以减少网络流量</p>
</li>
<li><p> 把sess或less文件编译成css</p>
</li>
<li><p> 压缩图像文件，以减少网络流量</p>
</li>
<li><p> 创建一个可以实时刷新页面内容和本地服务器等等</p>
</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p> 安装：npm install gulp</p>
</li>
<li><p> 在项目根目录下建立gulpfile.js文件</p>
</li>
<li><p> 重构项目的文件夹结构src目录放置源代码文件dist目录放置构建后文件</p>
</li>
<li><p> 在gulpfile.js文件中编写任务</p>
</li>
<li><p> 在命令行工具中执行gulp任务</p>
</li>
</ol>
<h2 id="Gulp中提供的方法"><a href="#Gulp中提供的方法" class="headerlink" title="Gulp中提供的方法"></a>Gulp中提供的方法</h2><ul>
<li><p>  gulp.src()：获取任务要处理的文件</p>
</li>
<li><p>  gulp.dest()：输出文件</p>
</li>
<li><p>  gulp.task()：建立gulp任务</p>
</li>
<li><p>  gulp.watch()：监控文件的变化</p>
</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>)
<span class="hljs-comment">// 使用gulp.task()方法建立任务</span>
gulp.task(<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// 获取要处理的文件</span>
	gulp.src(<span class="hljs-string">&#x27;./src/css/base.css&#x27;</span>)
    <span class="hljs-comment">// 将处理后的文件输出到dist目录</span>
	.pipe(gulp.dest(<span class="hljs-string">&#x27;./dist/css&#x27;</span>))
&#125;)</code></pre>

<h2 id="Gulp插件"><a href="#Gulp插件" class="headerlink" title="Gulp插件"></a>Gulp插件</h2><ul>
<li><p>  gulp-htmlmin: html文件压缩</p>
</li>
<li><p>  gulp-csso：压缩css</p>
</li>
<li><p>  gulp-babel：JavaScript语法转化</p>
</li>
<li><p>  gulp-less：less语法转化</p>
</li>
<li><p>  gulp-uglify：压缩混淆JavaScript</p>
</li>
<li><p>  gulp-file-include：公共文件包含</p>
</li>
<li><p>  browsersync：浏览器实时同步</p>
</li>
</ul>
<h2 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h2><p>gulp.task(‘default’, gulp.series(任务名));</p>
<p>gulp.series：按照顺序执行 gulp.paralle：可以并行计算</p>
<p>现在gulp.task只接受两个参数</p>
<h2 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h2><h3 id="node-modules文件夹的问题"><a href="#node-modules文件夹的问题" class="headerlink" title="node_modules文件夹的问题"></a>node_modules文件夹的问题</h3><ul>
<li><p>  文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢</p>
</li>
<li><p>  复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错</p>
</li>
</ul>
<h3 id="package-json文件的作用"><a href="#package-json文件的作用" class="headerlink" title="package.json文件的作用"></a>package.json文件的作用</h3><p>项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。使用<strong>npm<br>init -y</strong>命令生成。</p>
<h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a><strong>项目依赖</strong></h3><ul>
<li><p>  在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖，例如，jQuery</p>
</li>
<li><p>使用npm<br>  install包名命令下载的文件会默认被添加到package.json文件的dependencies字段中</p>
</li>
</ul>
<h3 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h3><ul>
<li><p>  在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖，例如gulp</p>
</li>
<li><p>使用npm install 包名<br>  <strong>–save-dev</strong>命令将包添加到package.json文件的devDependencies字段中</p>
</li>
</ul>
<p><strong>–production 下载项目依赖内容</strong></p>
<p><strong>script作用：运用命令的别名，来简化一些操作。例如将一段命令语句声明一个别名，通过npm<br>run 别名 就可以执行这条别名里的命令</strong></p>
<h2 id="package-lock-json文件的作用"><a href="#package-lock-json文件的作用" class="headerlink" title="package-lock.json文件的作用"></a>package-lock.json文件的作用</h2><ul>
<li><p>  <strong>锁定包的版本</strong>，确保再次下载时不会因为包版本不同而产生问题</p>
</li>
<li><p>  <strong>加快下载速度</strong>，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工</p>
</li>
</ul>
<h1 id="Node-js中模块加载机制"><a href="#Node-js中模块加载机制" class="headerlink" title="Node.js中模块加载机制"></a>Node.js中模块加载机制</h1><p><strong>模块查找规则-当模块拥有路径但没有后缀时</strong></p>
<pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;/find.js&#x27;</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;/find&#x27;</span>)</code></pre>

<ol>
<li><p> require方法根据模块路径查找模块，如果是完整路径，直接引入模块。</p>
</li>
<li><p> 如果模块后缀省略，先找同名JS文件再找同名JS文件夹</p>
</li>
<li><p> 如果找到了同名文件夹，找文件夹中的index.js</p>
</li>
<li><p> 如果文件夹中没有index.js就会去当前文件夹中的package.js文件中查找main选项中的入口文件</p>
</li>
<li><p> 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</p>
</li>
</ol>
<p><strong>模块查找规则-当模块没有路径且没有后缀时</strong></p>
<ol>
<li><p> Node.js会假设它是系统模块</p>
</li>
<li><p> Node.js会去node_modules文件夹中</p>
</li>
<li><p> 首先看是否有该名字的JS文件</p>
</li>
<li><p> 再看是否有该名字的文件夹</p>
</li>
<li><p> 如果是文件夹看里面是否有index.js</p>
</li>
<li><p> 否则找不到报错</p>
</li>
</ol>
<h1 id="服务器端基础概念"><a href="#服务器端基础概念" class="headerlink" title="服务器端基础概念"></a>服务器端基础概念</h1><h2 id="网站的组成"><a href="#网站的组成" class="headerlink" title="网站的组成"></a>网站的组成</h2><p>网站应用程序主要分为两大部分：客户端和服务器端</p>
<p>客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。</p>
<h2 id="Node网站服务器"><a href="#Node网站服务器" class="headerlink" title="Node网站服务器"></a>Node网站服务器</h2><p>能够提供网站访问服务的机器就是网站服务器，他能够接受客户端的<strong>请求</strong>，能够对请求做出<strong>响应</strong>。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>互联网中设备的唯一标识</p>
<p>IP是Internet Protocol Address的简写，代表互联网协议地址</p>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时<strong>上网所使用的网址</strong>。</p>
<p>虽然在地址栏中输入的是网址，但是最终还是会将域名转换为ip才能访问到指定的网站服务器。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>统一资源定位符，又叫URL（Uniform Resource<br>Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。</p>
<h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>传输协议://服务器IP或域名:端口/资源所在位置标识</p>
<p>http：超文本传输协议，提供了一种发布和接受HTML页面的方法。</p>
<h2 id="开发过程中客户端和服务器端说明"><a href="#开发过程中客户端和服务器端说明" class="headerlink" title="开发过程中客户端和服务器端说明"></a>开发过程中客户端和服务器端说明</h2><p>在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑</p>
<p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/9667d2f0ef5d3194fd01c98ef7938fed.png" srcset="/img/loading.gif"></p>
<p><strong>创建Web服务器</strong></p>
<p><strong>创建web服务器</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 引用系统模块</span>
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)
<span class="hljs-comment">// 创建web服务器</span>
<span class="hljs-keyword">const</span> app = http.createServer()
<span class="hljs-comment">// 当客户端发送请求的时候</span>
app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
	<span class="hljs-comment">// 响应</span>
	res.end(<span class="hljs-string">&#x27;&lt;h1&gt;hi, user&lt;/h1&gt;&#x27;</span>)
&#125;)
<span class="hljs-comment">// 监听3000端口</span>
app.listen(<span class="hljs-number">3000</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;服务器已启动，监听3000端口，请访问localhost:3000&#x27;</span>)</code></pre>

<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP协议的概念"><a href="#HTTP协议的概念" class="headerlink" title="HTTP协议的概念"></a>HTTP协议的概念</h3><p><strong>超文本传输协议</strong>（hyperText Transfer<br>Protocol，缩写：<strong>HTTP</strong>）规定了如何从网站服务器传输超文本到本地服务器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。</p>
<p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/b61a0c8588d9a22a13a18ff5ab1da97e.png" srcset="/img/loading.gif"></p>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。</p>
<p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/5003849755bb396b5d1787fb60a7b41a.png" srcset="/img/loading.gif"></p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ol>
<li><p> 请求方式（Request Method）：GET 请求数据 POST 发送数据</p>
</li>
<li><p> 请求地址（Request URL）：</p>
</li>
</ol>
<pre><code class="hljs js">app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;
	req.headers <span class="hljs-comment">// 获取请求报文</span>
	req.url <span class="hljs-comment">// 获取请求地址</span>
	req.method <span class="hljs-comment">// 获取请求方法</span>
&#125;)</code></pre>

<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ol>
<li> HTTP状态码</li>
</ol>
<ul>
<li><p>  200 请求成功</p>
</li>
<li><p>  404 请求的资源没有被找到</p>
</li>
<li><p>  500 服务器端错误</p>
</li>
<li><p>  400 客户端请求有语法错误</p>
</li>
</ul>
<ol start="2">
<li>内容类型</li>
</ol>
<p>text/html 说明返回html文件</p>
<p>text/css 说明返回css文件</p>
<p>application/javascript 说明返回js文件</p>
<p>image/jpeg 说明返回图片文件</p>
<p>application/json 说明返回json文件</p>
<p><strong>res.writeHead</strong> 方法，书写响应头</p>
<h3 id="HTTP请求与响应处理"><a href="#HTTP请求与响应处理" class="headerlink" title="HTTP请求与响应处理"></a>HTTP请求与响应处理</h3><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p>
<p>有两种请求参数</p>
<h4 id="GET请求参数"><a href="#GET请求参数" class="headerlink" title="GET请求参数"></a>GET请求参数</h4><p>参数被放置在浏览器地址栏中，例如：<strong>http:// localhost:3000/index?name=zhangsan&amp;age=20</strong></p>
<p>?开始，&amp;连接多个</p>
<p>url.parse(urlStr, [parseQueryString], [slashesDenoteHost]);</p>
<p>urlStr url字符串</p>
<p>parseQueryString 为true时将使用查询模块分析查询字符串，默认为false</p>
<p>slashesDenoteHost 为true时返回对象类型结果</p>
<h4 id="POST请求参数"><a href="#POST请求参数" class="headerlink" title="POST请求参数"></a>POST请求参数</h4><p>参数被放置在请求体中进行传输</p>
<p>获取POST参数需要使用data事件和end事件</p>
<p>使用querystring系统模块将参数转换为对象格式</p>
<p>post参数是通过事件的方式接受的</p>
<p>data 当请求参数传递的时候出发data事件</p>
<p>end 当参数传递完成的时候出发end事件</p>
<pre><code class="hljs js"><span class="hljs-comment">// 导入系统模块querystring用于将http参数转换为对象形式</span>
<span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)
app.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;
	<span class="hljs-keyword">let</span> postData = <span class="hljs-string">&#x27;&#x27;</span>
	<span class="hljs-comment">// 监听参数传输事件</span>
	req.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> postData += chunk)
	<span class="hljs-comment">// 监听参数传输完毕事件</span>
	req.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;
		<span class="hljs-built_in">console</span>.log(querystring.parse(postData))
	&#125;)
&#125;)</code></pre>

<h2 id="输出带有object-null-prototype问题"><a href="#输出带有object-null-prototype问题" class="headerlink" title="输出带有object: null prototype问题"></a>输出带有object: null prototype问题</h2><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/8cb4d2f58bed5ad3000c19b3c242be7a.png" srcset="/img/loading.gif"></p>
<p>解决方法：将对象进行JSON字符串转化（JSON.stringify()）, 然后再转化成对象</p>
<p>（JSON.parse()）</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件。</p>
<p><strong>mime 模块 判断请求资源的类型</strong></p>
<p><strong>动态资源</strong></p>
<p>相同的请求地址不同的响应资源，这种资源就是动态资源。</p>
<h1 id="Node-js异步编程"><a href="#Node-js异步编程" class="headerlink" title="Node.js异步编程"></a>Node.js异步编程</h1><h2 id="同步API，异步API"><a href="#同步API，异步API" class="headerlink" title="同步API，异步API"></a>同步API，异步API</h2><p>同步API：只有当前API执行完成后，才能继续执行下一个API</p>
<p>异步API：当前API的执行不会阻塞后续代码的执行</p>
<h2 id="同步API，异步API的区别（获取返回值）"><a href="#同步API，异步API的区别（获取返回值）" class="headerlink" title="同步API，异步API的区别（获取返回值）"></a>同步API，异步API的区别（获取返回值）</h2><p>同步API可以从返回值中拿到API执行的结果，但是异步API不可以</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>自己定义函数让别人去调用。</p>
<h2 id="同步API，异步API的区别（代码执行顺序）"><a href="#同步API，异步API的区别（代码执行顺序）" class="headerlink" title="同步API，异步API的区别（代码执行顺序）"></a>同步API，异步API的区别（代码执行顺序）</h2><p>同步API从上到下依次执行，前面代码会阻塞后面代码的执行</p>
<p>异步API不会等待API执行完成后再向下执行代码</p>
<p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/ca95b39956909b22e1dc75005c8c0e6a.png" srcset="/img/loading.gif"></p>
<h2 id="Node-js的异步API"><a href="#Node-js的异步API" class="headerlink" title="Node.js的异步API"></a>Node.js的异步API</h2><p>例：</p>
<p>fs.readFile(‘./demo.txt’, (err, result) =&gt; {});</p>
<p>var server = http.createServer(); server.on(‘request’, (req, res) =&gt; {});</p>
<p>回调地狱：异步API多层嵌套，导致代码难以维护。 <strong>promise可以解决这个问题。</strong></p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise出现的目的是解决Node.js异步编程中回调地狱的问题。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
	<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
		<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;
			resolve(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span> &#125;)
		&#125;<span class="hljs-keyword">else</span> &#123;
			reject(<span class="hljs-string">&#x27;失败了&#x27;</span>)
		&#125;
	&#125;， <span class="hljs-number">2000</span>)
&#125;)
promise.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result) <span class="hljs-comment">// &#123; name: &#x27;张三&#x27; &#125;)</span>
		.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error) <span class="hljs-comment">// 失败了)</span></code></pre>

<h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">async</span> () =&gt; &#123;&#125;
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</code></pre>

<h4 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h4><ol>
<li><p> 普通函数定义前加async关键字 普通函数变成异步函数</p>
</li>
<li><p> 异步函数默认的<strong>返回值是promise对象</strong></p>
</li>
<li><p>在异步函数内部使用<strong>return关键字进行结果返回</strong> 结果会被包裹的promise对象中<br> return关键字代替了resolve方法</p>
</li>
<li><p> 在异步函数内部·使用<strong>throw关键字</strong>进行<strong>错误的抛出</strong></p>
</li>
<li><p> 调用异步函数再链式调用then方法获取异步函数执行结果</p>
</li>
<li><p> 调用异步函数再链式调用catch方法获取异步函数执行的错误信息</p>
</li>
</ol>
<h4 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h4><ol>
<li><p> <strong>await关键字只能出现在异步函数中</strong></p>
</li>
<li><p> await promise <strong>await后面只能写promise对象</strong> 写其他类型的API是不可以的</p>
</li>
<li><p> await关键字它可以暂停异步函数的执行，等待promise对象返回结果后再向下执行。</p>
</li>
</ol>
<p><strong>promisify util模块中的方法，用来改造现有异步函数api 让其返回promise对象<br>从而支持异步函数语法</strong></p>
<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><p>Express是一个基于<strong>Node平台</strong>的<strong>web应用开发框架</strong>，它提供了一系列的强大特性，帮助你<strong>创建各种Web应用</strong>。</p>
<p><strong>下载：</strong>npm install express</p>
<p><strong>框架特性：</strong></p>
<ul>
<li><p>  提供了方便<strong>简洁的路由定义</strong>方式</p>
</li>
<li><p>  对获取HTTP<strong>请求参数</strong>进行了<strong>简化处理</strong></p>
</li>
<li><p>  对<strong>模板引擎支持程度高</strong>，方便渲染动态HTML页面</p>
</li>
<li><p>  提供了<strong>中间件</strong>机制有效<strong>控制HTTP请求</strong></p>
</li>
<li><p>  拥有大量第三方中间件对功能进行扩展</p>
</li>
</ul>
<p>响应方法不再是end（）而是<strong>send（）</strong></p>
<ol>
<li><p> send方法内部会检测响应内容的类型</p>
</li>
<li><p> send方法会自动设置http状态码</p>
</li>
<li><p> send方法会帮我们自动设置响应的内容类型以及编码</p>
</li>
</ol>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>，中间件就是一堆方法，可以接收客户端发来的请求，可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。</p>
<p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/node/d2423f8ce4f619f6d55bf3e55d5c8069.png" srcset="/img/loading.gif"></p>
<p>中间件主要由两部分构成，<strong>中间件方法</strong>以及<strong>请求处理函数</strong></p>
<p>中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。例如路由方法。</p>
<pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;请求路径&#x27;</span>, <span class="hljs-string">&#x27;处理函数&#x27;</span>) <span class="hljs-comment">// 接收并处理get请求</span>
app.post(<span class="hljs-string">&#x27;请求路径&#x27;</span>, <span class="hljs-string">&#x27;处理函数&#x27;</span>) <span class="hljs-comment">// 接收并处理post请求</span></code></pre>

<p>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p>
<p>默认情况下，请求从上往下一次匹配中间件，一旦匹配成功，终止匹配。</p>
<p>可以调用<strong>next方法</strong>将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p>
<pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;
	req.name = <span class="hljs-string">&#x27;张三&#x27;</span>
&#125;)
app.get(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
	res.send(req.name)
&#125;)</code></pre>

<h3 id="app-use中间件用法"><a href="#app-use中间件用法" class="headerlink" title="app.use中间件用法"></a>app.use中间件用法</h3><p>app.use匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有请求</p>
<p>第一个参数也可以是传入请求地址，代表无论什么请求方式，只要是这个请求地址就接收这个请求。</p>
<pre><code class="hljs js">app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;
	<span class="hljs-built_in">console</span>.log(req.url)
	next()
&#125;)
app.use(<span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;
	<span class="hljs-built_in">console</span>.log(req.url)
	next()
&#125;)</code></pre>

<h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><ol>
<li><p> 路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p>
</li>
<li><p> 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</p>
</li>
<li><p> 自定义404页面</p>
</li>
</ol>
<h3 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h3><p>在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。</p>
<pre><code class="hljs js">app.use(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;
	res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">&#x27;服务器发生未知错误&#x27;</span>)
&#125;)</code></pre>

<p>同步函数抛出错误会被马上捕获到，但<strong>异步函数</strong>不行，所以要调用<strong>next（）方法</strong>，并且将错误信息通过参数的形式传递给next（）方法，即可触发错误处理中间件</p>
<pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;
 fs.readFile(<span class="hljs-string">&#x27;/file-does-not-exist&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;
 	<span class="hljs-keyword">if</span> (err) &#123;
 		next(err)
 	&#125;
 &#125;)
&#125;)</code></pre>



<h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p>在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。</p>
<p><strong>try catch</strong>可以<strong>捕获异步函数以及其他同步代码在执行过程中发生的错误</strong>，但是不能捕获其他类型的API发生的错误，例如promise，回调函数</p>
<pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">async</span> (req, res, next) =&gt; &#123;
	<span class="hljs-keyword">try</span> &#123;
		<span class="hljs-keyword">await</span> User.find(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;)
	&#125;<span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">ex</span>)</span> &#123;
		next(ex)
	&#125;
&#125;)</code></pre>

<h2 id="Express请求处理"><a href="#Express请求处理" class="headerlink" title="Express请求处理"></a>Express请求处理</h2><h3 id="构建模块化路由"><a href="#构建模块化路由" class="headerlink" title="构建模块化路由"></a>构建模块化路由</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)
<span class="hljs-comment">// 创建路由对象</span>
<span class="hljs-keyword">const</span> home = express.Router()
<span class="hljs-comment">// 将路由和请求路径进行匹配</span>
app.use(<span class="hljs-string">&#x27;/home&#x27;</span>, home)
<span class="hljs-comment">// 在home路由下继续创建路由</span>
home.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// /home/index</span>
	res.send(<span class="hljs-string">&#x27;欢迎来到博客展示页面&#x27;</span>)
&#125;)</code></pre>

<pre><code class="hljs js"><span class="hljs-comment">// home.js</span>
<span class="hljs-keyword">const</span> home = express.Router()
home.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;
	res.send(<span class="hljs-string">&#x27;欢迎来到博客展示页面&#x27;</span>)
&#125;)
<span class="hljs-built_in">module</span>.exports = home</code></pre>

<pre><code class="hljs js"><span class="hljs-comment">// admin.js</span>
<span class="hljs-keyword">const</span> admin = express.Router()
admin.get(<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;
	res.send(<span class="hljs-string">&#x27;欢迎来到博客管理页面&#x27;</span>)
&#125;)
<span class="hljs-built_in">module</span>.exports = admin</code></pre>

<pre><code class="hljs js"><span class="hljs-keyword">const</span> home = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./route/home.js&#x27;</span>)
<span class="hljs-keyword">const</span> admin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./route/admin.js&#x27;</span>)
app.use(<span class="hljs-string">&#x27;/home&#x27;</span>, home)
app.use(<span class="hljs-string">&#x27;/admin&#x27;</span>, admin)</code></pre>

<h3 id="GET参数的获取"><a href="#GET参数的获取" class="headerlink" title="GET参数的获取"></a>GET参数的获取</h3><p>Express框架中使用<strong>req.query</strong>即可获取GET参数，框架内部会将GET参数转换为对象并返回。</p>
<pre><code class="hljs js"><span class="hljs-comment">// 接收地址栏中问号后面的参数</span>
<span class="hljs-comment">// 例如：http://localhost:3000/?name=zhangsan&amp;age=30</span>
app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
	<span class="hljs-built_in">console</span>.log(req.query) <span class="hljs-comment">// &#123; &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot; &#125;</span>
&#125;)</code></pre>

<h3 id="POST参数的获取"><a href="#POST参数的获取" class="headerlink" title="POST参数的获取"></a>POST参数的获取</h3><p>Express中接收post请求参数需要借助第三方包<strong>body-parser</strong>。</p>
<pre><code class="hljs js"><span class="hljs-comment">// 引入body-parser模块</span>
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)
<span class="hljs-comment">// 配置body-parser模块</span>
app.use(bodyParser.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))
<span class="hljs-comment">// 接收请求</span>
app.post(<span class="hljs-string">&#x27;/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
	<span class="hljs-comment">// 接收请求参数</span>
	<span class="hljs-built_in">console</span>.log(req.body)
&#125;)</code></pre>

<p>extended拓展，默认值为false，即使用系统模块querystring处理请求参数的格式，当为true时，运用第三方模块qs来对请求参数进行处理，虽然qs的功能比querystring强大，但目前用querystring就足够了。</p>
<h3 id="Express路由参数"><a href="#Express路由参数" class="headerlink" title="Express路由参数"></a>Express路由参数</h3><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/find/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
	<span class="hljs-built_in">console</span>.log(req.params) <span class="hljs-comment">// &#123; id: 123 &#125;</span>
&#125;)
<span class="hljs-comment">// localhost:3000/find/123</span></code></pre>

<p>不传递参数将无法访问页面</p>
<h3 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h3><p>通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript文件等。</p>
<pre><code class="hljs js">app.use(express.static(<span class="hljs-string">&#x27;pubilc&#x27;</span>))</code></pre>

<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方原art-template模板引擎的基础上封装了express-art-template。</p>
<p>下载：</p>
<p>npm install –save art-template</p>
<p>npm install –save express-art-template</p>
<pre><code class="hljs js"><span class="hljs-comment">// 当渲染后缀为art的模板时 使用express-art-template</span>
app.engine(<span class="hljs-string">&#x27;art&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))
<span class="hljs-comment">// 设置模板存放目录</span>
app.set(<span class="hljs-string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>))
<span class="hljs-comment">// 渲染模板时不写后缀 默认拼接art后缀</span>
app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;art&#x27;</span>)
app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// 渲染模板</span>
	res.render(<span class="hljs-string">&#x27;index&#x27;</span>)
&#125;)</code></pre>

<p>views是固定的，要在文件夹中生成views文件夹</p>
<h3 id="app-locals对象"><a href="#app-locals对象" class="headerlink" title="app.locals对象"></a>app.locals对象</h3><p>将变量设置到app.locals对象z下面，这个数据在所有的模板中都可以获取到。</p>
<pre><code class="hljs js">app.locals.users = [&#123;
	name: <span class="hljs-string">&#x27;张三&#x27;</span>,
	age: <span class="hljs-number">20</span>
&#125;, &#123;
	name: <span class="hljs-string">&#x27;李四&#x27;</span>,
	age: <span class="hljs-number">20</span>
&#125;]</code></pre>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Note/">Note</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Node/">Node</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/18/MongoDB%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MongoDB笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/15/HTML5%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">HTML5笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
