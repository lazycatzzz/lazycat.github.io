<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Javascript笔记</title>
    <link href="/2020/12/05/JS%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/05/JS%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><p>arguments对象中存储了传递到函数里的所有实参。</p><p>prompt</p><p>prompt() 方法用于显示可提示用户进行输入的对话框</p><p>语法：prompt(text,defaultText)</p><p>text：可选。要在对话框中显示的纯文本</p><p>defaultText：可选。默认的输入文本。</p><p>如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段<strong>当前显示的文本</strong>。</p><h1 id="函数声明方式"><a href="#函数声明方式" class="headerlink" title="函数声明方式"></a>函数声明方式</h1><h2 id="1-利用函数关键字自定义函数（命名函数）"><a href="#1-利用函数关键字自定义函数（命名函数）" class="headerlink" title="1.利用函数关键字自定义函数（命名函数）"></a>1.利用函数关键字自定义函数（命名函数）</h2><p>function fn() {}</p><p>fn（）；</p><h2 id="2-函数表达式（匿名函数）"><a href="#2-函数表达式（匿名函数）" class="headerlink" title="2.函数表达式（匿名函数）"></a>2.函数表达式（匿名函数）</h2><p>var fun(变量名) = function() {}</p><p>fun（）；</p><p>注意：1.变量名不是函数名</p><p>2.函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存函数</p><p>3.函数表达式也可以进行传递参数</p><p>4.<strong>函数表达式调用必须写在函数声明下面</strong></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>Javascript作用域：就是代码名字（变量）在某个范围内起作用和效果 目的是为了提高程序的可靠性更重要的是减少命名冲突。</p><p>js的作用域（es6）之前：全局作用域 局部作用域</p><p><strong>全局作用域</strong>：整个script标签 或者是一个单独的js文件</p><p><strong>局部作用域</strong>：在函数内部就是局部作用域</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>根据作用域的不同我们变量分为全局变量和局部变量</p><ol><li><p><strong>全局变量</strong>：在全局作用域下的变量 在全局下都可以使用</p></li><li><p><strong>局部变量</strong> 在局部作用域下的变量 后者在函数内部的变量就是局部变量。只能在函数内部使用。</p></li><li><p><strong>从指向效率来看全局变量和局部变量</strong></p></li></ol><p>（1）  全局变量只有浏览器关闭的时候才会销毁，比较占内存资源</p><p>（2）  局部变量 当我们程序执行完毕就会销毁，比较节约内存资源</p><p><strong>注意</strong>：如果在函数内部 <strong>没有声明直接赋值的变量也属于全局变量</strong></p><p>函数的形参也可以看做是局部变量</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值 这种结构称作作用域链 就近原则。</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步：<strong>预解析和代码执行</strong></p><ol><li><p>预解析：js引擎会把js里面所有的var还有function提升到当前作用域的最前面</p></li><li><p>代码执行：按照代码书写顺序从上往下执行</p></li></ol><p>预解析分为 变量预解析（变量提升）和函数预解析（函数提升）</p><ol><li><p>变量提升：就是把所有的变量声明提升到当前的作用域最前面 <strong>不提升赋值操作</strong>。</p></li><li><p>函数提升：就是把所有的函数声明提升到当前作用域的最前面 <strong>不调用函数</strong></p></li></ol><p>例：    </p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;fun();                 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;         <span class="hljs-built_in">console</span>.log(num);          <span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span>;          &#125;</code></pre><p>相当于</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num;<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> num;<span class="hljs-built_in">console</span>.log(num);num = <span class="hljs-number">20</span>;&#125;num = <span class="hljs-number">10</span>fun();</code></pre><p>最后结果是undefined（就近原则）</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>JavaScript中，对象是一组无序的相关属性和方法的集合，例如字符串、数值、数组、函数等。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h3><p><strong>对象字面量</strong>：就是花括号**{}**里面包含了表达这个具体事物（对象）的属性和方法。</p><p><strong>使用对象</strong>：</p><p>（1）  调用对象的属性 用  对象名 <strong>.</strong> 属性名</p><p>（2）  调用属性还有一种方法 对象吗[‘属性名’] 方括号内一定要有引号</p><p>（3）  调用方法  对象名 <strong>.</strong> 方法()</p><h3 id="new-Object创建对象"><a href="#new-Object创建对象" class="headerlink" title="new Object创建对象"></a>new Object创建对象</h3><p>var 对象名 = new Object();</p><p>对象名.属性名 = 属性值  //创建新的属性</p><p>对象名.方法名 = function（）{} //创建新的方法</p><h3 id="利用构造函数创建对象"><a href="#利用构造函数创建对象" class="headerlink" title="利用构造函数创建对象"></a>利用构造函数创建对象</h3><p>构造函数 就是把对象里面一些相同的属性和方法抽象出来封装到函数里面</p><p>function 构造函数名（）{</p><p>  this.属性 = 值；</p><p>  this.方法 = function () {}</p><p>}</p><p>new 构造函数名（）；</p><p>注意: 1.构造函数名字首字母要大写</p><p>2.构造函数不需要return 就可以返回结果</p><p>3.调用构造函数必须使用new</p><p>4.属性和方法前面必须要添加this</p><h2 id="构造函数和对象的关系"><a href="#构造函数和对象的关系" class="headerlink" title="构造函数和对象的关系"></a>构造函数和对象的关系</h2><ol><li><p> 构造函数泛指某一大类，它类似java中的类（class）</p></li><li><p> 对象特指是一个具体的事物 </p></li><li><p> 我们利用构造函数创建对象的过程我们称之为<strong>对象的实例化</strong></p></li></ol><h2 id="new执行步骤"><a href="#new执行步骤" class="headerlink" title="new执行步骤"></a>new执行步骤</h2><ol><li><p> 在内存中创建一个新的空对象</p></li><li><p> 让this指向这个新的对象</p></li><li><p> 执行构造函数里面的代码，给这个新对象添加属性和方法</p></li><li><p> 返回这个新对象（所以构造函数里面不需要return）</p></li></ol><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><p>for in 遍历对象</p><p>例：</p><p>for (var k in obj){</p><p> console.log(k); //k 变量 输出得到的是<strong>属性名</strong></p><p>console.log(obj[k]); //obj[k] 得到的是<strong>属性值</strong></p><p>}</p><p>使用for in 里面的变量，我们喜欢用k 或者 key （习惯，就像i ,j）</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>JavaScript中的对象分为3种：自定义对象、内置对象、浏览器对象</p><p>前两种对象是js基础内容，属于ECMAScript；第三个浏览器对象属于JS独有的。</p><p>内置对象就是指js语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基础而必要的功能（属性和方法）</p><p>查文档：MDN</p><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p>Math对象不是构造函数，它具有数学常数和函数的属性和方法，跟数学相关的运算。</p><p>Math.max() 最大值</p><p>Math.min() 最小值</p><p>Math.PI 圆周率</p><p>Math.abs() 绝对值 (隐式转换 会把字符串中的 -1 转换为数字型</p><p>Math.floor() 向下取整(取最小的整数)</p><p>Math.ceil() 向上取整（取最大的整数）</p><p>Math.round() 四舍五入 其他数字都是四舍五入</p><p>Math.random() 不跟参数，返回随机小数 0&lt;= x &lt;1</p><h1 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h1><h2 id="JS的组成"><a href="#JS的组成" class="headerlink" title="JS的组成"></a>JS的组成</h2><p>WebAPIs是JS所独立的部分，主要实现交互功能。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/123.png"></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>API（应用程序编程接口）</strong>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p><p>简单理解：<strong>API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。</strong></p><p><strong>Web API是浏览器</strong>提供的一套操作<strong>浏览器功能</strong>和<strong>页面元素</strong>的API（BOM和DOM）。主要针对于浏览器做交互效果。</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h2><p>文档对象模型（Document Object Model，简称<strong>DOM</strong>），是W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准<strong>编程接口</strong>。</p><p>W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/dom.png"></p><p>文档：一个页面就是一个文档，DOM中使用document表示</p><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p><p>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示</p><p><strong>DOM把以上内容都看做是对象</strong></p><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>(因为我们文档页面是从上往下加载，所以先得有标签 所以我们script写到标签的下面)</p><h3 id="1-根据ID获取"><a href="#1-根据ID获取" class="headerlink" title="1.根据ID获取"></a>1.根据ID获取</h3><p><strong>getElementById(id) //参数id是大小写敏感的字符串，所以要‘ ’ 返回的是Element对象</strong></p><p><strong>console.dir</strong> <strong>打印我们返回的元素对象 更好的查看里面的属性和方法</strong></p><h3 id="2-根据标签名获取"><a href="#2-根据标签名获取" class="headerlink" title="2.根据标签名获取"></a>2.根据标签名获取</h3><p><strong>getElementsByTagName(TagName) //返回的是 获取的元素对象的集合 以伪数组的形式存储的（没有数组方法）</strong></p><p><strong>得到的对象是动态的</strong></p><p><strong>element.getElementsByTagName()</strong> <strong>可以获取这个元素中的某些标签</strong></p><p><strong>例：var nav = document.getElementById(id)</strong></p><p><strong>nav. getElementsByTagName(Tagname)</strong></p><h3 id="3-通过HTML5新增方法获取"><a href="#3-通过HTML5新增方法获取" class="headerlink" title="3.通过HTML5新增方法获取"></a>3.通过HTML5新增方法获取</h3><p><strong>document.getElementsByClassName(‘类名’); // 根据类名返回元素对象集合</strong></p><p><strong>document.querySelector(‘选择器‘); // 根据指定选择器返回</strong>第一个<strong>元素对象</strong></p><p><strong>里面的选择器要加符号 id：#、 class：.</strong></p><p><strong>document.querySelectorAll(); // 返回指定选择器的所有元素对象集合</strong></p><h3 id="4-获取特殊元素"><a href="#4-获取特殊元素" class="headerlink" title="4.获取特殊元素"></a>4.获取特殊元素</h3><p><strong>document.body // 获取body标签，返回body对象</strong></p><p><strong>document.documentElement // 返回html对象</strong></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是由三部分组成 事件源 事件类型 事件处理程序</p><ol><li><p> 事件源：事件被触发的对象</p></li><li><p> 事件类型：如何触发 什么事件 </p></li><li><p> 事件处理程序：通过一个函数赋值的方式 完成</p></li></ol><p>例：var btn = document.getElementById(‘btn’)</p><p>btn.onclick = function() { }</p><p><strong>步骤</strong>：获取事件源——注册事件——添加事件处理程序（采用函数赋值形式）</p><h3 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h3><p><strong>onClick</strong>：鼠标点击事件，多用在某个对象控制的范围内的鼠标点击</p><p>onDblClick：鼠标双击事件</p><p><strong>onfocus</strong>：获得鼠标焦点触发</p><p><strong>onblur</strong>：失去鼠标焦点触发</p><p><strong>onMouseDown</strong>：鼠标上的按钮被按下了</p><p><strong>onMouseUp</strong>：鼠标按下后，松开时激发的事件</p><p><strong>onMouseOver</strong>：当鼠标移动到某对象范围的上方时触发的事件</p><p><strong>onMouseMove</strong>：鼠标移动时触发的事件</p><p><strong>onMouseOut</strong>：当鼠标离开某对象范围时触发的事件</p><p>onKeyPress：当键盘上的某个键被按下并且释放时触发的事件</p><p><strong>onKeyDown</strong>：当键盘上某个按键被按下时触发的事件</p><p><strong>onKeyUp</strong>：当键盘上某个按键被按放开时触发的事件</p><h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><p><strong>element.innerText</strong>：从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉</p><p><strong>element.innerHTML</strong>：起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行</p><p>区别：</p><p>1.innerText不识别html标签，innerHTML识别</p><p>2.innerText是非标准 innerHTML是W3C标准</p><h2 id="表单属性操作"><a href="#表单属性操作" class="headerlink" title="表单属性操作"></a>表单属性操作</h2><p>type、value、checked、selected、disabled</p><p>表单里面的值 文字内容是通过value来修改</p><p>表单禁用，disabled=true</p><h2 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h2><p><strong>element.style</strong> <strong>行内样式操作即修改具体样式</strong></p><p><strong>element.className</strong> <strong>类名样式操作即修改类名</strong></p><p>注意：</p><p><strong>1.JS里面的样式采取驼峰命名法 比如 fontSize、backgroundColor</strong></p><p><strong>2.JS修改style样式操作，产生的是行内样式，css权重比较高</strong></p><h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>去除其他元素独特的样式，给自己添加的独特样式</p><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p>即我们可以自定义元素的属性 应用：tab页</p><p><strong>获取</strong>属性方法：</p><p>1.获取元素的属性值——<strong>element.属性</strong> 先get元素，再得属性值</p><p>2.<strong>element.getAttribute(‘属性’)</strong> </p><p><strong>设置</strong>元素属性值1. <strong>element.属性 = ‘值’</strong> 设置内置的属性值</p><p><strong>2. element.setAttribute(‘属性’，值)</strong> 主要针对<strong>自定义属性</strong>，也可以改内置属性</p><p>注意：class比较特殊，里面是class，不是className</p><p><strong>移除</strong>属性方法：<strong>element.removeAttribute(‘属性’)</strong></p><h2 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h2><p><strong>自定义属性目的：是为了保存并使用数据。有些数据可以保持到页面中而不用保存到数据库中。</strong></p><p>H5规定自定义属性**data-**开头做为属性名并且赋值。</p><p>比如：&lt;div data-index=””&gt;&lt;/div&gt;</p><p>H5新增的获取自定义属性方法：<strong>element.dataset.index (就不用再加data-)</strong></p><p>注意：只能获取data-的自定义属性，兼容ie11以上版本</p><p><strong>dataset是一个集合里面存放了所有以data-开头的自定义属性</strong></p><p>注意：如果自定义属性里面有多个-链接的单词，我们获取的时候采取驼峰命名法。（例：data-list-name —— element.dataset.listName）</p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><ol><li>利用DOM提供的方法获取元素</li></ol><p>缺点：逻辑性不强、繁琐</p><ol start="2"><li>利用节点层级关系获取元素</li></ol><p>利用父子兄节点关系获取元素</p><p>特点：逻辑性强，但是兼容性稍差</p><p><strong>节点描述</strong>：一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><p>元素节点 nodeType 为 1</p><p>属性节点 nodeType 为 2</p><p>文本节点 nodeType 为 3</p><p><strong>节点层级</strong>：利用DOM树可以把节点划为不同的层级关系，最常见的是父子兄级关系</p><h3 id="父节点parentNode"><a href="#父节点parentNode" class="headerlink" title="父节点parentNode"></a>父节点parentNode</h3><p><strong>element.parentNode</strong>得到离元素最近的父级节点，如果找不到，返回为null</p><h3 id="子节点childNodes"><a href="#子节点childNodes" class="headerlink" title="子节点childNodes"></a>子节点childNodes</h3><p>parentNode.childNodes（标准） 返回包含指定节点的子节点的集合</p><p><strong>注意：返回值里面包含了所有的子节点，包括元素节点、文本节点等</strong></p><p><strong>如果只想获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes</strong></p><p><strong>子节点children</strong></p><p>parentNode.children（非标准）<strong>获取所有的子元素节点，虽然是非标准，但是得到了各个浏览器的支持。（常用）</strong></p><p><strong>子节点 firstChild</strong> 获得第一个子节点（不管是文本还是元素）</p><p><strong>子节点 lastChild</strong> 获得最后一个子节点（不管是文本还是元素）</p><p><strong>子节点 firstElementChild</strong> 返回第一个子元素节点</p><p><strong>子节点 lastElementChild</strong> 返回最后一个子元素节点</p><p>上两种方法兼容IE9以上版本</p><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><p><strong>node.nextSibling</strong> 返回当前元素的下一个兄弟节点（包括文本，元素），找不到返回null</p><p><strong>node.previousSibling</strong> 返回当前元素上一个兄弟节点</p><p><strong>node.nextElementSibling</strong> 返回当前节点的下一个兄弟元素节点</p><p><strong>node.previousElementSibling</strong> 返回当前节点的上一个兄弟元素节点</p><p>上两种方法兼容IE9以上版本</p><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p><strong>document.createElement(‘tagName’)</strong> 创建由tagName指定的HTML元素。因为这些元素原先不存在，是动态生成的。</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p><strong>1.node.appendChild(child)</strong> 将一个节点添加到指定父节点的子节点列表末尾。后面追加元素，类似于伪元素after</p><p>node（父级）child（子级）</p><p><strong>2.node.insertBefore(child,</strong> <strong>指定元素)</strong> 将添加父元素的指定子元素的前面添加。</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>node.removeChild(child) 方法从DOM中删除一个子节点，返回删除的节点</p><p>阻止链接跳转需要添加<strong>javascript:void(0);</strong> 或者 **javascript:; **在 a href=” ”中</p><h3 id="复制节点（克隆节点）"><a href="#复制节点（克隆节点）" class="headerlink" title="复制节点（克隆节点）"></a>复制节点（克隆节点）</h3><p>node.cloneNode() 返回调用该方法的节点的一个副本。</p><p>例：ul.children[0].cloneNode()</p><p>注意：括号为空或者里面是false 进行的是浅拷贝，只复制标签不复制里面的内容，改为true就是深拷贝，复制里面的所有内容。</p><h3 id="三种动态创建元素区别"><a href="#三种动态创建元素区别" class="headerlink" title="三种动态创建元素区别"></a>三种动态创建元素区别</h3><p><strong>document.write()</strong> </p><p><strong>element.innerHTML</strong></p><p><strong>document.createElement()</strong></p><p><strong>区别</strong></p><ol><li>document.write()是直接将内容写入页面的内容流，但是当页面文档流加载完毕，则它会导致页面全部重绘。</li></ol><p>2.innerHTML是将内容写入某个DOM节点，不会导致页面全部重绘</p><p>3.innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</p><p>4.createElement() 创建多个元素效率稍低一点点，但是结构更清晰</p><h2 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h2><h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p><strong>1.传统注册方式</strong></p><p>利用on开头的事件onclick </p><p>特点：注册事件的唯一性 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数。</p><p><strong>2.方法监听注册方式</strong></p><p>w3c标准 推荐方式</p><p><strong>addEventListener()</strong> 它是一个方法</p><p>IE9之前的IE不支持此方法，可使用attachEvent()代替</p><p>特点：同一个元素同一个事件可以注册多个监听器  按照注册顺序依次执行</p><p><strong>addEventListener事件监听方式</strong></p><p><strong>eventTarget.addEventListener(type, listener[, useCapture])</strong></p><p>eventTarget.addEventListener()方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，就会执行事件处理函数。</p><p>该方法接收三个参数：</p><p>type:事件类型字符串，比如click、mouseover，注意这里不要带on</p><p>listener：事件处理函数，事件发生时，会调用该监听函数</p><p>useCapture：可选参数，是一个布尔值，默认时false。</p><p><strong>attachEvent</strong> <strong>事件监听方式（非标准，了解一下）</strong></p><p>eventTarget.attachEvent()方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p><p>该方法接收两个参数：</p><p>eventNameWithOn：事件类型字符串，比如onclick、onmouseover，这里要带on</p><p>callback：事件处理函数，当目标触发事件时会回调函数被调用</p><h3 id="删除事件（解绑事件）"><a href="#删除事件（解绑事件）" class="headerlink" title="删除事件（解绑事件）"></a>删除事件（解绑事件）</h3><p><strong>1.传统注册方式</strong></p><p><strong>eventTarget.onclick = null</strong></p><p><strong>2.方法监听注册方式</strong></p><p><strong>eventTarget.removeEventListener(type, listener[,useCapture]);</strong></p><p>注意函数不能是匿名函数，兼容性问题（跟add一样）</p><p><strong>eventTarget.detachEvent(eventNameWithOn, callback);</strong></p><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件流描述的是从页面中接收事件的顺序</p><p>事件发生时会在元素节点之间按照特定的传播，这个传播过程即DOM事件流</p><p>DOM事件流分三个阶段：捕获阶段 当前目标阶段 冒泡阶段</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/684645.png"></p><p>事件冒泡：IE最早提出，事件开始时有最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程。</p><p>事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到具体的元素接收的过程。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/861.png"></p><p><strong>注意</strong></p><ol><li><p>JS代码中只能执行捕获或者冒泡其中的一个阶段</p></li><li><p>onclick和attachEvent只能得到冒泡阶段</p></li><li><p>addEventListener（type，listener[,useCapture]）第三个参数如果为true，表示事件捕获阶段调用事件处理程序；如果为false（默认为false），则在事件冒泡阶段调用事件处理程序。</p></li><li><p>实际开发很少使用事件捕获</p></li><li><p>有些事件没有冒泡，比如onblur、onfocus、onmouseover、onmouseleave</p></li></ol><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ol><li><p>event就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看</p></li><li><p>事件对象只有有了对象才会存在，它是系统给我们自动创建的，不需要我们传递参数</p></li><li><p>事件对象是我们事件的<strong>一系列相关数据的集合</strong> 跟事件相关的 <strong>有很多属性和方法</strong> 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标，如果是键盘事件就包含了键盘事件的信息</p></li><li><p><strong>这个事件对象我们可以自己命名 比如event、evt、e</strong></p></li><li><p>事件对象也有兼容性问题 ie678通过window.event </p></li></ol><p><strong>兼容性写法e = e | | window.event</strong></p><ol start="6"><li>event是个形参，不需要传递实参过去</li></ol><h4 id="事件对象常见的属性和方法"><a href="#事件对象常见的属性和方法" class="headerlink" title="事件对象常见的属性和方法"></a>事件对象常见的属性和方法</h4><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E4%BA%8B%E4%BB%B6.png"></p><p>1.<strong>e.target</strong>返回的是<strong>触发事件的对象</strong>（元素） <strong>this</strong>返回的是<strong>绑定事件的对象</strong>（元素）</p><p>2.了解一下 跟this有个相似的属性 currentTarget ie678不兼容</p><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><p><strong>标准写法：利用事件对象里面的stopPropagation（）方法</strong></p><p>兼容性：再添加判断条件 使用e.cancelBubble = true</p><h4 id="事件委托（代理、委派）"><a href="#事件委托（代理、委派）" class="headerlink" title="事件委托（代理、委派）"></a>事件委托（代理、委派）</h4><p><strong>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</strong></p><p>作用：操作一次DOM，提高了程序性能</p><p>关键：就是把事件绑定在父节点上</p><h3 id="常见鼠标事件"><a href="#常见鼠标事件" class="headerlink" title="常见鼠标事件"></a>常见鼠标事件</h3><ol><li>禁止鼠标右键菜单</li></ol><p><strong>contextmenu</strong>主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p><ol start="2"><li>禁止鼠标选中</li></ol><p><strong>selectstart（开始选中）</strong></p><p><strong>鼠标事件对象（MouseEvent）</strong></p><p> 1.鼠标在可视区的 X 和 Y 坐标</p><ul><li><p>e.clientX  返回鼠标相对于浏览器窗口可视区的坐标X</p></li><li><p>e.clientY  返回鼠标相对于浏览器窗口可视区的坐标Y</p></li></ul><p>2.鼠标在页面文档的 X 和 Y 坐标</p><ul><li><p>e.pageX  返回鼠标相对于页面文档的坐标X  IE9+ 支持</p></li><li><p>e.pageY  返回鼠标相对于页面文档的坐标Y  IE9+ 支持</p></li></ul><p>3.鼠标在电脑屏幕的 X 和 Y 坐标</p><ul><li><p>e.screenX  返回鼠标相对于电脑屏幕的 X 坐标</p></li><li><p>e.screenY  返回鼠标相对于电脑屏幕的 Y 坐标</p></li></ul><p>开发中pageXY比较常用</p><h3 id="常见的键盘事件"><a href="#常见的键盘事件" class="headerlink" title="常见的键盘事件"></a>常见的键盘事件</h3><p><strong>onkeyup</strong>：按键弹起时触发</p><p><strong>onkeydown</strong>：键盘按下时触发</p><p><strong>onkeypress</strong>：键盘按下触发 但是识别不了功能键</p><p>三个事件的执行顺序：keydown -&gt; keypress-&gt; keyup</p><h4 id="键盘事件对象-KeyboardEvent"><a href="#键盘事件对象-KeyboardEvent" class="headerlink" title="键盘事件对象 KeyboardEvent"></a>键盘事件对象 KeyboardEvent</h4><p> <strong>keyCode</strong>：返回该键的ASCII值</p><p>注意：</p><p>1.keyup和keydown事件不区分字母大小写 a和A得到都是65</p><p>2.keypress事件区分字母大小写 a 97 A 65</p><p>注意：keydown和keypress在文本框里面得特点：他们两个事件触发的时候，文字还没有落入文本框中。</p><p>keyup事件触发的时候，文字已经落入文本框里面了</p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM即<strong>浏览器对象模型</strong>，它提供了独立于内容而与<strong>浏览器窗口进行交互的对象</strong>，其核心对象是window</p><p>BOM由一系列相关的对象构成，并且每个对象都提供了很多方法和属性。</p><p>BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分。</p><h2 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h2><p><strong>window对象是浏览器的顶级对象</strong>，它具有双重角色</p><ol><li><p>它是JS访问浏览器窗口的一个接口</p></li><li><p>它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window。对话框都属于window对象方法（alert、prompt等）</p></li></ol><p><strong>注意：window下的一个特殊属性window.name，声明变量尽量不用name</strong></p><h2 id="window对象的常见事件"><a href="#window对象的常见事件" class="headerlink" title="window对象的常见事件"></a>window对象的常见事件</h2><h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><p><strong>window.onload= function(){ }</strong></p><ol><li><p>窗口加载事件，当文档内容（包括图像、脚本文件、CSS文件等）完全加载完成会触发事件，就调用函数。</p></li><li><p>传统的方式注册事件只能写一次，声明多个以最后一个为准。</p></li><li><p>如果用addEventListener则没有限制，没有on</p></li></ol><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><p><strong>document.addEventListener(‘DOMContentLoaded’, function(){ })</strong></p><p>DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片、flash等等</p><p>ie9以上支持</p><p>如果页面图片较多，加载时间长，用DOMContentLoaded事件比较合适</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p><strong>window.onresize = function(){}</strong></p><p><strong>window.addEventLIstener(‘resize’, function(){ })</strong></p><p>window.onresize 是调整窗口大小加载的事件，当触发时就调用的处理函数。</p><p>应用：响应式布局，<strong>window.innerWIdth当前屏幕的宽度</strong></p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p>window.setTimeout(调用函数，[延迟的毫秒数]);</p><p>setTimeout()方法用于设置定时器，该定时器在定时器到期后执行调用函数。</p><ol><li><p> window在调用时可以省略</p></li><li><p> 这个调用函数可以直接写函数，还可以写函数名 还有一个写法‘函数名（）’第三种不推荐（麻烦）</p></li><li><p> 页面中可能有多个定时器，要给定时器加标识符（名字）</p></li></ol><h3 id="停止setTImeout（）定时器"><a href="#停止setTImeout（）定时器" class="headerlink" title="停止setTImeout（）定时器"></a>停止setTImeout（）定时器</h3><p><strong>window.clearTimeout(timeout ID)</strong></p><p>window可以省略</p><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p>window.setInterval(回调函数，[间隔毫秒数]);</p><p>setInterval()方法用于设置定时器，该定时器每隔指定毫秒就执行调用一次函数，不断重复调用。</p><ol><li><p> window在调用时可以省略</p></li><li><p> 这个调用函数可以直接写函数，还可以写函数名 还有一个写法‘函数名（）’第三种不推荐（麻烦）</p></li><li><p> 页面中可能有多个定时器，要给定时器加标识符（名字）</p></li></ol><h3 id="停止setInterval-定时器"><a href="#停止setInterval-定时器" class="headerlink" title="停止setInterval()定时器"></a>停止setInterval()定时器</h3><p>window.clearInterval(intervalID);</p><p>clearInterval()方法取消了先前通过调用setInterval()建立的定时器</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this指向问题 一般情况下this的最终指向的是那个调用它的对象</p><ol><li><p>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</p></li><li><p>方法调用中谁调用this指向谁</p></li><li><p>构造函数中this指向构造函数的实例</p></li></ol><h2 id="JS执行队列"><a href="#JS执行队列" class="headerlink" title="JS执行队列"></a>JS执行队列</h2><h3 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一时间只能做一件事</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>如果执行过程中有一步需要等待很长时间，就会造成页面渲染不连贯。为了解决这个问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。于是，JS中出现了同步和异步。</p><p><strong>同步：</strong>前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</p><p><strong>异步：</strong>如果做一件事花费的时间很长，在做一件事的同时，可以处理其他事情。</p><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>同步任务都在主线程上执行，形成一个执行线。</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>JS的异步是通过回调函数实现的</p><p>一般而言，异步任务有以下三种类型：</p><p>1、    普通事件，如 click、resize等</p><p>2、    资源加载，如load、error等</p><p>3、    定时器，包括setInterval、setTImeout等</p><p>异步任务相关回调函数添加到<strong>任务队列</strong>中（任务队列也称为消息队列）</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/%E6%89%A7%E8%A1%8C.png"></p><h4 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h4><ol><li><p>先执行<strong>执行栈中的同步任务</strong></p></li><li><p>异步任务（回调函数）放入任务队列中。</p></li><li><p>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取<strong>任务队列</strong>中的异步任务，于是被读取的异步任务结束等待状态，进入执行线，开始执行。</p></li></ol><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为<strong>事件循环（event loop）</strong>。</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/qd516.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/1d56w.png"></p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>window对象给我们提供了一个<strong>location属性</strong>用于<strong>获取或设置窗体的URL</strong>，并且可以用于<strong>解析URL</strong>。因为这个属性返回的是一个对象，所以我们将这个属性也称为<strong>location对象</strong>。</p><p>URL：统一资源定位符（Uniform Resource Locator，URL）是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p>URL的一般语法格式为：</p><p> <strong>protocol://host[:port]/path/[?query]#frament</strong></p><p>例：<a href="http://www.amaodama.com/index.html?name=amao&amp;age22#link">http://www.amaodama.com/index.html?name=amao&amp;age22#link</a></p><p>protocol：通信协议 常用的http,ftp,maito等等</p><p>host：主机（域名）</p><p>port：端口号 可选，省略时使用方案的默认端口，如http的默认端口为80</p><p>path：路径 由 零或多个‘/’符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</p><p>query：参数 以键值对的形式，通过&amp;符号分隔开来</p><p>fragment：片段#后面内容 常见于链接锚点</p><h3 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage014.png"></p><p><strong>重点记住：href和search</strong></p><h3 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage015.png"></p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象<strong>包含有关浏览器的信息</strong>，它有很多属性，最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值。即得知是什么浏览器。</p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>该对象包含用户（在浏览器窗口中）访问过的URL</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage016.png"></p><h1 id="PC端网页特效"><a href="#PC端网页特效" class="headerlink" title="PC端网页特效"></a>PC端网页特效</h1><h2 id="元素offset系列"><a href="#元素offset系列" class="headerlink" title="元素offset系列"></a>元素offset系列</h2><h3 id="offset概述"><a href="#offset概述" class="headerlink" title="offset概述"></a>offset概述</h3><p>offset翻译过来就是偏移量，使用offset系列相关属性可以<strong>动态的</strong>得到该属性的位置（偏移）、大小等。</p><ul><li>获得元素距离带有定位父元素的位置</li></ul><ul><li>获得元素自身的大小</li></ul><p><strong>注意：返回的数值都不带单位</strong></p><h3 id="offset系列常用属性"><a href="#offset系列常用属性" class="headerlink" title="offset系列常用属性"></a>offset系列常用属性</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage017.png"></p><p>element.parentNode也可以返回父节点，返回的是最近一级的父节点。</p><p>element.offsetParent返回带有定位的父节点</p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage018.png"></p><h3 id="offset和style区别"><a href="#offset和style区别" class="headerlink" title="offset和style区别"></a>offset和style区别</h3><p><strong>offset</strong></p><p>offset可以得到任何样式表中的样式值</p><p>offset系列获得的数值是没有单位的</p><p>offsetWIdth包含padding + border + width</p><p>offsetWidth等属性是只读属性，只能获取不能赋值</p><p>获取元素大小位置，用offset更合适</p><p><strong>style</strong></p><p>style只能得到行内样式表的样式值</p><p>style.width获得的是带有单位的</p><p>style可以赋值</p><p>给元素位置赋值，用style更合适</p><h2 id="元素可视区client系列"><a href="#元素可视区client系列" class="headerlink" title="元素可视区client系列"></a>元素可视区client系列</h2><p>client就是客户端，使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage019.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage020.png"> </p><p><strong>立即执行函数（function () {}）() 或者 （function（）{}（））</strong></p><p><strong>立即执行函数最大的作用是 独立创建了一个作用域，避免了命名冲突问题</strong></p><p><strong>pageshow： 重新加载页面触发的事件 添加给window</strong></p><h2 id="为什么用pageshow不用load事件？"><a href="#为什么用pageshow不用load事件？" class="headerlink" title="为什么用pageshow不用load事件？"></a>为什么用pageshow不用load事件？</h2><p><strong>有三种情况会刷新页面触发load事件：a标签的超链接、F5或者刷新按钮、前进后退按钮</strong></p><p><strong>但是火狐浏览器有“往返缓存”，保存了DOM和JavaScript的状态；此时后退按钮不能刷新页面。</strong></p><p><strong>这时候可以使用pageshow事件触发。这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发。</strong></p><p>根据事件对象中的<strong>persisted</strong>来判断<strong>是否是缓存中的页面触发</strong>的pageshow事件。</p><h2 id="元素滚动scroll系列"><a href="#元素滚动scroll系列" class="headerlink" title="元素滚动scroll系列"></a>元素滚动scroll系列</h2><p>scroll翻译过来就是滚动，scroll系列相关属性可以动态的得到该元素的大小、滚动距离。<strong>（元素内容的实际高度大小）</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage021.png"></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage022.png"></p><p><strong>页面被卷去的头部：可以通过window.pageYOffset获得 如果是被卷去的左侧 window.pageXOffset</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage023.png"></p><p>DTD：<!DOCTYPE html></p><p><strong>三个系列对比</strong></p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage024.png"></p><p>主要用法：</p><ol><li><p>offset系列经常用于获得元素位置 <strong>offsetLeft offsetTop</strong></p></li><li><p>client经常用于获取元素大小 <strong>clientWidth clientHeight</strong></p></li><li><p>scroll经常用于获取滚动距离 <strong>scrollTop scrollLeft</strong></p></li><li><p>注意页面滚动的距离通过window.pageXOffset获得</p></li></ol><h2 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h2><p>mouseenter和mouseover都是鼠标移到元素上就会触发的事件</p><p>区别：mouseover鼠标<strong>经过自身盒子会触发</strong>，经过<strong>子盒子还会触发</strong>。mouseenter<strong>只会经过自身盒子触发</strong>。之所以这样，就是因为<strong>mouseenter不会冒泡</strong></p><p>跟mouseenter搭配mouseleave，同样也不会冒泡</p><h2 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h2><h3 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h3><p><strong>核心原理</strong>：通过定时器setInterval（）不断移动盒子位置。</p><p>实现步骤：</p><p>1.获得盒子当前位置</p><p>2.让盒子在当前位置加上1个移动距离</p><p>3.利用定时器不断重复这个操作</p><p>4.加一个结束定时器的条件</p><p><strong>5.注意此元素需要添加定位，才能使用element.style.left</strong></p><h3 id="动画函数简单的封装"><a href="#动画函数简单的封装" class="headerlink" title="动画函数简单的封装"></a>动画函数简单的封装</h3><p>注意函数需要传递2个参数，对象和移动距离</p><h3 id="动画函数给不同元素记录不同定时器"><a href="#动画函数给不同元素记录不同定时器" class="headerlink" title="动画函数给不同元素记录不同定时器"></a>动画函数给不同元素记录不同定时器</h3><p>如果多个元素都使用这个动画函数，每次都要var声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）</p><p>核心原理：利用JS是一门动态语言，可以很方便的给当前对象添加属性。</p><h3 id="缓动效果原理"><a href="#缓动效果原理" class="headerlink" title="缓动效果原理"></a>缓动效果原理</h3><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p><p>思路：</p><p>1.让每次移动距离慢慢变小，速度就会慢慢落下来</p><p>2.核心算法：（目标值-当前位置）/ 10 作为每次移动的距离步长</p><p>3.停止条件：让当前盒子位置等于目标位置就停止定时器。</p><h3 id="动画函数添加回调函数"><a href="#动画函数添加回调函数" class="headerlink" title="动画函数添加回调函数"></a>动画函数添加回调函数</h3><p><strong>回调函数原理：</strong>函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。</p><h3 id="动画函数封装到单独JS文件里面"><a href="#动画函数封装到单独JS文件里面" class="headerlink" title="动画函数封装到单独JS文件里面"></a>动画函数封装到单独JS文件里面</h3><p>经常用到这个函数，就单独创建js文件，把函数放进去。</p><p>轮播图</p><p>图片放在一个大ul，通过移动ul实现滚动效果。</p><p>无缝滚动效果：在最后一张后面复制一份第一张克隆，等到达克隆张，下次点击快速到达第一张，</p><p><strong>节流阀</strong></p><p>目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p><p>题外话：</p><p>if（callback）{callback（）；} == callback &amp;&amp; callback（）；</p><p>运用了短路运算符的特性，当两个都为true时，才会调用函数。</p><h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><p>window.scroll(x, y); 里面的xy不跟单位；</p><h1 id="移动端特效"><a href="#移动端特效" class="headerlink" title="移动端特效"></a>移动端特效</h1><h3 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h3><p>移动端浏览器兼容性较好，不需要考虑JS兼容性问题。但移动端也有独特的地方，比如触屏事件touch。</p><p>touch对象代表一个触摸点。</p><p>常见的触屏事件如下</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage025.png"></p><h4 id="触摸事件对象"><a href="#触摸事件对象" class="headerlink" title="触摸事件对象"></a>触摸事件对象</h4><p>每个事件都有对象产生</p><p>触摸事件对象常见的对象类别：</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage026.png"></p><p>如果监听的是一个DOM元素，touches和targetTouches一样。</p><p>手指离开屏幕，只有changedTouches还在。</p><p>一般都是触摸元素，最经常用targetTouches。</p><p><strong>注意：手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault();</strong></p><h3 id="移动端轮播图"><a href="#移动端轮播图" class="headerlink" title="移动端轮播图"></a>移动端轮播图</h3><p>要前后放两张图片（第一张和最后一张），同时为了显示第一张图片，ul要margin-left：-100%；移动一张图片的位置。</p><p>transitionend：过渡效果结束的时候触发。</p><h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。</p><p>添加类名：classList.add(‘类名’);</p><p>移除类名：classList.remove(‘类名’)；</p><p>切换类名：classList.toggle(‘类名’); //原来有就删除，没有就添加。</p><h3 id="click延时解决方案"><a href="#click延时解决方案" class="headerlink" title="click延时解决方案"></a>click延时解决方案</h3><p>点了第一下，300ms没有点第二下，就判断是点击。</p><p>移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放页面。</p><p>解决方案：</p><ol><li>禁用缩放。浏览器禁用默认的双击缩放行为并且去掉300ms的点击延迟。</li></ol><meta name=”viewport” content=”user-scalable=no”>2. 利用touch事件自己封装这个事件解决300ms延迟。<ol start="3"><li>利用fastclick插件解决（GitHub上找）</li></ol><p><strong>视频插件：zy.media.js</strong></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。</p><p>常用框架：bootstrap、vue、angular、react等</p><p>移动端常用插件：swiper、superslide、iscroll等</p><p>框架：大而全，一整套解决方案</p><p>插件：小而专一，某个功能的解决方案</p><h1 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h1><p>特性：1.数据存储在用户浏览器中</p><p>2.设置、读取方便、甚至页面刷新不丢失数据</p><p>3.容量较大，sessionStorage约5M、localStorage约20M</p><p>4.只能存储字符串，可以将对象JSON.stringfy()编码后存储</p><h2 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h2><ol><li><p>生命周期为<strong>关闭浏览器窗口</strong>（即关闭浏览器就消失）</p></li><li><p>在同一个窗口（页面）下数据可以共享</p></li><li><p>以键值对的形式存储使用</p></li></ol><p>存储数据：sessionStorage.setItem(key, value);</p><p>获取数据：sessionStorage.getItem(key);</p><p>删除数据：sessionStorage.removeItem(key);</p><p>清空数据：sessionStorage.clear();</p><h2 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h2><ol><li><p>生命周期<strong>永久生效</strong>，除非手动删除</p></li><li><p>可以多窗口（页面）共享（同一浏览器可以共享）</p></li><li><p>以键值对的形式存储使用</p></li></ol><p>存储数据：localStorage.setItem(key, value);</p><p>获取数据：localStorage.getItem(key);</p><p>删除数据：localStorage.removeItem(key);</p><p>清空数据：localStorage.clear();</p><p>change: 状态改变触发事件。</p><h1 id="JavaScript面向对象"><a href="#JavaScript面向对象" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h1><h2 id="面向对象编程介绍"><a href="#面向对象编程介绍" class="headerlink" title="面向对象编程介绍"></a>面向对象编程介绍</h2><p>面向过程（POP）就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p><p>即面向过程就是分析好问题，按步骤解决。</p><p>面向对象（OOP）是把事务分解成为一个个对象，然后由对象之间分工与合作。</p><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。</p><p>面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</p><p>特性：<strong>封装性 继承性 多态性</strong></p><p>缺点：面向对象性能比面向过程低</p><p><strong>通俗的讲：用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭</strong></p><h2 id="ES6中的类与对象"><a href="#ES6中的类与对象" class="headerlink" title="ES6中的类与对象"></a>ES6中的类与对象</h2><p><strong>在JavaScript中，对象是一组无序的相关属性和方法集合，所有事物都是对象。</strong></p><p>对象是由<strong>属性</strong>和<strong>方法</strong>组成的：</p><p>属性：事物的<strong>特征</strong>，在对象中用<strong>属性</strong>来表示</p><p>方法：事物的<strong>行为</strong>，在对象中用<strong>方法</strong>来表示</p><p>类：class ES6新增了类的概念 类抽象了对象的公共部分，它<strong>泛指</strong>某一大类（class）<strong>对象</strong>特指某一个，通过<strong>类</strong>实例化一个具体对象</p><p>面向对象的思维特点：</p><ol><li><p>抽取（抽象）对象共用的属性和行为组织（封装）成一个<strong>类</strong>（模板）</p></li><li><p>对类进行实例化，获取类的<strong>对象</strong></p></li></ol><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>语法：class name{ //class body} 创建实例： var xx = new name（）；</p><p><strong>注意：类必须使用new实例化对象</strong></p><h3 id="类constructor构造函数"><a href="#类constructor构造函数" class="headerlink" title="类constructor构造函数"></a>类constructor构造函数</h3><p><strong>constructor（）</strong>方法是类的构造函数（默认方法），<strong>用于传递参数，返回实例对象</strong>，通过new命令生成对象实例时，自动调用该方法。如果没有显示定义，类内部会自动给我们创建一个<strong>constructor（）</strong></p><p>注意</p><ol><li><p>通过class关键字创建类，<strong>类名我们还是习惯性定义首字母大写</strong></p></li><li><p>类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象</p></li><li><p>constructor函数只要new生成实例时，就会自动调用这个函数，如果我们不写这个函数，类也会自动生成这个函数</p></li><li><p>生成实例new不能省略</p></li><li><p>最后注意语法规范，创建类 类名后面不要加小括号，生成实例 类名后面加小括号，<strong>构造函数不需要加function</strong></p></li><li><p>多个函数和方法之间不需要逗号分隔</p></li></ol><h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><p>子类可以继承父类，使用父类中的属性和方法。</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p><strong>super关键字</strong>用于访问和调用对象父类上的函数。<strong>可以调用父类的构造函数（super(参数)）</strong>，也可以调用父类的普通函数（**super.方法()**）。</p><p>1.继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的这个方法。如果没有就查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原则）</p><p>2.<strong>super必须在this前面调用</strong></p><p><strong>注意点</strong></p><ol><li><p>在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p></li><li><p>类里面的共有的属性和方法一定要加this使用。</p></li><li><p>类里面的this指向问题</p></li><li><p>constructor里面的this指向实例对象，方法里面的this指向这个方法的调用者</p></li></ol><p><strong>添加元素高级做法</strong>：利用**insertAdjacentHTML(position, text)**可以直接把字符串格式元素添加到父元素中。</p><p><strong>position参数</strong></p><p><strong>beforebegin:元素自身的前面</strong></p><p><strong>afterbegin:插入元素内部的第一个子节点之前<br> beforeend:插入元素内部的最后一个子节点之后</strong></p><p><strong>afterend:元素自身的后面</strong></p><p><strong>remove()</strong> <strong>可以删除指定的元素 例：element.remove();</strong></p><h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在典型的OOP的语言中（如java），都存在类的概念，类就是对象的模板，对象就是类的实例，但是在ES6之前没有类的概念。</p><p>创建对象可以通过以下三种方式：</p><ol><li><p>对象字面量   例：var xx = {}</p></li><li><p>new Object（）</p></li><li><p>自定义构造函数</p></li></ol><p><strong>构造函数</strong>时一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在js中，使用构造函数时要注意以下两点：</p><ol><li><p>构造函数用于创建某一类对象，其<strong>首字母要大写</strong></p></li><li><p>构造函数要<strong>和new一起使用</strong>才有意义</p></li></ol><p>静态成员 在构造函数本身上添加的成员 sex就是静态成员</p><p>静态成员只能通过构造函数来访问</p><p>构造函数问题：<strong>存在浪费内存的问题</strong></p><h3 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h3><p>构造函数通过原型分配的函数是所有对象所<strong>共享</strong>的。</p><p>JavaScript规定，<strong>每一个构造函数都有一个prototype属性</strong>，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p><strong>我们可以把一些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。</strong></p><p>原型的作用是什么？<strong>共享方法</strong></p><p>语法：函数名.prototype.方法 = function（）{}</p><p>所以，一般情况下，公共属性定义到构造函数里面，公共的方法放到原型对象身上</p><h3 id="对象原型proto"><a href="#对象原型proto" class="headerlink" title="对象原型proto"></a>对象原型proto</h3><ul><li><p><strong>对象都会有一个属性<strong>proto</strong></strong>指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有__proto__原型的存在。（即__proto__对象原型和原型对象prototype是等价的）</p></li><li><p>__proto__是非标准的，实际开发不可以使用这个属性。他只是内部指向原型对象prototype的一条路线。</p></li></ul><p>方法查找原则：查找对象身上是否有指定方法，因为有__proto__，就接着查找构造函数原型对象prototype身上去查找。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage027.png"></p><h3 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h3><p>如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须<strong>手动的利用constructor指向</strong>原来的构造函数</p><p>例：函数名.prototype = { //通过这个方式给原型添加多个方法，但这样就把原来原型的方法覆盖掉了</p><p>constructor：函数名，//指回原来的构造函数</p><p>}</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage028.png"></p><h4 id="JS成员的查找机制"><a href="#JS成员的查找机制" class="headerlink" title="JS成员的查找机制"></a>JS成员的查找机制</h4><ol><li><p>当访问一个对象的属性（包括方法）时，首先查找这个<strong>对象自身</strong>有没有该属性。</p></li><li><p>如果没有就查找它的原型（也就是__proto__指向的<strong>prototype原型对象</strong>）。</p></li><li><p>如果还没有就查找原型对象的原型（<strong>Object的原型对象</strong>）。</p></li><li><p>依此类推一直找到Object为止（<strong>null</strong>）。</p></li></ol><h4 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h4><p>一般情况下，this指向的是调用函数的对象。</p><p>原型对象函数里面的this指向的是 实例对象</p><h4 id="扩张内置对象"><a href="#扩张内置对象" class="headerlink" title="扩张内置对象"></a>扩张内置对象</h4><p>可以通过内置对象原型，给内置对象添加方法。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>组合继承：（ES6前）构造函数 + 原型对象 模拟实现继承</p><p>call（） 调用这个函数，并且修改函数运行时的指向</p><p>语法：函数名.call(thisArg, arg1, arg2,—)</p><p><strong>thisArg：当前调用函数this的指向对象</strong></p><h5 id="借用父构造函数继承属性"><a href="#借用父构造函数继承属性" class="headerlink" title="借用父构造函数继承属性"></a>借用父构造函数继承属性</h5><p>例：子构造函数中</p><p>Father.call(this, 属性1，属性2)；//这样子构造函数就可以使用父构造函数中的属性。</p><h5 id="借用原型对象继承方法"><a href="#借用原型对象继承方法" class="headerlink" title="借用原型对象继承方法"></a>借用原型对象继承方法</h5><ol><li>直接赋值（误）</li></ol><p>Son.prototype = Father.prototype //这时候把父构造函数的原型对象地址给了子，子修改原型对象，父也会变化</p><ol start="2"><li>创建父实例，子==父实例</li></ol><p>例: Son.prototype = new Father(); //因为这样覆盖了子的constructor，所以要指回</p><p>Son.prototype.constructor = Son;</p><h2 id="ES5中新增的方法"><a href="#ES5中新增的方法" class="headerlink" title="ES5中新增的方法"></a>ES5中新增的方法</h2><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>迭代方法：</p><p>**forEach()**：遍历数据每一个数据 array.forEach(function(value, index, array){});</p><p><strong>filter():</strong> 主要用于筛选数组，找到所有满足条件的值，返回一个<strong>新数组</strong> arr.filter(function(value, index,array){})</p><p><strong>some():</strong> 检测数组中的元素是否满足指定条件，通俗点 查找数组中是否有满足条件的元素 返回值是<strong>布尔值</strong> 如果找到第一个满足条件的，就停止查找。</p><p>array.some(function(value, index, arr){});</p><p>map（）类似于forEach（）</p><p>every（）类似于some（）</p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>trim() 会从一个字符串的两端删除空白字符</p><p>str.trim() //返回新的字符串</p><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><ol><li><strong>Object.keys()</strong> 用于获取对象自身所有属性 效果类似for。。。in</li></ol><p>Object.keys(obj) //返回一个由属性名组成的数组</p><ol start="2"><li><strong>Object.defineProperty()</strong> 定义对象中新属性或修改原有的属性。</li></ol><p>Object.defineProperty(Obj, prop, descriptor)</p><p>第二个参数是属性名，字符串</p><p>第三个参数是descriptor说明：以对象形式{}书写，其中参数有</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage029.png"></p><p>重写就是修改的意思</p><p>枚举就是遍历的意思</p><p>configurable定义true后属性将不会被修改</p><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><ol><li><p>自定义函数 function fn() {}</p></li><li><p>函数表达式（匿名函数） var fun = function() {}</p></li><li><p>new Function  var fn = new Function(‘参数1’，’参数2’，’函数体’)；</p></li></ol><p>例：var fn = new Function(‘a’,’b’,’console.log(a+b)’);</p><p>不建议使用，效率低，但这种声明方式说明，所有函数都是Function的实例（对象），函数也属于对象</p><h3 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h3><ol><li>普通函数</li></ol><p>function fn() { }  fn();</p><ol start="2"><li>对象方法</li></ol><p>var o = {             o.fn();</p><p>fn: function(){}</p><p>}                 </p><ol start="3"><li>构造函数</li></ol><p>function Star(){}  new Star();</p><ol start="4"><li>绑定事件函数</li></ol><p>btn.onclick = function() {}; </p><ol start="5"><li>定时器函数</li></ol><p>setInterval(function() {}, 1000)</p><ol start="6"><li>立即执行函数</li></ol><p>(function() {})();</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this的指向，是当我们调用函数的时候确定的。调用方式不同决定了this的指向不同。一般指向我们的调用者。</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage030.png"></p><p>构造函数this指向实例对象，原型对象中的this也是指向实例对象。</p><h3 id="改变函数内部this指向"><a href="#改变函数内部this指向" class="headerlink" title="改变函数内部this指向"></a>改变函数内部this指向</h3><p>常用的方法有bind(), call(), apply() 三种方法</p><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>语法：fn.call( thisArg, arg1, arg2, —);</p><p>作用：1. 可以调用函数 2. 可以改变函数内部的this指向</p><p>主要应用：可以实现继承</p><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>语法：fn.apply(thisArg, array);</p><p>作用：1. 调用函数 2. 可以改变函数内部的this指向</p><p>但是参数必须是数组（伪数组）</p><p>主要应用：可以利用apply借助于数学内置对象求最大值（ Math.max.apply(null, array) ）</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>语法：fn.bind(thisAsg, arg1, arg2,—-);</p><p>作用：1. <strong>不会调用函数</strong> 2. 可以改变函数内部的this指向</p><p>返回由指定的this值和初始化参数改造的<strong>原函数拷贝</strong></p><p>thisArg：当前调用函数this的指向对象</p><p>arg1,arg2：传递的其他参数</p><h4 id="call-apply-bind-总结"><a href="#call-apply-bind-总结" class="headerlink" title="call(), apply(), bind()总结"></a>call(), apply(), bind()总结</h4><ol><li><p>都可以改变函数内部this指向</p></li><li><p>call和apply可以调用函数，bind不调用函数</p></li><li><p>call、bind的参数一个一个传，apply的参数以数组方式传递</p></li><li><p>call主要用于继承，apply主要用于数组打交道的情况，bind用于不调用函数又要改变内部this指向。</p></li></ol><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES5的严格模式（strict mode）是采用具有限制性JavaScript变体的一种方式，即在严格的条件下运行JS代码。（IE10以上版本浏览器才支持）</p><ol><li><p>消除了JavaScript语法的一些不合理、不严谨之处，减少了一些怪异行为。</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全。</p></li><li><p>提高编译器效率，增加运行速度。</p></li><li><p>禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的JavaScript做好铺垫。比如保留字如class，export，import不能做变量名</p></li></ol><p>严格模式可以应用到整个脚本或个别函数中</p><ol><li>为脚本开启严格模式</li></ol><p>需要<strong>在所有语句之前放一个特定语句“use strict”；(或 ‘use strict’; )</strong></p><ol start="2"><li>为函数开启严格模式</li></ol><p>需要把<strong>“use strict”；(或 ‘use strict’; )声明放在函数体所有语句之前。</strong></p><h4 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h4><ol><li>变量规定</li></ol><ul><li><p><strong>严格模式下，变量都必须先用var命令声明，然后再使用。</strong></p></li><li><p><strong>严禁删除已经声明变量。例如，delete x；语法是错误的。</strong></p></li></ul><ol start="2"><li>严格模式下this指向问题</li></ol><ul><li><p><strong>严格模式下全局作用域函数中的this指向的是underfined</strong></p></li><li><p><strong>严格模式下不加new调用构造函数，会报错</strong></p></li><li><p><strong>定时器this还是指向window</strong></p></li><li><p><strong>事件、对象还是指向调用者</strong></p></li></ul><ol start="3"><li>函数变化</li></ol><ul><li><p><strong>函数不能有重名的参数</strong></p></li><li><p><strong>函数必须声明在顶层。为了与ES6接轨，不允许在非函数的代码块内声明函数。即不能在for、if等有大括号而不是函数的代码块中声明函数。</strong></p></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p><strong>高阶函数</strong>是对其他函数进行操作的函数，它<strong>接受函数作为参数</strong>或<strong>将函数作为返回值输出</strong>。</p><p>函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p><strong>闭包</strong>指有权<strong>访问</strong>另一个函数作用域中<strong>变量</strong>的<strong>函数</strong>。</p><p>简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。</p><p><strong>变量指向的函数就是闭包函数</strong></p><p>闭包的主要作用：<strong>延伸了变量的作用范围，使变量不会被立即释放</strong>。</p><p><strong>立即执行函数也称为小闭包</strong>因为立即执行函数里面的任何一个函数都可以调用它的变量。</p><p>缺点：<strong>比较占用内存</strong></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>定义：如果<strong>一个函数在内部可以调用其本身</strong>，那么这个函数就是<strong>递归函数</strong>。</p><p>由于递归很容易发生栈溢出错误，所以必须要加退出条件return</p><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><ol><li><p>浅拷贝只是拷贝一层，<strong>更深层次对象级别的只拷贝引用</strong></p></li><li><p>深拷贝拷贝多层，每一级别的数据都会拷贝</p></li><li><p><strong>Object.assign(target, …sources)</strong> es6新增方法可以<strong>浅拷贝</strong></p></li></ol><p>深拷贝就是把所有数据都拷贝过来，更深层次而不只是引用地址，从而会可能修改了原数据。深拷贝时要先拷贝数组数据，再拷贝对象。因为数组也属于对象。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><strong>概述：</strong>正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。</p><p>正则表单式里面不用加引号。</p><p>主要用途：</p><ol><li><p>通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户表单只能输入英文字母、数字或者下划线，昵称输入框中可以输入中文（<strong>匹配</strong>）。</p></li><li><p>常用于过滤掉页面内容中的一些敏感词（<strong>替换</strong>），或者从字符串中获取我们想要的特定部分（<strong>提取</strong>）等。</p></li></ol><p>特点：</p><ol><li><p>灵活性、逻辑性和功能性非常强</p></li><li><p>可以迅速的用极简单的方式达到字符串的复杂控制</p></li><li><p>刚开始比较晦涩难懂</p></li></ol><h4 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h4><p><strong>1.</strong>  <strong>通过调用RegExp对象的构造函数创建</strong></p><p>var 变量名 = new RegExp（/表达式/）；</p><p><strong>2.</strong>  <strong>通过字面量创建</strong></p><p>var 变量名 = /表达式/；</p><h4 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h4><p><strong>test（）</strong>正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false</p><p>regexpObj.test(str)</p><ol><li><p>regexp是写的正则表达式</p></li><li><p>str我们要测试的文本</p></li><li><p>就是检测str文本是否符合我们写的正则表达式规范。</p></li></ol><h4 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h4><p>正则表达式的组成</p><p>一个正则表达式<strong>可以由简单的字符构成</strong>，比如/abc/，<strong>也可以是简单和特殊字符的组合</strong>，比如/ab*c/。其中特殊字符也被称为<strong>元字符</strong>，在正则表达式中是具有<strong>特殊</strong>意义的专用<strong>符号</strong>，如^、$、+等。</p><p><strong>边界符</strong></p><p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</p><p> <img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage031.png"></p><p>/^abc$/意味着精准匹配abc，意为开头是它结尾也是它（同一个它）</p><p><strong>字符类</strong></p><p><strong>[ ]:</strong> 表示有一系列字符可供选择，只要匹配其中一个就可以了。</p><p><strong>-:</strong> 范围符，表示省略中间的字符，例如a-z，0-9</p><p><strong>字符组合：把要的字符都加进去，不用分隔，例如：a-zA-Z0-9_-</strong></p><p><strong>取反符：</strong>如果<strong>中括号里面有^ 表示取反的意思</strong> 和边界符完全不同</p><p><strong>量词符</strong></p><p>量词符用来<strong>设定某个模式的出现的次数</strong></p><p>*<strong>**     **相当于 &gt;=0 可以出现0次或者很多次</strong></p><p><strong>+</strong>     <strong>相对于&gt;=1 可以出现1次或者很多次</strong></p><p><strong>?</strong>     <strong>相当于1 || 0</strong></p><p><strong>{n}</strong>     <strong>就是重复n次</strong></p><p><strong>{n，}    大于等于n次</strong></p><p><strong>{n，m}   大于等于n次并且小于等于m次（中间不要有空格）</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage032.png"></p><p><strong>括号总结</strong></p><p><strong>大括号</strong> 量词符，里面表示重复次数</p><p><strong>中括号</strong> 字符集合。匹配方括号中的任意字符。</p><p><strong>小括号</strong> 表示分组</p><p>可以在线测试：<a href="http://c.runoob.com/">http://c.runoob.com/</a></p><p>注意</p><p>/^abc{2}$/ 匹配的是abcc</p><p>/^(abc){2}$/ 匹配的是abcabc</p><p><strong>预定义类</strong></p><p>预定义类指的是<strong>某些常见模式的简写方式</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage033.png"></p><p>小写要，大写不要</p><p><strong>|</strong> <strong>表示或者</strong> 例：/^red | green $/ 匹配red或者green字符串</p><p><strong>替换</strong></p><p>replace替换</p><p>replace（）方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p><p>string.replace(substr/regexp,replacement)</p><p>第一个参数：被替换的字符串或者正则表达式</p><p>第二个参数：替换为的字符串</p><p>返回值是一个替换完毕的新字符串</p><p><strong>正则表达式参数</strong></p><p>/表达式/[switch]</p><p>switch（也称为修饰符）按照什么样的模式来匹配。有三种值：</p><p><strong>g：全局匹配</strong></p><p><strong>i：忽略大小写</strong></p><p><strong>gi：全局匹配 + 忽略大小写</strong></p><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="let变量"><a href="#let变量" class="headerlink" title="let变量"></a>let变量</h2><p>let声明的变量会与当前块级作用域绑定，不被其他块级作用域访问。</p><p>特点：</p><ol><li>let声明的变量只在所处于的块级作用域有效</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>&#125;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span></code></pre><p>例如：for循环中，索引值就不会变成全局变量而访问到，而且每一次循环都保留着它的i值。</p><ol start="2"><li>不存在变量提升</li></ol><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span></code></pre><ol start="3"><li>暂时性死区</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;tmp = <span class="hljs-string">&#x27;abc&#x27;</span><span class="hljs-keyword">let</span> tmp&#125;</code></pre><p>tmp只看当前块级作用域中的变量，不再往上查找。</p><h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>作用：声明常量，常量就是值（内存地址）不能变化的量。</p><p>特点：</p><ul><li>具有块级作用域</li></ul><ul><li>声明常量时必须赋值</li></ul><h2 id="let、const、var区别"><a href="#let、const、var区别" class="headerlink" title="let、const、var区别"></a>let、const、var区别</h2><ol><li><p>使用 <strong>var</strong> 声明的变量，其作用域为<strong>该语句所在的函数内，且存在变量提升现象。</strong> </p></li><li><p>使用 <strong>let</strong> 声明的变量，其作用域为<strong>该语句所在的代码块内，不存在变量提升。</strong> </p></li><li><p>使用 <strong>const</strong> 声明的是常量，在后面出现的代码中<strong>不能再修改该常量的值。</strong></p><p><img src="https://pic-1304376225.cos.ap-guangzhou.myqcloud.com/img/jsimage037.png"></p></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6中允许从数组或对象中提取值，按照对应位置，对变量赋值。</p><p>如果解构不成功，变量的值为underfined。</p><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;<span class="hljs-keyword">let</span> &#123; name, age &#125; = person<span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// 20</span></code></pre><p>也可以用属性名匹配对象，用变量实际赋值</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge &#125; = person<span class="hljs-built_in">console</span>.log(myName) <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><span class="hljs-built_in">console</span>.log(myAge) <span class="hljs-comment">// 20</span></code></pre><h3 id="箭头函数（-gt-）"><a href="#箭头函数（-gt-）" class="headerlink" title="箭头函数（ ( )=&gt; { } ）"></a>箭头函数（ ( )=&gt; { } ）</h3><p>ES6中新增的定义函数的方式。用来简化函数定义语法的。<strong>一般把它赋值给一个变量，变量名就是函数名。</strong></p><p>特点：</p><ul><li>函数体中只有一句代码，且代码的执行结果就是<strong>返回值</strong>，可以省略大括号</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<span class="hljs-keyword">return</span> num1 + num2&#125;<span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> num1 + num2</code></pre><ul><li>如果形参只有一个，可以省略小括号</li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">v</span>) </span>&#123;<span class="hljs-keyword">return</span> v&#125;<span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v</code></pre><ul><li>箭头函数不绑定this关键字。如果在箭头函数中使用this，<strong>this关键字指向箭头函数定义位置的this</strong></li></ul><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">first, ...args</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(first)<span class="hljs-built_in">console</span>.log(args)&#125;sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</code></pre><p>注：剩余参可以数和解构配合使用</p><h2 id="Array的扩展方法"><a href="#Array的扩展方法" class="headerlink" title="Array的扩展方法"></a>Array的扩展方法</h2><h3 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h3><ul><li>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]...ary <span class="hljs-comment">// 1, 2, 3</span><span class="hljs-built_in">console</span>.log(...ary) <span class="hljs-comment">// 1 2 3</span></code></pre><ul><li>扩展运算符可以将两个数组分散合并成一个数组</li></ul><ul><li>将类数组或可遍历对象转换为真正的数组</li></ul><h3 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h3><p>将类数组或可遍历对象转换为真正的数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>length: <span class="hljs-number">3</span>&#125;<span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.from(arrayLike) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></code></pre><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><h3 id="实例方法：find（）"><a href="#实例方法：find（）" class="headerlink" title="实例方法：find（）"></a>实例方法：find（）</h3><p>用于找出第一个符合条件的数组成员，<strong>返回当前项</strong>，如果没有找到返回underfined</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [&#123;id: <span class="hljs-number">1</span>,name: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;， &#123;id: <span class="hljs-number">2</span>,name: <span class="hljs-string">&#x27;李四&#x27;</span>]<span class="hljs-keyword">let</span> target = ary.find(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item.id == <span class="hljs-number">2</span>)</code></pre><h3 id="实例方法：findIndex（）"><a href="#实例方法：findIndex（）" class="headerlink" title="实例方法：findIndex（）"></a>实例方法：findIndex（）</h3><p>用于找出第一个符合条件的数组成员的位置，<strong>返回索引值</strong>，如果没有就返回-1</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]<span class="hljs-keyword">let</span> index = ary.findIndex(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> value &gt; <span class="hljs-number">9</span>)<span class="hljs-built_in">console</span>.log(index) <span class="hljs-comment">// 2</span></code></pre><h3 id="实例方法：includes（）"><a href="#实例方法：includes（）" class="headerlink" title="实例方法：includes（）"></a>实例方法：includes（）</h3><p>表示某个数组是否包含给定的值，<strong>返回布尔值</strong>。</p><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>) <span class="hljs-comment">// false</span></code></pre><h2 id="String的扩展方法"><a href="#String的扩展方法" class="headerlink" title="String的扩展方法"></a>String的扩展方法</h2><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>ES6新增的创建字符串的方式，使用反引号定义。</p><p>例：let name = ‘zhangsan’;</p><p>特点：</p><ul><li>模板字符串中可以<strong>解析变量</strong>（加变量）用**${ }**包裹</li></ul><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;张三&#x27;</span><span class="hljs-keyword">let</span> sayHello = <span class="hljs-string">`hello, my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span> <span class="hljs-comment">// hello, my name is 张三</span></code></pre><ul><li>模板字符串可以<strong>换行</strong></li></ul><ul><li>在模板字符串中<strong>可以调用函数</strong>，得到函数的返回值。</li></ul><h3 id="实例方法：startWith-和-endsWith"><a href="#实例方法：startWith-和-endsWith" class="headerlink" title="实例方法：startWith() 和 endsWith()"></a>实例方法：startWith() 和 endsWith()</h3><p>startWith()：表示参数字符串是否在原字符串的头部，返回布尔值</p><p>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</p><p>例：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world&#x27;</span>str.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span>str.endWith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-comment">// true</span></code></pre><h3 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h3><p>repeat方法表示将原字符串重复n次，返回一个新字符串</p><pre><code class="hljs js"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;xxx&quot;</span><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;hellohello&quot;</span></code></pre><h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成Set数据结构。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()</code></pre><p>Set函数可以接受一个数值作为参数，用来初始化。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</code></pre><p>Set默认去重，size是它的长度</p><p>实例方法</p><p>add（value）：添加某个值，返回Set结构本身</p><p>delete（value）：删除某个值，返回一个布尔值，表示删除成功</p><p>has（value）：返回一个布尔值，表示该值是否为Set的成员</p><p>clear（）：清除所有成员，没有返回值</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>) <span class="hljs-comment">// 向set结构中添加值</span>s.delete(<span class="hljs-number">2</span>) <span class="hljs-comment">// 删除set结构中的2值</span>s.has(<span class="hljs-number">1</span>) <span class="hljs-comment">// 表示set结构中是否有1这个值 返回布尔值</span>s.clear() <span class="hljs-comment">// 清除set结构中的所有值</span></code></pre><p>遍历</p><p>Set结构的实例和数组一样，也拥有forEach方法，用于对每个成员某种操作，没有返回值。</p><p>s.forEach( value =&gt; console.log(value) )</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记都在电脑本地，是word文档，在转markdown了</title>
    <link href="/2020/11/18/hello-world/"/>
    <url>/2020/11/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>有点麻烦，要把word里面的图片重新保存再上传</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
